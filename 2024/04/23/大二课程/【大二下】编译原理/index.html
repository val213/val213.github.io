<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>编译原理 | Val-Blog</title><meta name="author" content="Val,10425999@qq.com, val213666@gmail.com"><meta name="copyright" content="Val"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="2024考纲IntroductionMaster: the phases of a compiler.Understand: what is a compiler. All the concepts about the compiler stagesYou Should be familiar with each stage of the compiler, and describe the wh">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理">
<meta property="og:url" content="https://val213.github.io/2024/04/23/%E5%A4%A7%E4%BA%8C%E8%AF%BE%E7%A8%8B/%E3%80%90%E5%A4%A7%E4%BA%8C%E4%B8%8B%E3%80%91%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Val-Blog">
<meta property="og:description" content="2024考纲IntroductionMaster: the phases of a compiler.Understand: what is a compiler. All the concepts about the compiler stagesYou Should be familiar with each stage of the compiler, and describe the wh">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2024-04-23T10:57:36.557Z">
<meta property="article:modified_time" content="2024-11-02T12:55:27.282Z">
<meta property="article:author" content="Val">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://val213.github.io/2024/04/23/%E5%A4%A7%E4%BA%8C%E8%AF%BE%E7%A8%8B/%E3%80%90%E5%A4%A7%E4%BA%8C%E4%B8%8B%E3%80%91%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: Val","link":"Link: ","source":"Source: Val-Blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '编译原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-02 20:55:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://github.com/val213/image/blob/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230630230143.jpg?raw=true" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">128</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">104</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Val-Blog"><span class="site-name">Val-Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">编译原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-04-23T10:57:36.557Z" title="Created 2024-04-23 18:57:36">2024-04-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-11-02T12:55:27.282Z" title="Updated 2024-11-02 20:55:27">2024-11-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="编译原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="2024考纲"><a href="#2024考纲" class="headerlink" title="2024考纲"></a>2024考纲</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Master: the phases of a compiler.<br>Understand: what is a compiler. All the concepts about the compiler stages<br>You Should be familiar with each stage of the compiler, and describe the whole process in graph or text.</p>
<h2 id="Lexical"><a href="#Lexical" class="headerlink" title="Lexical"></a>Lexical</h2><p>Master: Write regular expression, the transition from regular expression to NFA, then to DFA, DFA minimization and the construction of scanner<br>Understand: Concept of regular expression, NFA, DFA<br>Be familiar with the expression of R.E.. Know the difference of R.E. and C.F.G, can translate each from the other. While given a R.E, know how to draw the NFA and DFA, and how to minimize it. </p>
<h2 id="C-F-G"><a href="#C-F-G" class="headerlink" title="C.F.G."></a>C.F.G.</h2><p>Understand: Context-free grammar, Derivation, Parse tree, Abstract syntax tree, ambiguous grammar. Total under all the concepts.<br>Be familiar with the grammar of C.F.G, know how to make a left/right most derivation. Given a set of grammar and an expression, can draw the parse tree and abstract syntax tree.</p>
<h2 id="Top-Down-Parsing"><a href="#Top-Down-Parsing" class="headerlink" title="Top-Down Parsing"></a>Top-Down Parsing</h2><p>Master: LL(1) grammar, Construction of Recursive-descent parsing, LL(1) parsing, Computing  First set and Follow set<br>Given the C.F.G, know the left factor and left recursion removal, and know how to compute its first/ follow set, know to judge if it is a LL(1) grammar，and know to construct the parsing table.</p>
<h2 id="Bottom-Up-Paring"><a href="#Bottom-Up-Paring" class="headerlink" title="Bottom-Up Paring:"></a>Bottom-Up Paring:</h2><p>Master:    LR(0) parsing, SLR(1) parsing<br>Understand: Right sentential form, Viable prefix, Handle<br>It must be easy of you to write out the right sentential form of a given C.F.G and expression, and figure out the variable prefix and handles. Know the difference of LR(0) and SLR(1). Knowing when will the ambiguities happen. What’s more, given the C.F.G, be able to write out its LR(0) items, draw the DFA, construct the SLR(1) parsing table, and know how to parse a expression according to it in a stack table step by step.</p>
<h2 id="Semantic"><a href="#Semantic" class="headerlink" title="Semantic:"></a>Semantic:</h2><p>Master:    Dependency graphs, Algorithms for attribute computation<br>Understand: Attribute grammar, Synthesized and Inherited attributes. S-attributes, L-attributes.<br>Know the task of semantic analysis, and the implementation method of it. Know how to compute the attribute values by given equations. Know how to draw a dependency graph, and how to label out the attributes or values to a parsing graph.</p>
<h2 id="Intermediate-Code-Generation"><a href="#Intermediate-Code-Generation" class="headerlink" title="Intermediate Code Generation:"></a>Intermediate Code Generation:</h2><p>Master: Intermediate code generation for basic structures：Three-address code; TAC for control structure, TAC for expression<br>Given context-free grammar and Attribute grammar, can translate the source code into TAC by SDT</p>
<p>考试题型 1）选择题 10题共20分；2）解答题 80分</p>
<h1 id="编译器组成"><a href="#编译器组成" class="headerlink" title="编译器组成"></a>编译器组成</h1><p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-255.png?raw=true" alt="alt text"></p>
<h1 id="lexical-analysis-词法分析-scanner"><a href="#lexical-analysis-词法分析-scanner" class="headerlink" title="lexical analysis 词法分析 (scanner)"></a>lexical analysis 词法分析 (scanner)</h1><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-256.png?raw=true" alt="alt text"></p>
<h3 id="Compound-Regular-Expressions"><a href="#Compound-Regular-Expressions" class="headerlink" title="Compound Regular Expressions"></a>Compound Regular Expressions</h3><ul>
<li>If R1 and R2 are regular expressions, <strong>R1R2</strong> is a regular expression represents the concatenation of the languages of R1 and R2.</li>
<li>If R1 and R2 are regular expressions,<strong>R1 | R2</strong> is a regular expression representing the union of R1 and R2.</li>
<li>If R is a regular expression, <strong>R*</strong> is a regular expression for the <strong>Kleene closure</strong> of R.</li>
<li>If R is a regular expression, <strong>R+</strong> is a regular expression for the <strong>positive closur</strong>e of R.</li>
<li>If R is a regular expression, <strong>(R)</strong> is a regular expression with the same meaning as R.</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul>
<li>for strings of length exactly four<ul>
<li>(0|1){4} = (0|1)(0|1)(0|1)(0|1)</li>
</ul>
</li>
<li>for strings that contain at most one zero:<ul>
<li>1<em>(0|ε)1</em> = 1*0?1*</li>
</ul>
</li>
<li>All strings not containing the substring 101<br>$0^\ast\left(1^\ast000^\ast\right)^\ast1^\ast0^\ast$</li>
<li>All strings having at least two occurrences of the substring 00<br>$\left(0|1\right)^\ast00\left(0|1\right)^\ast00\left(0|1\right)^\ast|\left(0|1\right)^\ast000\left(0|1\right)^\ast$</li>
<li>Comments, consisting of a string surrounded by /<em> and </em>/, without an intervening */, unless it is inside double-quotes (“)<br>$/o ( o^\ast( a | ” | ”o/” ) | / )^\ast o^+/$<ul>
<li><code>a</code> stands for all characters except <code>*</code> , <code>”</code> and <code>/</code></li>
<li><code>o</code> stands for <code>*</code></li>
</ul>
</li>
</ul>
<h3 id="Identifier"><a href="#Identifier" class="headerlink" title="Identifier"></a>Identifier</h3><ul>
<li>Identifier: strings of letters or digits, starting with a letter</li>
<li>letter = ‘A’ | … | ‘Z’ | ‘a’ | … | ‘z’ or letter = [A-Za-z]</li>
<li>digit = [0-9]</li>
<li>identifier = letter (letter | digit) *</li>
<li>Is (letter<em> | digit</em>) the same as (letter | digit) * ? <ul>
<li>NO</li>
</ul>
</li>
</ul>
<h3 id="Nondeterministic-Finite-Automata-NFA"><a href="#Nondeterministic-Finite-Automata-NFA" class="headerlink" title="Nondeterministic Finite Automata(NFA)"></a>Nondeterministic Finite Automata(NFA)</h3><p>RE-&gt;NFA</p>
<p>NFA has n states and m transitions;</p>
<ul>
<li>Can determine whether a string of length k matches NFA in time O(k(n+m)).</li>
</ul>
<h4 id="conflict-resolve"><a href="#conflict-resolve" class="headerlink" title="conflict resolve"></a>conflict resolve</h4><ul>
<li>maximal munch rule<ul>
<li>最长子串匹配</li>
</ul>
</li>
<li>adding priority rule<ul>
<li>设立优先级，关键字的优先级在identifier之上<h4 id="error-report"><a href="#error-report" class="headerlink" title="error report"></a>error report</h4></li>
</ul>
</li>
<li>Trick: Add a “catch-all” rule that matches any character and reports an error.</li>
<li>啥也没有match到意味着发生错误；</li>
<li>增加⼀台用于报错的机器，但是优先级设置为最低<h3 id="Deterministic-Finite-Automata-DFA"><a href="#Deterministic-Finite-Automata-DFA" class="headerlink" title="Deterministic Finite Automata(DFA)"></a>Deterministic Finite Automata(DFA)</h3>NFA-&gt;DFA</li>
</ul>
<p>Every state must have exactly one transition defined for every letter.</p>
<ul>
<li>ε-moves are not allowed.</li>
</ul>
<p>Two problems need to be solved in translation<br>1) Eliminate ε-transition<br>2) Eliminate multiple transitions from a state on a single character</p>
<h4 id="Subset-Construction-子集构造法"><a href="#Subset-Construction-子集构造法" class="headerlink" title="Subset Construction 子集构造法"></a>Subset Construction 子集构造法</h4><p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-257.png?raw=true" alt="alt text"></p>
<p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-258.png?raw=true" alt="alt text"></p>
<p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-259.png?raw=true" alt="alt text"></p>
<h4 id="Minimizing-Algorithm"><a href="#Minimizing-Algorithm" class="headerlink" title="Minimizing Algorithm"></a>Minimizing Algorithm</h4><p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-260.png?raw=true" alt="alt text"></p>
<h1 id="Syntax-Analysis-语法分析-parsing"><a href="#Syntax-Analysis-语法分析-parsing" class="headerlink" title="Syntax Analysis 语法分析 (parsing)"></a>Syntax Analysis 语法分析 (parsing)</h1><p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-262.png?raw=true" alt="alt text"></p>
<p>• Goal: Recover the structure described by that <strong>series of tokens</strong>.<br>• Goal: Report errors if those tokens do not properly encode a structure.</p>
<p>Specification of syntax structure : </p>
<ul>
<li>Context-free grammar (CFG)</li>
<li>Method of turning grammar rules into code for parsing<ul>
<li>Top-down parsing method</li>
<li>Bottom-up parsing method<h2 id="Formalisms-fot-syntax-analysis"><a href="#Formalisms-fot-syntax-analysis" class="headerlink" title="Formalisms fot syntax analysis"></a>Formalisms fot syntax analysis</h2></li>
</ul>
</li>
</ul>
<h2 id="Language-of-CFG"><a href="#Language-of-CFG" class="headerlink" title="Language of CFG"></a>Language of CFG</h2><p>RE 的构造能力有限，不能描述所有的语言。CFG可以描述更多的语言。使⽤context- free grammer能够展示信息以及构造结构的能⼒⽐regular expression强的多。</p>
<blockquote>
<p>Definition: A context-free grammar G= $(V_T,V_N,P,S)$:</p>
</blockquote>
<p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-261.png?raw=true" alt="alt text"></p>
<p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-263.png?raw=true" alt="alt text"><br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-264.png?raw=true" alt="alt text"></p>
<h3 id="RE-vs-CFG"><a href="#RE-vs-CFG" class="headerlink" title="RE vs CFG"></a>RE vs CFG</h3><p>CFG 中不能使用Kleene闭包，因为这样会导致无限递归。但是可以使用递归的产生式。</p>
<h3 id="Derivation-推导"><a href="#Derivation-推导" class="headerlink" title="Derivation 推导"></a>Derivation 推导</h3><p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-265.png?raw=true" alt="alt text"></p>
<h3 id="Sentence-and-Sentential-Form-句子和句型"><a href="#Sentence-and-Sentential-Form-句子和句型" class="headerlink" title="Sentence and Sentential Form 句子和句型"></a>Sentence and Sentential Form 句子和句型</h3><ul>
<li>Sentence: <strong>A string of terminal symbols</strong> that can be derived from the start symbol.</li>
<li>Sentential form: <strong>A string of terminal and nonterminal symbols</strong> that can be derived from the start symbol.</li>
<li>右句型 right sentential form: A sentential form that can be derived from the start symbol by a rightmost derivation.<br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-266.png?raw=true" alt="alt text"><h2 id="parse-tree-and-abstract-syntax-tree"><a href="#parse-tree-and-abstract-syntax-tree" class="headerlink" title="parse tree and abstract syntax tree"></a>parse tree and abstract syntax tree</h2>要将解析树转化成为抽象语法树</li>
<li>Function of parse trees<ul>
<li>A parse tree is a useful representation of the structure of a string of tokens</li>
<li>Parse trees represent derivations visually</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-267.png?raw=true" alt="alt text"></p>
<h2 id="Derivations-and-Parse-Trees"><a href="#Derivations-and-Parse-Trees" class="headerlink" title="Derivations and Parse Trees"></a>Derivations and Parse Trees</h2><p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-268.png?raw=true" alt="alt text"></p>
<ul>
<li>A parse tree has<ul>
<li>Terminals at the leaves</li>
<li>Non-terminals at the interior nodes</li>
</ul>
</li>
<li>A left-right traversal of the leaves is the original input</li>
<li>The parse tree shows the association of operations, the input string does not !</li>
<li>There may be multiple ways to match the input</li>
<li>Derivations (and parse trees) choose one</li>
<li>A parse tree of a string corresponds in general to many derivations of the string</li>
<li>Derivations do not uniquely represent the structure of the strings they construct, while parse trees do </li>
<li>Parse trees abstract the essential features of derivations while factoring out superficial difference in order<h3 id="Leftmost-Derivation"><a href="#Leftmost-Derivation" class="headerlink" title="Leftmost Derivation"></a>Leftmost Derivation</h3>Leftmost derivation</li>
<li>A derivation in which the leftmost nonterminal is replaced at each step in the derivation</li>
<li>It corresponds to <strong>a preorder traversal of the parse tree</strong><h3 id="Rightmost-derivation"><a href="#Rightmost-derivation" class="headerlink" title="Rightmost derivation"></a>Rightmost derivation</h3></li>
<li>Rightmost derivation</li>
<li>A derivation in which the rightmost non-terminal is replaced at each step in the derivation</li>
<li>It corresponds to the reverse of a postorder traversal of the parse tree<h3 id="Abstract-Syntax-Tree"><a href="#Abstract-Syntax-Tree" class="headerlink" title="Abstract Syntax Tree"></a>Abstract Syntax Tree</h3>The need of abstract syntax tree</li>
<li>A parse tree contains much more information than is absolutely necessary for a compiler to produce executable code<br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-269.png?raw=true" alt="alt text"><br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-270.png?raw=true" alt="alt text"><br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-271.png?raw=true" alt="alt text"><h2 id="ambiguity-二义性"><a href="#ambiguity-二义性" class="headerlink" title="ambiguity 二义性"></a>ambiguity 二义性</h2>对于grammer G，某⼀个string w拥有多于⼀个的不同的分析树（最左或者最右推导）那么就说这个grammar具有⼆义性。二义性来源于文法设计的不当。<h3 id="如何处理二义性"><a href="#如何处理二义性" class="headerlink" title="如何处理二义性"></a>如何处理二义性</h3>处理⼆义性的办法其实很简单，就是改变语法使之正确</li>
<li>Disambiguating rule 添加规则<ul>
<li>Example<ul>
<li>Rule 1: 优先级 Enforces precedence of * over – </li>
<li>Rule 2: 结合性 左联系 is left-associative</li>
<li>Rule 3：Most closely nested rule 就近嵌套原则</li>
</ul>
</li>
</ul>
</li>
<li>Rewriting the grammar 重写语法<br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-273.png?raw=true" alt="alt text"><br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-272.png?raw=true" alt="alt text"><br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-274.png?raw=true" alt="alt text"></li>
</ul>
<h3 id="Left-Recursion"><a href="#Left-Recursion" class="headerlink" title="Left Recursion"></a>Left Recursion</h3><p>什么是左递归，什么是右递归<br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-275.png?raw=true" alt="alt text"></p>
<h4 id="Elimination-of-Left-Recursion"><a href="#Elimination-of-Left-Recursion" class="headerlink" title="Elimination of Left Recursion"></a>Elimination of Left Recursion</h4><p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-276.png?raw=true" alt="alt text"></p>
<h3 id="Left-Factoring"><a href="#Left-Factoring" class="headerlink" title="Left Factoring"></a>Left Factoring</h3><p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-277.png?raw=true" alt="alt text"></p>
<h2 id="parsing-algorithm"><a href="#parsing-algorithm" class="headerlink" title="parsing algorithm"></a>parsing algorithm</h2><h3 id="Top-down-parsing-自顶向下"><a href="#Top-down-parsing-自顶向下" class="headerlink" title="Top-down parsing 自顶向下"></a>Top-down parsing 自顶向下</h3><p>Top-down parsing begins with virtually no information.</p>
<ul>
<li>Begins with just the start symbol, which matches every program</li>
</ul>
<p>An idea: treat parsing as a graph search</p>
<ul>
<li>Each node is a sentential form (a string of terminals and nonterminals derivable from the start symbol).</li>
<li>There is an edge from node α to node β iff α ⇒ β.</li>
</ul>
<p>多对多的关系，用图表示。节点是句子和句型，边是推导关系。Parsing as a Search</p>
<h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><h5 id="BFS的问题"><a href="#BFS的问题" class="headerlink" title="BFS的问题"></a>BFS的问题</h5><p>Enormous time and memory usage: </p>
<ul>
<li>Lots of wasted effort: 大量的无用工作<ul>
<li>Generates a lot of sentential forms that couldn’t possibly match.</li>
<li>But in general, extremely hard to tell whether a sentential form can match – that’s the job of parsing!</li>
</ul>
</li>
<li>High branching factor: 大量的分支<ul>
<li>Each sentential form can expand in (potentially) many ways for each nonterminal it contains.<h4 id="Leftmost-BFS"><a href="#Leftmost-BFS" class="headerlink" title="Leftmost BFS"></a>Leftmost BFS</h4><h4 id="Leftmost-DFS"><a href="#Leftmost-DFS" class="headerlink" title="Leftmost DFS"></a>Leftmost DFS</h4><h4 id="summary-of-Leftmost-BFS-DFS"><a href="#summary-of-Leftmost-BFS-DFS" class="headerlink" title="summary of Leftmost BFS/DFS"></a>summary of Leftmost BFS/DFS</h4><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-278.png?raw=true" alt="alt text"><h4 id="backtracking-回溯"><a href="#backtracking-回溯" class="headerlink" title="backtracking 回溯"></a>backtracking 回溯</h4>BFS剪枝，时间和空间开销大。</li>
</ul>
</li>
</ul>
<p>用BFS：进行图遍历搜索，复杂，时间复杂度过高，产生大量无用分支，时间和空间的最差情况都是指数级别。现代编译器中不被使用</p>
<p>剪枝：由终止符号做前缀时，如果无法与输入的前缀匹配则剪枝。(时，无法剪枝，因为前缀一直是非终止符号)</p>
<p>用DFS：有比BFS更好的空间复杂度和时间复杂度，但是无法匹配左递归，因为会一直循环。</p>
<h4 id="predictive-parsing-预测性分析"><a href="#predictive-parsing-预测性分析" class="headerlink" title="predictive parsing 预测性分析"></a>predictive parsing 预测性分析</h4><ul>
<li>The <strong>leftmost DFS/BFS algorithms</strong> are <strong>backtracking</strong> algorithms.<ul>
<li>Guess which production to use, then back up if it doesn‘t work.</li>
<li>Try to match a prefix by sheer dumb luck.</li>
</ul>
</li>
<li>There is another class of parsing algorithms called predictive algorithms.<ul>
<li>Based on remaining input, predict (without backtracking) which production to use.</li>
</ul>
</li>
</ul>
<p>Two Kinds of Predictive Parsing</p>
<ul>
<li>Recursive-descent parsing</li>
<li>LL(1) parsing</li>
</ul>
<p>Idea：利用<strong>先行词(lookahead tokens)</strong>，也就是上面提到过的<strong>终止符前缀</strong>。</p>
<p>从输入串和文法的开始符号开始分析</p>
<p>以当前input的token来独⼀⽆⼆地决定下⼀个被使⽤的production，parsing是预测性</p>
<p>预测分析文法包括LL(k)文法，其中L表示从左向右扫描，L表示最左推导，k表示“需要k个先行词用于预测”</p>
<p>LL(1)文法是常用的，也不完全常用。</p>
<h5 id="LL-1"><a href="#LL-1" class="headerlink" title="LL(1)"></a>LL(1)</h5><p>It’s definition depends on the definition of lookahead sets—First set and Follow set.</p>
<ul>
<li>lookahead sets: 用于预测的token集合。<h6 id="first-和-follow"><a href="#first-和-follow" class="headerlink" title="first 和 follow"></a>first 和 follow</h6></li>
<li>first set: 一个非终结符号的first set是它的所有产生式的first set的并集。</li>
</ul>
<p>Definition：</p>
<script type="math/tex; mode=display">G=(V_N, V_T, P, S) \text{ is a grammar,}</script><script type="math/tex; mode=display">β∈(V_N∪V_T)*</script><script type="math/tex; mode=display">FIRST(β) = { a ∊ V_T | β ⇒* a......}</script><script type="math/tex; mode=display">\text{ if } β⇒* ε \text{, then } ε ∊ FIRST(β)</script><ul>
<li>follow set: 一个非终结符号的follow set是它的所有产生式的follow set的并集。</li>
</ul>
<p>Definition:</p>
<script type="math/tex; mode=display">G=(VT, VN, S,P) \text{ is a grammar},A∈V_N ,</script><script type="math/tex; mode=display">FOLLOW(A)={a ∊ VT | S⇒*…Aa…},</script><script type="math/tex; mode=display">\text{if } S⇒* …A, \text{then dollar}  ∊ FOLLOW(A)</script><script type="math/tex; mode=display">(\text{dollar is used to mark the end of the input)}</script><h6 id="判断一个文法是否是LL-1-文法："><a href="#判断一个文法是否是LL-1-文法：" class="headerlink" title="判断一个文法是否是LL(1)文法："></a>判断一个文法是否是LL(1)文法：</h6><ul>
<li><p>可空的非终止符(nullable nonterminal), 如果一个非终止符号的产生式中有$\epsilon$，那么这个非终止符号是可空的。</p>
</li>
<li><p>计算产生式右侧所有的First(a)，并验证对于<strong>产生式</strong>$A \rightarrow \alpha | \beta $，如果不存在$\beta = \epsilon$，则验证FIRST($\alpha$)和FIRST($\beta$)两两交集是否为空。如果不为空，则不是LL(1)文法。</p>
</li>
<li>只有当一个<strong>非终结符号</strong>的first set和follow set没有交集时，这个文法才是LL(1)文法。</li>
<li>如果一个非终止符号的产生式中有$\epsilon$，那么需要考察这个非终止符号的follow set。First(A)和Follow(A)的交集为空才是LL(1)文法。</li>
</ul>
<p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-280.png?raw=true" alt="alt text"><br>例1：<br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-279.png?raw=true" alt="alt text"><br>例2：<br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-305.png?raw=true" alt="alt text"><br>典型的非LL(1)文法：</p>
<ul>
<li>if a grammar has <strong>left factor(左因子)</strong> or <strong>left recursion（左递归）</strong>, it is not LL(1).</li>
<li>有左公因⼦或者左递归，⼀定不是LL(1)型grammar</li>
<li><p>没有左公因⼦或者左递归也不⼀定是LL(1)算法</p>
<h5 id="Recursive-descent-parsing-递归下降分析"><a href="#Recursive-descent-parsing-递归下降分析" class="headerlink" title="Recursive-descent parsing 递归下降分析"></a>Recursive-descent parsing 递归下降分析</h5><p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-281.png?raw=true" alt="alt text"></p>
<h6 id="构造递归下降分析器-LL1-parsing"><a href="#构造递归下降分析器-LL1-parsing" class="headerlink" title="构造递归下降分析器+LL1 parsing"></a>构造递归下降分析器+LL1 parsing</h6><p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-282.png?raw=true" alt="alt text"><br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-283.png?raw=true" alt="alt text"></p>
</li>
<li><p>分析表</p>
<ul>
<li>一般的，根据FIRST集，分别填上能够推导出对应符号的式子；</li>
<li>文法中可以推导出空集的非终止符的：就把follow集中的每一个元素和这个非终止符的对应的cell里填上推导出空的式子；</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-295.png?raw=true" alt="alt text"></p>
<ul>
<li><p>分析栈怎么写？：</p>
<ul>
<li>分析栈要基于分析表进行填写。stack和input的最左边符号就定位了分析表中的某个cell，其中的产生式就是Action的内容。<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4>Error Recovery in Top-down Parsers</li>
</ul>
</li>
<li><p>Error Recovery: after an error has occurred, the parser picks a likely place to resume the parsing</p>
</li>
<li><p>Error Repair: the parser attempts to infer a correct program from the incorrect one given</p>
<h4 id="Error-Recovery-in-Recursive-Descent-Parsers：Panic-Mode"><a href="#Error-Recovery-in-Recursive-Descent-Parsers：Panic-Mode" class="headerlink" title="Error Recovery in Recursive-Descent Parsers：Panic Mode"></a>Error Recovery in Recursive-Descent Parsers：Panic Mode</h4><p>这种模式的主要目的是尽可能多地发现和报告源代码中的错误，而不仅仅是停在第一个遇到的错误。</p>
<ul>
<li>Discard input symbols until a synchronizing token is found</li>
<li>Synchronizing tokens are those that can legally follow the error</li>
</ul>
</li>
<li><p>In complex situations, the error handler will consume a possibly large number of tokens in an attempt to find a place to resume parsing</p>
</li>
<li><p>Phrase-level Recovery</p>
<h3 id="Bottom-up-parsing-自底向上"><a href="#Bottom-up-parsing-自底向上" class="headerlink" title="Bottom-up parsing 自底向上"></a>Bottom-up parsing 自底向上</h3><blockquote>
<p>掌握：LR(0)语法分析，SLR(1)语法分析<br>理解：正确的句型，可行的前缀，句柄<br>对于给定的C.F.G和表达式，你一定能很容易地写出正确的句型，并找出可变前缀和句柄。知道LR(0)和SLR(1)的区别。知道什么时候会出现歧义。此外，给定C.F.G，能够写出它的LR(0)项，画出DFA，构造SLR(1)解析表，并知道如何根据它在堆栈表中一步步解析表达式。</p>
</blockquote>
</li>
<li><p>右句型：句型的一种，句型的最右边是一个非终结符号。</p>
</li>
<li>最右推导：从开始符号推导出句型的过程。</li>
<li>handle：在推导过程中，句型的一部分，<strong>跟产生式右部所匹配</strong>的部分。（在右边）</li>
<li>从输入串开始，逐步推导出文法的开始符号。  </li>
<li>归约：推导的逆过程，将handle归约回产生式左侧的非终结符号。（<strong>此时在分析栈中，handle所处位置是顶部</strong>）</li>
<li>将右句型一分为二分为左部/右部，handle在左部的最右边。左部被称为work area，所有的handle都在work area中。</li>
<li>用一个<strong>分析栈</strong>来存储<strong>已经分析过</strong>的部分，栈底是文法的开始符号。<strong>top-down的分析栈中是待分析的内容</strong>。</li>
<li>shift-reduce parsing: 从左到右扫描输入串，shift是将输入串的一个token放入栈中，reduce是将handle归约为产生式左部的非终结符号。</li>
<li>什么时候规约？做预测。这是后续算法解决的问题</li>
<li>可行前缀：找到一个handle之前，在栈里出现过的所有串都可称为可行前缀。如果前缀是可行的，证明分析也是对的，所以也称为“活前缀”<h4 id="LR-parsing"><a href="#LR-parsing" class="headerlink" title="LR parsing"></a>LR parsing</h4>自底向上的分析方法，最需要解决的问题是如何正确识别句柄。句柄是逐步产生的，</li>
<li><p>状态：</p>
<ul>
<li>移进状态：$S \rightarrow \cdot bBB$</li>
<li>待规约状态: $S \rightarrow b\cdot BB$ $S \rightarrow bB\cdot B$</li>
<li>已经规约状态: $S \rightarrow bBB \cdot$</li>
</ul>
</li>
<li><p>LR(0) parsing: 用于解决shift-reduce冲突的问题。<br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-285.png?raw=true" alt="alt text"></p>
</li>
<li><p>Parsing Table: </p>
<ul>
<li>top-down的分析表：选择产生式的规则</li>
<li>bottom-up的分析表：选择规约的产生式</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-284.png?raw=true" alt="alt text"></p>
<ul>
<li><p>增广文法 Augmented Grammar</p>
<ul>
<li>将文法的开始符号G改为新的符号G’，然后添加一个新的产生式 $G’ \rightarrow G$，将新的符号替换为原来的开始符号。</li>
<li>目的是让开始符号只出现在一个产生式的左部，这样可以保证在规约时，栈中只有一个符号，分析器只有一个接收状态。</li>
</ul>
</li>
<li><p>项目</p>
<ul>
<li>项目是对文法的产生式的扩展，包括一个点，表示产生式的位置，描述规约状态。</li>
<li>等价项目应该放在同一个项目集闭包中。</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-286.png?raw=true" alt="alt text"></p>
<h5 id="LR-0-parsing的问题："><a href="#LR-0-parsing的问题：" class="headerlink" title="LR(0) parsing的问题："></a>LR(0) parsing的问题：</h5><ul>
<li>无法处理shift-reduce冲突<br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-287.png?raw=true" alt="alt text"></li>
<li>无法处理reduce-reduce冲突<br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-288.png?raw=true" alt="alt text"></li>
</ul>
<p>LR(0) only accepts languages where the handle can be found with no right context.<br>• Our shift/reduce parser only looks to the left of the handle, not to the right.<br>• How do we exploit the tokens after a possible handle to determine what to do?</p>
<h4 id="SLR-1-parsing"><a href="#SLR-1-parsing" class="headerlink" title="SLR(1) parsing"></a>SLR(1) parsing</h4><p><strong>S(simple)LR(1) parsing</strong>: “ simple “ 在借助 <code>FOLLOW SET</code> 就可以解决冲突。 </p>
<p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-289.png?raw=true" alt="alt text"><br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-290.png?raw=true" alt="alt text"><br>基本思想：看当前的handle对应的非终止符号（产生式的左部）后面允许出现哪些终止符号</p>
<h5 id="判断是否为SLR-1-文法"><a href="#判断是否为SLR-1-文法" class="headerlink" title="判断是否为SLR(1)文法"></a>判断是否为SLR(1)文法</h5><p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-306.png?raw=true" alt="alt text"><br>满足以下条件的文法是SLR(1)文法：</p>
<ol>
<li>存在shift-reduce冲突</li>
<li>冲突能够通过FOLLOW集解决<h5 id="SLR分析存在的问题"><a href="#SLR分析存在的问题" class="headerlink" title="SLR分析存在的问题"></a>SLR分析存在的问题</h5>SLR只是简单地考察下一个输入符号是否属于规约项目 $A \rightarrow \alpha$ 相关的FOLLOW(A)，但是 $b \in FIRST(\alpha)$，只是规约的一个必要条件，而非充分条件。</li>
</ol>
<p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-294.png?raw=true" alt="alt text"><br>也就是集合${a_1,a_2,…,a_m}$和$FOLLOW{B_n}$的交集不为空，下一个输入的字符在此之中，那么就会出现冲突。</p>
<h5 id="SLR分析表"><a href="#SLR分析表" class="headerlink" title="SLR分析表"></a>SLR分析表</h5><p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-302.png?raw=true" alt="alt text"><br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-303.png?raw=true" alt="alt text"></p>
<h5 id="SLR分析栈"><a href="#SLR分析栈" class="headerlink" title="SLR分析栈"></a>SLR分析栈</h5><p>(正确：only state symbols at the top of the stack)<br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-304.png?raw=true" alt="alt text"></p>
<h4 id="LR-1-parsing"><a href="#LR-1-parsing" class="headerlink" title="LR(1) parsing"></a>LR(1) parsing</h4><p>SLR能帮我们排除一些不可能的规约，但是不能保证所有的规约都是正确的。</p>
<p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-291.png?raw=true" alt="alt text"><br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-292.png?raw=true" alt="alt text"><br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-293.png?raw=true" alt="alt text"></p>
<h4 id="LALR-parsing"><a href="#LALR-parsing" class="headerlink" title="LALR parsing"></a>LALR parsing</h4><p>LR1的项目集太多，LALR1是对LR1的优化，将LR1的项目集合并，减少项目集的数量。</p>
<h1 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h1><blockquote>
<p>掌握：依赖图，属性计算算法<br>理解：属性语法，合成和继承属性。S-属性，L-属性。了解语义分析的任务及其实现方法。知道如何通过给定的方程式计算属性值。知道如何绘制依赖图，以及如何将属性或值标注到解析图中。</p>
</blockquote>
<h2 id="AST-vs-Parse-Tree"><a href="#AST-vs-Parse-Tree" class="headerlink" title="AST vs. Parse Tree"></a>AST vs. Parse Tree</h2><p>AST 是解析树的压缩形式</p>
<ul>
<li>运算符出现在内部节点，而不是叶子节点。</li>
<li>列表是“扁平化的”。</li>
<li><p>省略了语法细节</p>
<ul>
<li>例如括号、逗号、分号</li>
</ul>
</li>
<li><p>AST 是编译器后期阶段的更好结构</p>
<ul>
<li>抽象语法树表示实际源代码标记序列的抽象</li>
<li>尽管如此，它们包含转换所需的所有信息。比解析树更有效</li>
<li>解析器将执行解析树所表示的所有步骤，但通常只会构建抽象语法树</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-309.png?raw=true" alt="alt text"></p>
<h2 id="SDD-Syntax-Directed-Definition-语法制导定义"><a href="#SDD-Syntax-Directed-Definition-语法制导定义" class="headerlink" title="SDD (Syntax-Directed Definition) 语法制导定义"></a>SDD (Syntax-Directed Definition) 语法制导定义</h2><ul>
<li>语法制导定义是一种用于描述语法制导翻译的形式化方法。</li>
<li>语法制导定义是对CFG的推广，<ul>
<li>每个文法符号都和一个语义属性集合相关联</li>
<li>每个产生式都与一组语义规则相关联，这些规则用于计算产生式各个文法符号的属性值。</li>
</ul>
</li>
<li>语法制导定义的属性可以是综合属性或继承属性。<ul>
<li>综合属性是由产生式的右侧的属性计算得到的属性，分析树中N节点上的非终结符A的综合属性只能通过N的子节点的属性或者N节点本身的属性值来定义。<ul>
<li>终结符可以有综合属性，是由词法器提供的词法值。</li>
</ul>
</li>
<li>继承属性是由产生式的左侧的属性计算得到的属性，分析树中N节点上的非终结符A的由N的父节点或者N的兄弟节点的属性或者N本身的属性值计算得到的属性。<ul>
<li>终结符没有继承属性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="属性文法"><a href="#属性文法" class="headerlink" title="属性文法"></a>属性文法</h3><h3 id="SDD的求值顺序"><a href="#SDD的求值顺序" class="headerlink" title="SDD的求值顺序"></a>SDD的求值顺序</h3><h4 id="S-SDD"><a href="#S-SDD" class="headerlink" title="S-SDD"></a>S-SDD</h4><ol>
<li>S-attribute grammar is the attributed grammar, of which.<br>A. <strong>each attribute must be synthesized.</strong><br>仅仅使用综合属性的SSD称为S-SDD。</li>
</ol>
<p>如果一个SDD是S-SDD，那么它的属性计算顺序是自底向上的。</p>
<h4 id="L-SDD"><a href="#L-SDD" class="headerlink" title="L-SDD"></a>L-SDD</h4><p>L-SDD当且仅当它的每个属性要么是综合属性，要么是满足以下条件的继承属性：</p>
<ul>
<li>假设存在一个产生式$A \rightarrow X_1X_2…X_n$， 右边的符号$X_1X_2…X_n$的继承属性仅依赖于<ul>
<li>A的继承属性</li>
<li>$X<em>i$左边的符号$X_1X_2…X</em>{i-1}$的属性</li>
<li>$X_i$的本身的属性，但是$X_i$的属性不能在依赖图中形成环路。</li>
</ul>
</li>
</ul>
<h2 id="SDT-Syntax-Directed-Translation-语法制导翻译"><a href="#SDT-Syntax-Directed-Translation-语法制导翻译" class="headerlink" title="SDT (Syntax-Directed Translation) 语法制导翻译"></a>SDT (Syntax-Directed Translation) 语法制导翻译</h2><ul>
<li>可以看作是对语法制导定义的实现。</li>
<li>显式地指明了语义规则的计算顺序。<h3 id="parse-tree"><a href="#parse-tree" class="headerlink" title="parse tree"></a>parse tree</h3><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-307.png?raw=true" alt="alt text"><h3 id="Dependency-Graph"><a href="#Dependency-Graph" class="headerlink" title="Dependency Graph"></a>Dependency Graph</h3><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-308.png?raw=true" alt="alt text"><h3 id="控制流SDT"><a href="#控制流SDT" class="headerlink" title="控制流SDT"></a>控制流SDT</h3></li>
</ul>
<h1 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h1><blockquote>
<p>掌握：基本结构的中级代码生成：三地址代码；控制结构的TAC，表达式的TAC<br>给定上下文无关语法和属性语法，能够通过SDT将源代码翻译成TAC</p>
</blockquote>
<h2 id="什么是-IR-生成？"><a href="#什么是-IR-生成？" class="headerlink" title="什么是 IR 生成？"></a>什么是 IR 生成？</h2><p>• Intermediate Representation (IR) Generation<br>• 编译器前端的最后阶段。<br>• 目标：将程序转换为编译器后端所需的格式。<br>• 生成的代码无需优化；这由后续过程处理。<br>• 生成的代码不需要汇编；这也可以由后续过程处理。</p>
<ul>
<li>中间代码的必要性<br>抽象语法树与目标代码不同，特别是在控制流结构的表示上<br>中间代码以顺序形式表示语法树，更接近目标代码</li>
<li>中间代码的流行形式：<ul>
<li>三地址代码<h2 id="三地址代码"><a href="#三地址代码" class="headerlink" title="三地址代码"></a>三地址代码</h2>The most basic instruction of three address code has the    general form $x=y op z$<br>Which represents the evaluation of expressions</li>
</ul>
</li>
<li>x,y,z are names, constants or compiler-generated temporary names</li>
<li>op stands for any arithmetic or logical operator, such as + ,’and’</li>
<li>“Three-address code” comes from this form of instruction,  in general each of x,y and z represents an address in memory<h3 id="logical-expression"><a href="#logical-expression" class="headerlink" title="logical expression"></a>logical expression</h3><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-311.png?raw=true" alt="alt text"><h3 id="Control-Flow-Statements"><a href="#Control-Flow-Statements" class="headerlink" title="Control Flow Statements"></a>Control Flow Statements</h3></li>
<li>三地址代码的基本结构是三地址指令，控制结构的三地址代码是基于基本结构的。</li>
</ul>
<p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-310.png?raw=true" alt="alt text"></p>
<h4 id="Translation-of-Boolean-expressions-in-the-context-of-control-statements"><a href="#Translation-of-Boolean-expressions-in-the-context-of-control-statements" class="headerlink" title="Translation of Boolean expressions in the context of control statements"></a>Translation of Boolean expressions in the context of control statements</h4><ul>
<li>Translation Method<ul>
<li>The value of Boolean expression is not saved in a temporary but represented by a position reached in a program</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-296.png?raw=true" alt="alt text"></p>
<ul>
<li>代码生成中使用的函数<ul>
<li>newlabel() 每次调用时都会返回一个新标签、</li>
</ul>
</li>
<li>Attributes<ul>
<li>E true (E false) 是当 E 为 true(false)时 控制流向的标签</li>
<li>S.next 是附在S的代码后执行的第一个三地址指令上的标签</li>
<li>S.begin 是附在S的代码生成的第一个指令上的标签</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-301.png?raw=true" alt="alt text"></p>
<p><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-298.png?raw=true" alt="alt text"><br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-297.png?raw=true" alt="alt text"><br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-299.png?raw=true" alt="alt text"><br><img src="https://github.com/val213/val213.github.io/blob/hexo_source/source/_posts/../image/image-300.png?raw=true" alt="alt text"></p>
<h3 id="triple-implementation"><a href="#triple-implementation" class="headerlink" title="triple implementation"></a>triple implementation</h3><h3 id="quadruple-implementation"><a href="#quadruple-implementation" class="headerlink" title="quadruple implementation"></a>quadruple implementation</h3><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://val213.github.io">Val</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://val213.github.io/2024/04/23/%E5%A4%A7%E4%BA%8C%E8%AF%BE%E7%A8%8B/%E3%80%90%E5%A4%A7%E4%BA%8C%E4%B8%8B%E3%80%91%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">https://val213.github.io/2024/04/23/%E5%A4%A7%E4%BA%8C%E8%AF%BE%E7%A8%8B/%E3%80%90%E5%A4%A7%E4%BA%8C%E4%B8%8B%E3%80%91%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/23/%E5%A4%A7%E4%BA%8C%E8%AF%BE%E7%A8%8B/%E3%80%90%E5%A4%A7%E4%BA%8C%E4%B8%8B%E3%80%91%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/" title="编译原理实验"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">编译原理实验</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/23/%E5%A4%A7%E4%BA%8C%E8%AF%BE%E7%A8%8B/%E3%80%90%E5%A4%A7%E4%BA%8C%E4%B8%8B%E3%80%91%E5%8D%97%E5%A4%A7jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="【大二下】南大jyy操作系统"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">【大二下】南大jyy操作系统</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://github.com/val213/image/blob/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230630230143.jpg?raw=true" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Val</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">128</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">104</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/val213"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/val213" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:val213666@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">记录跬步 e/acc</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2024%E8%80%83%E7%BA%B2"><span class="toc-number">1.</span> <span class="toc-text">2024考纲</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lexical"><span class="toc-number">1.2.</span> <span class="toc-text">Lexical</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-F-G"><span class="toc-number">1.3.</span> <span class="toc-text">C.F.G.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Top-Down-Parsing"><span class="toc-number">1.4.</span> <span class="toc-text">Top-Down Parsing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bottom-Up-Paring"><span class="toc-number">1.5.</span> <span class="toc-text">Bottom-Up Paring:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semantic"><span class="toc-number">1.6.</span> <span class="toc-text">Semantic:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Intermediate-Code-Generation"><span class="toc-number">1.7.</span> <span class="toc-text">Intermediate Code Generation:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E7%BB%84%E6%88%90"><span class="toc-number">2.</span> <span class="toc-text">编译器组成</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lexical-analysis-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-scanner"><span class="toc-number">3.</span> <span class="toc-text">lexical analysis 词法分析 (scanner)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RE"><span class="toc-number">3.1.</span> <span class="toc-text">RE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Compound-Regular-Expressions"><span class="toc-number">3.1.1.</span> <span class="toc-text">Compound Regular Expressions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Identifier"><span class="toc-number">3.1.2.</span> <span class="toc-text">Identifier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nondeterministic-Finite-Automata-NFA"><span class="toc-number">3.1.3.</span> <span class="toc-text">Nondeterministic Finite Automata(NFA)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#conflict-resolve"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">conflict resolve</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#error-report"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">error report</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deterministic-Finite-Automata-DFA"><span class="toc-number">3.1.4.</span> <span class="toc-text">Deterministic Finite Automata(DFA)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Subset-Construction-%E5%AD%90%E9%9B%86%E6%9E%84%E9%80%A0%E6%B3%95"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">Subset Construction 子集构造法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Minimizing-Algorithm"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">Minimizing Algorithm</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Syntax-Analysis-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-parsing"><span class="toc-number">4.</span> <span class="toc-text">Syntax Analysis 语法分析 (parsing)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Formalisms-fot-syntax-analysis"><span class="toc-number">4.1.</span> <span class="toc-text">Formalisms fot syntax analysis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Language-of-CFG"><span class="toc-number">4.2.</span> <span class="toc-text">Language of CFG</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RE-vs-CFG"><span class="toc-number">4.2.1.</span> <span class="toc-text">RE vs CFG</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Derivation-%E6%8E%A8%E5%AF%BC"><span class="toc-number">4.2.2.</span> <span class="toc-text">Derivation 推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sentence-and-Sentential-Form-%E5%8F%A5%E5%AD%90%E5%92%8C%E5%8F%A5%E5%9E%8B"><span class="toc-number">4.2.3.</span> <span class="toc-text">Sentence and Sentential Form 句子和句型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parse-tree-and-abstract-syntax-tree"><span class="toc-number">4.3.</span> <span class="toc-text">parse tree and abstract syntax tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Derivations-and-Parse-Trees"><span class="toc-number">4.4.</span> <span class="toc-text">Derivations and Parse Trees</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Leftmost-Derivation"><span class="toc-number">4.4.1.</span> <span class="toc-text">Leftmost Derivation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rightmost-derivation"><span class="toc-number">4.4.2.</span> <span class="toc-text">Rightmost derivation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Abstract-Syntax-Tree"><span class="toc-number">4.4.3.</span> <span class="toc-text">Abstract Syntax Tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ambiguity-%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-number">4.5.</span> <span class="toc-text">ambiguity 二义性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-number">4.5.1.</span> <span class="toc-text">如何处理二义性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Left-Recursion"><span class="toc-number">4.5.2.</span> <span class="toc-text">Left Recursion</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Elimination-of-Left-Recursion"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">Elimination of Left Recursion</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Left-Factoring"><span class="toc-number">4.5.3.</span> <span class="toc-text">Left Factoring</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parsing-algorithm"><span class="toc-number">4.6.</span> <span class="toc-text">parsing algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Top-down-parsing-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B"><span class="toc-number">4.6.1.</span> <span class="toc-text">Top-down parsing 自顶向下</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BFS"><span class="toc-number">4.6.1.1.</span> <span class="toc-text">BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BFS%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.6.1.1.1.</span> <span class="toc-text">BFS的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Leftmost-BFS"><span class="toc-number">4.6.1.2.</span> <span class="toc-text">Leftmost BFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Leftmost-DFS"><span class="toc-number">4.6.1.3.</span> <span class="toc-text">Leftmost DFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#summary-of-Leftmost-BFS-DFS"><span class="toc-number">4.6.1.4.</span> <span class="toc-text">summary of Leftmost BFS&#x2F;DFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#backtracking-%E5%9B%9E%E6%BA%AF"><span class="toc-number">4.6.1.5.</span> <span class="toc-text">backtracking 回溯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#predictive-parsing-%E9%A2%84%E6%B5%8B%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">4.6.1.6.</span> <span class="toc-text">predictive parsing 预测性分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LL-1"><span class="toc-number">4.6.1.6.1.</span> <span class="toc-text">LL(1)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#first-%E5%92%8C-follow"><span class="toc-number">4.6.1.6.1.1.</span> <span class="toc-text">first 和 follow</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%96%87%E6%B3%95%E6%98%AF%E5%90%A6%E6%98%AFLL-1-%E6%96%87%E6%B3%95%EF%BC%9A"><span class="toc-number">4.6.1.6.1.2.</span> <span class="toc-text">判断一个文法是否是LL(1)文法：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Recursive-descent-parsing-%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E5%88%86%E6%9E%90"><span class="toc-number">4.6.1.6.2.</span> <span class="toc-text">Recursive-descent parsing 递归下降分析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E5%88%86%E6%9E%90%E5%99%A8-LL1-parsing"><span class="toc-number">4.6.1.6.2.1.</span> <span class="toc-text">构造递归下降分析器+LL1 parsing</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">4.6.1.7.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Error-Recovery-in-Recursive-Descent-Parsers%EF%BC%9APanic-Mode"><span class="toc-number">4.6.1.8.</span> <span class="toc-text">Error Recovery in Recursive-Descent Parsers：Panic Mode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bottom-up-parsing-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A"><span class="toc-number">4.6.2.</span> <span class="toc-text">Bottom-up parsing 自底向上</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-parsing"><span class="toc-number">4.6.2.1.</span> <span class="toc-text">LR parsing</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LR-0-parsing%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">4.6.2.1.1.</span> <span class="toc-text">LR(0) parsing的问题：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SLR-1-parsing"><span class="toc-number">4.6.2.2.</span> <span class="toc-text">SLR(1) parsing</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BASLR-1-%E6%96%87%E6%B3%95"><span class="toc-number">4.6.2.2.1.</span> <span class="toc-text">判断是否为SLR(1)文法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SLR%E5%88%86%E6%9E%90%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.6.2.2.2.</span> <span class="toc-text">SLR分析存在的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SLR%E5%88%86%E6%9E%90%E8%A1%A8"><span class="toc-number">4.6.2.2.3.</span> <span class="toc-text">SLR分析表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SLR%E5%88%86%E6%9E%90%E6%A0%88"><span class="toc-number">4.6.2.2.4.</span> <span class="toc-text">SLR分析栈</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-1-parsing"><span class="toc-number">4.6.2.3.</span> <span class="toc-text">LR(1) parsing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LALR-parsing"><span class="toc-number">4.6.2.4.</span> <span class="toc-text">LALR parsing</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">语义分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AST-vs-Parse-Tree"><span class="toc-number">5.1.</span> <span class="toc-text">AST vs. Parse Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SDD-Syntax-Directed-Definition-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E5%AE%9A%E4%B9%89"><span class="toc-number">5.2.</span> <span class="toc-text">SDD (Syntax-Directed Definition) 语法制导定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95"><span class="toc-number">5.2.1.</span> <span class="toc-text">属性文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDD%E7%9A%84%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.2.2.</span> <span class="toc-text">SDD的求值顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#S-SDD"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">S-SDD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#L-SDD"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">L-SDD</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SDT-Syntax-Directed-Translation-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91"><span class="toc-number">5.3.</span> <span class="toc-text">SDT (Syntax-Directed Translation) 语法制导翻译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#parse-tree"><span class="toc-number">5.3.1.</span> <span class="toc-text">parse tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dependency-Graph"><span class="toc-number">5.3.2.</span> <span class="toc-text">Dependency Graph</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81SDT"><span class="toc-number">5.3.3.</span> <span class="toc-text">控制流SDT</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">6.</span> <span class="toc-text">中间代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-IR-%E7%94%9F%E6%88%90%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">什么是 IR 生成？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%9C%B0%E5%9D%80%E4%BB%A3%E7%A0%81"><span class="toc-number">6.2.</span> <span class="toc-text">三地址代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#logical-expression"><span class="toc-number">6.2.1.</span> <span class="toc-text">logical expression</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Control-Flow-Statements"><span class="toc-number">6.2.2.</span> <span class="toc-text">Control Flow Statements</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Translation-of-Boolean-expressions-in-the-context-of-control-statements"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">Translation of Boolean expressions in the context of control statements</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#triple-implementation"><span class="toc-number">6.2.3.</span> <span class="toc-text">triple implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#quadruple-implementation"><span class="toc-number">6.2.4.</span> <span class="toc-text">quadruple implementation</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A"><span class="toc-number">7.</span> <span class="toc-text">作业</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/16/%E5%BC%80%E5%8F%91/%E3%80%90C++%E3%80%91%E9%AB%98%E9%80%9F%E4%B8%8A%E6%89%8B/" title="No title"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2024/11/16/%E5%BC%80%E5%8F%91/%E3%80%90C++%E3%80%91%E9%AB%98%E9%80%9F%E4%B8%8A%E6%89%8B/" title="No title">No title</a><time datetime="2024-11-16T09:17:46.635Z" title="Created 2024-11-16 17:17:46">2024-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/14/DragonOS/%E3%80%90DragonOS%E3%80%91ebpf/" title="eBPF"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="eBPF"/></a><div class="content"><a class="title" href="/2024/11/14/DragonOS/%E3%80%90DragonOS%E3%80%91ebpf/" title="eBPF">eBPF</a><time datetime="2024-11-14T07:03:54.243Z" title="Created 2024-11-14 15:03:54">2024-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/06/DragonOS/%E3%80%90DragonOS%E3%80%91%E5%A4%9A%E6%A0%B8%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" title="多核调度算法"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多核调度算法"/></a><div class="content"><a class="title" href="/2024/11/06/DragonOS/%E3%80%90DragonOS%E3%80%91%E5%A4%9A%E6%A0%B8%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" title="多核调度算法">多核调度算法</a><time datetime="2024-11-06T08:40:33.032Z" title="Created 2024-11-06 16:40:33">2024-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/01/DragonOS/%E3%80%90DragonOS%E3%80%91qemu%E7%9A%84%E7%A7%98%E5%AF%86/" title="【DragonOS】qemu的秘密"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【DragonOS】qemu的秘密"/></a><div class="content"><a class="title" href="/2024/11/01/DragonOS/%E3%80%90DragonOS%E3%80%91qemu%E7%9A%84%E7%A7%98%E5%AF%86/" title="【DragonOS】qemu的秘密">【DragonOS】qemu的秘密</a><time datetime="2024-11-01T15:18:46.089Z" title="Created 2024-11-01 23:18:46">2024-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/28/%E5%BC%80%E5%8F%91/%E3%80%90Rust%E3%80%91tokio/" title="【Rust】tokio"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Rust】tokio"/></a><div class="content"><a class="title" href="/2024/10/28/%E5%BC%80%E5%8F%91/%E3%80%90Rust%E3%80%91tokio/" title="【Rust】tokio">【Rust】tokio</a><time datetime="2024-10-28T11:29:42.554Z" title="Created 2024-10-28 19:29:42">2024-10-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Val</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">纯粹的心，感受意义不明</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>