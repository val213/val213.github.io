<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【大二下】南大jyy操作系统 | Val-Blog</title><meta name="author" content="Val,10425999@qq.com, val213666@gmail.com"><meta name="copyright" content="Val"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="课程地址：  2023：https:&#x2F;&#x2F;jyywiki.cn&#x2F;OS&#x2F;2023&#x2F;index.html 2022：https:&#x2F;&#x2F;jyywiki.cn&#x2F;OS&#x2F;2022&#x2F;index.html概述课STFW&#x2F;RTFM: search the fucking web&#x2F;read the fucking mannul命令行工具tmux终端复用工具，可以在一个终端窗口中打开多个终端，可以在后台运行，可以在不同终端">
<meta property="og:type" content="article">
<meta property="og:title" content="【大二下】南大jyy操作系统">
<meta property="og:url" content="https://val213.github.io/2024/04/23/%E3%80%90%E5%A4%A7%E4%BA%8C%E4%B8%8B%E3%80%91%E5%8D%97%E5%A4%A7jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Val-Blog">
<meta property="og:description" content="课程地址：  2023：https:&#x2F;&#x2F;jyywiki.cn&#x2F;OS&#x2F;2023&#x2F;index.html 2022：https:&#x2F;&#x2F;jyywiki.cn&#x2F;OS&#x2F;2022&#x2F;index.html概述课STFW&#x2F;RTFM: search the fucking web&#x2F;read the fucking mannul命令行工具tmux终端复用工具，可以在一个终端窗口中打开多个终端，可以在后台运行，可以在不同终端">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2024-04-23T10:57:36.554Z">
<meta property="article:modified_time" content="2024-09-17T06:46:22.985Z">
<meta property="article:author" content="Val">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://val213.github.io/2024/04/23/%E3%80%90%E5%A4%A7%E4%BA%8C%E4%B8%8B%E3%80%91%E5%8D%97%E5%A4%A7jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: Val","link":"Link: ","source":"Source: Val-Blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【大二下】南大jyy操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-17 14:46:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://github.com/val213/image/blob/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230630230143.jpg?raw=true" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">130</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">106</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">18</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Val-Blog"><span class="site-name">Val-Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【大二下】南大jyy操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-04-23T10:57:36.554Z" title="Created 2024-04-23 18:57:36">2024-04-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-09-17T06:46:22.985Z" title="Updated 2024-09-17 14:46:22">2024-09-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/">知识分享</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【大二下】南大jyy操作系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>课程地址：</p>
<ul>
<li>2023：<a target="_blank" rel="noopener" href="https://jyywiki.cn/OS/2023/index.html">https://jyywiki.cn/OS/2023/index.html</a></li>
<li>2022：<a target="_blank" rel="noopener" href="https://jyywiki.cn/OS/2022/index.html">https://jyywiki.cn/OS/2022/index.html</a><h1 id="概述课"><a href="#概述课" class="headerlink" title="概述课"></a>概述课</h1><code>STFW/RTFM</code>: search the fucking web/read the fucking mannul<h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a><code>tmux</code></h3>终端复用工具，可以在一个终端窗口中打开多个终端，可以在后台运行，可以在不同终端窗口之间切换，可以在不同终端窗口之间复制粘贴。</li>
</ul>
<p>主要区分session、Windows和pane的概念。<br>常用指令：</p>
<ul>
<li><code>tmux new -s [sessionname]</code></li>
<li><code>tmux attach -t [sessionname]</code></li>
<li><code>ctrl+b</code>+其他指令（注意ctrl+b要先放开再按其他键）<ul>
<li><code>?</code>：列出所有的快捷键，按q返回 </li>
<li><code>d</code>：detached当前的session，后台运行。 </li>
<li><code>c</code>: 新增windows</li>
<li><code>x</code>: 删除当前pane，关掉所有pane和windows后exit了整个session</li>
<li><code>%</code>：垂直划分pane</li>
<li><code>&quot;</code>：水平划分pane</li>
<li><code>Space (空格键)</code> ：对当前窗口下的所有窗格重新排列布局，每按一次，换一种样式。</li>
<li><code>q</code>：显示pane的index</li>
<li><code>s</code>：等价于<code>tmux ls</code>，显示所有的seesion</li>
<li><code>z</code>：放大当前的pane，再用一次还原</li>
<li><code>!</code>：单独拆分当前的pane</li>
<li><code>数字</code>: 跳转对应index的windows</li>
<li><code>o</code>： 依次切换当前窗口下的各个窗格。</li>
<li><code>↑/↓/←/→</code>：移动光标到对应的pane<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3></li>
</ul>
</li>
<li><code>fish</code>(我没用)：fish is a smart and user-friendly command line shell for Linux, macOS, and the rest of the family.</li>
<li><code>tldr</code>：too long, dont read.命令行工具的帮助文档，比<code>man</code>更简洁，更易读，更实用</li>
<li><code>strace</code>: 用于trace的工具</li>
<li><code>binutils</code>： </li>
<li><code>qemu</code>:<code>sudo yum install qemu-kvm qemu-img -y</code></li>
<li>Python37：<code>centOS</code>下安装<h3 id="gdb（GNU-Debugger），调试工具"><a href="#gdb（GNU-Debugger），调试工具" class="headerlink" title="gdb（GNU Debugger），调试工具"></a><code>gdb</code>（GNU Debugger），调试工具</h3></li>
</ul>
<h2 id="作业和lab代码框架"><a href="#作业和lab代码框架" class="headerlink" title="作业和lab代码框架"></a>作业和lab代码框架</h2><p>仓库地址：<code>git clone https://github.com/NJU-ProjectN/os-workbench-2022</code></p>
<blockquote>
<p>解决虚拟机无法克隆仓库（443：connected refused）</p>
<ol>
<li>进入终端命令行模式，输入sudo vi /etc/hosts</li>
<li>英文输入法输入GG，vim编辑器跳到hosts文件的最后一行</li>
<li>用浏览器访问 IPAddress.com 使用 IP Lookup 工具获得github.com和github.global.ssl.fastly.net域名的ip地址</li>
<li>在vi打开的hosts文件中添加如下格式：</li>
</ol>
</blockquote>
<pre><code>   192.30.253.112 github.com

   151.101.185.194 github.global.ssl.fastly.net
</code></pre><blockquote>
<ol>
<li>esc退出编辑模式，输入：wq，保存hosts文件，修改hosts结束</li>
<li>更新DNS缓存，输入sudo /etc/init.d/networking restart</li>
<li>然后再用git clone， 亲测有效。</li>
</ol>
</blockquote>
<h3 id="M1：打印进程树"><a href="#M1：打印进程树" class="headerlink" title="M1：打印进程树"></a>M1：打印进程树</h3><p>在<code>os-workbench-2022</code>目录下，运行<code>git pull origin M1</code>，获取M1的框架代码。</p>
<h4 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h4><p>这个实验我们自己实现pstree的简单功能：进程树会以非常漂亮的格式排版 (每个进程的第一个孩子都与它处在同一行，之后的孩子保持相同的缩进)。可以先把玩一下这个命令。</p>
<p>先下载psmisc:<code>yum -y install psmisc</code>，psmisc是一个开源的Linux系统的进程管理软件包，它包含了一些用于显示和控制进程的工具，例如<code>fuser</code>, <code>killall</code>, <code>pstree</code>等。<code>psmisc</code>的全称是<code>Process Status Miscellaneous</code>，意思是杂项进程状态。psmisc可以帮助你查看进程树，杀死指定名称或端口的进程，显示进程的用户和信号等信息。</p>
<p><code>everything is file.</code>Linux系统里也有专门存放系统进程文件的目录，就是<code>/proc</code>目录。<code>/proc</code>目录下的文件和目录都是虚拟的，它们的内容都是内核在运行时动态生成的。</p>
<blockquote>
<p>一个有趣的事情是，我在把玩的时候无意中执行了<code>cat proc/1/exe</code>，然后弹出了一屏幕的乱码，终端提示符也变成了乱码。</p>
<p>这个命令的作用是打印出进程1（即init进程）的可执行文件的内容。但是，这个文件是一个二进制文件，它不是用人类可读的文本编码的，而是用机器指令编码的。因此，当你用cat命令打印它的时候，终端会尝试用文本编码来解释它，导致出现乱码。<br>要解决这个问题，你可以用以下的方法：</p>
<ul>
<li>按下Ctrl+C或Ctrl+Z，中断cat命令的执行，恢复终端的正常状态。</li>
<li>使用reset命令，重置终端的设置，清除乱码。</li>
<li>使用hexdump或xxd等命令，以十六进制的格式打印二进制文件的内容，避免乱码。<br>输入<code>reset</code>后终端清空并恢复正常了。</li>
</ul>
</blockquote>
<h4 id="问题分解："><a href="#问题分解：" class="headerlink" title="问题分解："></a>问题分解：</h4><ul>
<li>解析命令行命令以及不同的选项</li>
<li>获取进程信息</li>
<li>构建树形结构</li>
<li>打印进程树</li>
<li>可移植性<h5 id="解析命令行命令以及不同的选项"><a href="#解析命令行命令以及不同的选项" class="headerlink" title="解析命令行命令以及不同的选项"></a>解析命令行命令以及不同的选项</h5></li>
<li><code>getopt</code>函数，只能解析短选项，不能解析长选项</li>
<li><code>getopt_long</code>函数，可以解析短选项和长选项</li>
<li><code>getopt_long_only</code>函数，可以解析短选项和长选项，但是短选项必须是一个字符，长选项必须是多个字符<br>按照要求可以选用  <code>getopt_long（）</code>。<h5 id="获取进程信息"><a href="#获取进程信息" class="headerlink" title="获取进程信息"></a>获取进程信息</h5></li>
<li><code>\proc\id\stat</code>此路径包含了我们需要的进程信息，包括进程名称、进程号pid和父进程号ppid</li>
</ul>
<h5 id="构建树形结构"><a href="#构建树形结构" class="headerlink" title="构建树形结构"></a>构建树形结构</h5><ul>
<li><code>struct process</code>结构体</li>
<li>哈希表</li>
<li>栈实现深度优先搜索</li>
</ul>
<h5 id="按照要求打印"><a href="#按照要求打印" class="headerlink" title="按照要求打印"></a>按照要求打印</h5><ul>
<li>版本信息<code>-v --version</code></li>
<li>带进程号<code>-p --show-pids</code></li>
<li>进程排序<code>-n --numeric-sort</code></li>
</ul>
<h5 id="可移植性——使用makefile编译32位和64位的可执行文件"><a href="#可移植性——使用makefile编译32位和64位的可执行文件" class="headerlink" title="可移植性——使用makefile编译32位和64位的可执行文件"></a>可移植性——使用makefile编译32位和64位的可执行文件</h5><ul>
<li>如果项目目录结构没错的话，执行<code>make</code>会自动运行<code>Makefile</code>脚本编译32位和64位的可执行文件，最终终端执行的命令是：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -m64 -O1 -std=gnu11 -ggdb -Wall -Werror -Wno-unused-result -Wno-unused-value -Wno-unused-variable ./pstree.c -o M1-64 </span><br><span class="line">gcc -m32 -O1 -std=gnu11 -ggdb -Wall -Werror -Wno-unused-result -Wno-unused-value -Wno-unused-variable ./pstree.c -o M1-32 </span><br></pre></td></tr></table></figure>
得到<code>M1-32</code>和<code>M1-64</code>两个可执行文件<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><blockquote>
<p>和系统打交道的编程可有更多的麻烦之处：</p>
<ol>
<li>你的程序遵守 POSIX 的返回值规定吗？如果你的 main 函数返回了非 0 的数值，我们将认为程序报告了错误——在非法的输入上返回 0，以及在合法的输入上返回非 0 都将导致 Wrong Answer。</li>
<li>程序够 roubust 吗？它会不会在一些非法的输入上 crash？如果系统里的进程很多呢？如果内存不够了呢？如果 open 或者 malloc 失败了呢？要知道，crash 一般是因为 undefined behavior (UB) 导致的——UB 没把所有的文件都删掉真是谢天谢地了。</li>
<li>万一我得到进程号以后，进去发现文件没了 (进程终止了)，怎么办？会不会有这种情况？万一有我的程序会不会 crash……？</li>
<li>进程的信息一直在变，文件的内容也一直在变 (两次 cat 的结果不同)。那我会不会读到不一致的信息(前一半是旧信息、新一半是新信息)？这两个问题都是 race condition 导致的；我们将会在并发部分回到这个话题。<br>如果我不确信这些事会不会发生，我有没有写一个程序，至少在压力环境下测试一下它们有没有可能发生？嗯，如果我同时运行很多程序，每个程序都不断扫描目录、读取文件，也观察不到这个问题，至少应该可以放点心。<h2 id="L0：直接运行在硬件上的小游戏-amgame"><a href="#L0：直接运行在硬件上的小游戏-amgame" class="headerlink" title="L0：直接运行在硬件上的小游戏 (amgame)"></a>L0：直接运行在硬件上的小游戏 (amgame)</h2>在<code>os-workbench-2022</code>目录下，运行<code>git pull origin L0</code>，获取L0的框架代码。</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="AbstractMachine-抽象计算机"><a href="#AbstractMachine-抽象计算机" class="headerlink" title="AbstractMachine: 抽象计算机"></a>AbstractMachine: 抽象计算机</h3><p>AbstractMachine 是裸机上的 C 语言运行环境，提供 5 组 (15 个) 主要 API，可以实现各类系统软件 (如操作系统)：</p>
<ul>
<li>(TRM) putch/halt - 最基础的计算、显示和停机</li>
<li>(IOE) ioe_read/ioe_write - I/O 设备管理</li>
<li>(CTE) ienabled/iset/yield/kcontext - 中断和异常</li>
<li>(VME) protect/unprotect/map/ucontext - 虚存管理</li>
<li>(MPE) cpu_count/cpu_current/atomic_xchg - 多处理器</li>
</ul>
<h4 id="为-Bare-Metal-编程：编译、链接与加载"><a href="#为-Bare-Metal-编程：编译、链接与加载" class="headerlink" title="为 Bare-Metal 编程：编译、链接与加载"></a>为 Bare-Metal 编程：编译、链接与加载</h4><h4 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h4><ul>
<li>有肉眼可辨认的图形输出；</li>
<li>能使用键盘与游戏交互；</li>
<li>游戏使用的内存 (代码、静态数据总和不超过 1 MiB、堆区 heap 使用不超过 1 MiB)，因此你不必考虑复杂的图形；</li>
<li>按 ESC 键后调用 halt() 退出；除此之外游戏程序永不调用 halt() 结束，Game Over 后按键重新开始。</li>
<li>在可移植性/通用性上对你的代码做出一定的保证：<ul>
<li>兼容很简单的处理器：即小游戏运行中只调用 TRM 和 IOE API，而不使用其他 API，且——这样大家的游戏就可以在各个 CPU 上广为流传下去啦！</li>
<li>你的游戏应当是可以在多个硬件体系结构之间移植的，考虑兼容以下情况：<ul>
<li>适配不同的屏幕大小。不同的体系结构中，屏幕大小可能是 $320\times 200$、$640 \times 480$、$800 \times 600$ 等，你的游戏最好能在所有分辨率下都获得不错的体验；</li>
<li>同 minilabs 一样，你的程序可能运行在 32/64-bit 平台，因此你应当使用 intptr_t 或 uintptr_t 来保存指针数值；<br>兼容大/小端，因此禁止把不同大小的指针类型强制转换；</li>
</ul>
</li>
</ul>
</li>
<li>除非按 ESC 键，我们假设游戏程序不结束；如果检测到 halt() 的调用 (包括 assert 失败，我们可能会增加一些额外的合法性检查)，将判定为错 (Runtime Error 或 Wrong Answer)；</li>
<li>如果按 ESC 键后游戏不 halt()，将判定为错；</li>
<li>如果虚拟机或进程发生崩溃、非预期的重启等 (由 undefined behavior 导致，例如访问某非法内存可能导致异常或 CPU Reset)，则被判定为错；</li>
<li>其他违反 specifications 的问题，如在 ioe_init() 之前调用 io_read/io_write，将被判定为错。</li>
</ul>
<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p><strong>freestanding程序</strong>与<strong>hosted程序</strong>相对应，hosted程序是一种依赖于操作系统和标准库的程序，它可以使用C语言的所有函数，宏，类型定义和对象，它的入口函数是main，它的终止方式是return或exit。hosted程序通常用于在操作系统之上的应用程序开发。<br>freestanding程序是一种不依赖于操作系统或标准库的程序，它只能使用C语言的基本类型和数值范围定义的头文件，如<float.h>，<limits.h>，<stdarg.h>，<stddef.h>等。freestanding程序的入口函数和终止方式都是由实现定义的，它通常用于裸机开发，比如操作系统内核，引导加载器，或者C库本身的开发。</p>
<h4 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h4><h2 id="第一周阅读材料"><a href="#第一周阅读材料" class="headerlink" title="第一周阅读材料"></a>第一周阅读材料</h2><p>大概了解操作系统中<code>并发</code>、<code>持久化</code>和<code>虚拟化</code>三个大主题。这是本课程以及OSTEP的核心内容。</p>
<h1 id="【并发】多线程"><a href="#【并发】多线程" class="headerlink" title="【并发】多线程"></a>【并发】多线程</h1><p>创建一个新线程就相当于是在栈空间里新增了一条独立的栈帧链。按照状态机模型来理解，create()就是新增了一个状态，join()就是将对应的进程进入等待循环，在状态机里等价于一个环。</p>
<h2 id="多处理器编程：从入门到放弃-线程库；现代处理器和宽松内存模型"><a href="#多处理器编程：从入门到放弃-线程库；现代处理器和宽松内存模型" class="headerlink" title="多处理器编程：从入门到放弃 (线程库；现代处理器和宽松内存模型)"></a>多处理器编程：从入门到放弃 (线程库；现代处理器和宽松内存模型)</h2><h3 id="语言特性补充"><a href="#语言特性补充" class="headerlink" title="语言特性补充"></a>语言特性补充</h3><ul>
<li>volatile<br>volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，告诉编译器对该变量不做优化，都会直接从变量内存地址中读取数据，从而可以提供对特殊地址的稳定访问。<br>如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。（简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错）</li>
<li><code>__thread</code>关键字<br><code>__thread</code>是GCC的一个特色，它可以让变量成为线程局部存储，每个线程都有一份独立的变量，互不干扰。<code>__thread</code>的语法是<code>__thread</code>类型说明符 变量名，其中类型说明符可以是任何类型说明符，变量名可以是任何合法的变量名。<code>__thread</code>关键字可以用于全局变量、静态变量和局部静态变量，但不能用于函数参数、自动变量和局部非静态变量。<code>__thread</code>关键字可以用于多线程编程，它可以让变量成为线程局部存储，每个线程都有一份独立的变量，互不干扰。<code>__thread</code>关键字可以用于全局变量、静态变量和局部静态变量，但不能用于函数参数、自动变量和局部非静态变量。</li>
<li><code>__attribute__</code>关键字<br><strong>attribute</strong>是GCC的一种特色，它允许用户指定函数属性、变量属性和类型属性。这些属性可以使编译器进行更好的优化，也可以使编译器发现代码中的错误。<strong>attribute</strong>的语法是<strong>attribute</strong>((attribute-list))，其中attribute-list是一个或多个以逗号分隔的属性。<ul>
<li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html">https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html</a></li>
</ul>
</li>
<li><code>asm volatile (&quot;&quot; : : : &quot;memory&quot;);</code><br>这是一种内存屏障，它会阻止编译器对内存的优化，保证内存的可见性。这个语句告诉编译器，不要对这个语句进行优化，因为这个语句可能会对内存进行读写操作，所以编译器不要对这个语句进行优化，要保证内存的可见性。</li>
<li>atomic_int<br>原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何切换。原子操作是线程安全的，因为它不会被线程调度机制打断，所以不会有多个线程同时执行这个操作。原子操作是并发编程中的重要概念，它可以保证多线程环境下的数据一致性。而<code>atomic_int</code>是C++11标准中的一个原子操作类型，它是一个整型的原子操作类型，可以保证对它的操作是原子的。</li>
<li>管道<br><code>./a.out |head -n 100000|sort -nk 6|unic-c</code><br>head：取前n行</li>
</ul>
<p>unic-c：统计</p>
<p>sort -nk6：按第六列排序</p>
<h3 id="多线程性质验证"><a href="#多线程性质验证" class="headerlink" title="多线程性质验证"></a>多线程性质验证</h3><h4 id="线程之间共享内存，线程有独立的堆栈"><a href="#线程之间共享内存，线程有独立的堆栈" class="headerlink" title="线程之间共享内存，线程有独立的堆栈"></a>线程之间共享内存，线程有独立的堆栈</h4><h3 id="多线程程序"><a href="#多线程程序" class="headerlink" title="多线程程序"></a>多线程程序</h3><h4 id="原子性的丧失"><a href="#原子性的丧失" class="headerlink" title="原子性的丧失"></a>原子性的丧失</h4><p>阅读printf的手册，搜索\thread可以发现他是线程安全的，但是printf有缓存区，共享内存的情况下不会炸了吗？？</p>
<p>99% 的并发问题都可以用一个队列解决。把大任务切分成可以并行的小任务，<strong>worker thread</strong> 去锁保护的队列里取任务。除去不可并行的部分，剩下的部分可以获得线性的加速。</p>
<h4 id="顺序的丧失（编译优化的问题）"><a href="#顺序的丧失（编译优化的问题）" class="headerlink" title="顺序的丧失（编译优化的问题）"></a>顺序的丧失（编译优化的问题）</h4><p>O1、O2编译优化的结果不同。<br>-O1: R[eax] = sum; R[eax] += N; sum = R[eax]<br>-O2: sum += N;</p>
<h4 id="可见性的丧失"><a href="#可见性的丧失" class="headerlink" title="可见性的丧失"></a>可见性的丧失</h4><h5 id="宽松内存模型（relaxed-weak-memory-model）"><a href="#宽松内存模型（relaxed-weak-memory-model）" class="headerlink" title="宽松内存模型（relaxed/weak memory model）"></a>宽松内存模型（relaxed/weak memory model）</h5><p>存在的目的是使得单处理器执行效率更高效<br>X86背负历史包袱，为了程序员能够写汇编代码<br>ARM/RISC-V</p>
<h2 id="理解并发程序执行-Peterson算法、模型检验与软件自动化工具"><a href="#理解并发程序执行-Peterson算法、模型检验与软件自动化工具" class="headerlink" title="理解并发程序执行 (Peterson算法、模型检验与软件自动化工具)"></a>理解并发程序执行 (Peterson算法、模型检验与软件自动化工具)</h2><p>实现互斥的四条原则：</p>
<ol>
<li>任何两个进程不能同时处于临界区（critical region）</li>
<li>不应对CPU的数量和速度做任何假设</li>
<li>临界区外运行的进程不能阻塞其他进程</li>
<li>进程不能无限期等待进入临界区<h3 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h3>每个进程进入临界区后马上关闭中断和时钟中断。但是这样把屏蔽中断的权限交给用户进程是不明智的。而且多处理器中，屏蔽中断只能对本处理器有效，其他cpu还是可以运行。</li>
</ol>
<h3 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h3><p>可能违背第一条原则。在锁变量尚为0的时候，两个进程先看到了锁变量为0，然后都把锁变量为1，同时进入了临界区。读和写的操作不是原子的，可能会出现这种情况。</p>
<h3 id="严格轮换"><a href="#严格轮换" class="headerlink" title="严格轮换"></a>严格轮换</h3><p>可能违背第三条原则。<br>严格轮换是指进程按照一定的顺序进入临界区，这样就不会出现两个进程同时进入临界区的情况。但是严格轮换的缺点是，如果一个进程比另一个进程慢很多，那么就会出现一个进程一直在等待，而另一个进程一直在临界区操作的情况，这样就违背了第三条原则。</p>
<p>具体来说，在一个进程比另一个进程慢很多的时候，严格轮换有可能就会出现两个进程都在非临界区操作的时候，其中一个进程0很快完成了非临界区操作，但是另一个进程1还在忙于非临界区操作，不能转换turn为0，所以临界区外的进程1就阻塞了进程0进入临界区。</p>
<p>不断测试一个变量直到某个值出现，这种方法叫做忙等待。忙等待的缺点是浪费CPU资源。只有在临界区的时间很短的时候才适用。用于忙等待的锁称为自旋锁。</p>
<h3 id="peterson算法"><a href="#peterson算法" class="headerlink" title="peterson算法"></a>peterson算法</h3><p>实现正确的互斥协议。</p>
<p>现实例子：和舍友抢厕所。</p>
<ul>
<li>turn：轮到谁用厕所</li>
<li>interested：谁想用厕所<br>课本上的代码示例：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> N 2</span></span><br><span class="line"><span class="type">int</span> turn;</span><br><span class="line"><span class="type">int</span> interested[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enter_region</span><span class="params">(<span class="type">int</span> process)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> other;</span><br><span class="line">    other = <span class="number">1</span> - process;</span><br><span class="line">    interested[process] = TRUE;</span><br><span class="line">    turn = process;</span><br><span class="line">    <span class="keyword">while</span> (turn == process &amp;&amp; interested[other] == TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leave_region</span><span class="params">(<span class="type">int</span> process)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    interested[process] = FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
想上厕所就举旗子（interested[N]），在厕所门上贴舍友的名字（turn），然后看看轮到谁了，如果轮到自己了，就进去，否则等待（<code>while(turn == process $$ interested[other]== True);</code> ），离开的时候把厕所门上的名字撕掉（<code>interested[process] = FALSE;</code>）。<h3 id="TSL"><a href="#TSL" class="headerlink" title="TSL"></a>TSL</h3>需要硬件支持的一种方案——TSL(test-and-set lock)： 一个原子指令，可以保证在多线程环境下，对共享变量的操作是原子的。在多线程环境下，可以用它来实现互斥。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TSL RX, lock</span><br></pre></td></tr></table></figure></li>
<li>原子指令，硬件的实现是锁住了内存总线（不等同于屏蔽中断）。</li>
<li>tsl与xchg（in inter-x86）类似，都是原子指令</li>
</ul>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>Peterson算法和tsl或者xchg都有忙等待的缺点，他们的本质其实都是当一个进程想进入临界区的时候，如果不被允许，就会一直原地等待，这样会浪费CPU资源。而且可能会有优先级反转的问题。</p>
<h4 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h4><ul>
<li>优先级反转是指一个低优先级的任务L先占用了一个高优先级任务H所需要的资源，导致即使调度了H从就绪状态执行，高优先级任务H也阻塞而无法执行的情况。<h3 id="实现并发程序"><a href="#实现并发程序" class="headerlink" title="实现并发程序"></a>实现并发程序</h3>画状态机图帮助理解。<h3 id="model-checker"><a href="#model-checker" class="headerlink" title="model checker"></a>model checker</h3>jyy的工具脚本。<h2 id="M2-协程库libco"><a href="#M2-协程库libco" class="headerlink" title="M2: 协程库libco"></a>M2: 协程库libco</h2><blockquote>
<p>Coroutines are computer program components that allow execution to be suspended and resumed, generalizing subroutines for cooperative multitasking. Coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes.</p>
<p>协同程序是允许暂停和恢复执行的计算机程序组件，它概括了用于协作多任务处理的子程序。协程非常适合实现熟悉的程序组件，如协作任务、异常、事件循环、迭代器、无限列表和管道。</p>
<p>They have been described as “functions whose execution you can pause”.</p>
<p>它们被描述为“可以暂停执行的函数”。</p>
</blockquote>
</li>
</ul>
<p>在这个实验中，我们实现轻量级的用户态携谐协程 (coroutine，“协同程序”)，也称为 green threads、user-level threads，可以在一个不支持线程的操作系统上实现共享内存多任务并发。即我们希望实现 C 语言的 “函数”，它能够：</p>
<ul>
<li>被 start() 调用，从头开始运行；</li>
<li>在运行到中途时，调用 yield() 被 “切换” 出去；</li>
<li>稍后有其他协程调用 yield() 后，选择一个先前被切换的协程继续执行。</li>
</ul>
<p>实现协程库 co.h 中定义的 API：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">co</span> *<span class="built_in">co_start</span>(<span class="type">const</span> <span class="type">char</span> *name, <span class="built_in">void</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *arg);</span><br><span class="line"><span class="function"><span class="type">void</span>       <span class="title">co_yield</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>       <span class="title">co_wait</span><span class="params">(<span class="keyword">struct</span> co *co)</span></span>;</span><br></pre></td></tr></table></figure><br>协程库的使用和线程库非常类似：</p>
<ul>
<li>co_start(name, func, arg) 创建一个新的协程，并返回一个指向 struct co 的指针 (类似于 pthread_create)。<ul>
<li>新创建的协程从函数 func 开始执行，并传入参数 arg。新创建的协程不会立即执行，而是调用 co_start 的协程继续执行。</li>
<li>使用协程的应用程序不需要知道 struct co 的具体定义，因此请把这个定义留在 co.c 中；框架代码中并没有限定 struct co 结构体的设计，所以你可以自由发挥。</li>
<li>co_start 返回的 struct co 指针需要分配内存。我们推荐使用 malloc() 分配。</li>
</ul>
</li>
<li>co_wait(co) 表示当前协程需要等待，直到 co 协程的执行完成才能继续执行 (类似于pthread_join)。<ul>
<li>在被等待的协程结束后、 co_wait() 返回前，co_start 分配的 struct co 需要被释放。如果你使用 malloc()，使用 free() 释放即可。</li>
<li>因此，每个协程只能被 co_wait 一次 (使用协程库的程序应当保证除了初始协程外，其他协程都必须被 co_wait 恰好一次，否则会造成内存泄漏)。</li>
</ul>
</li>
<li>co_yield() 实现协程的切换。协程运行后一直在 CPU 上执行，直到 func 函数返回或调用 co_yield 使当前运行的协程暂时放弃执行。  <ul>
<li>co_yield 时若系统中有多个可运行的协程时 (包括当前协程)，你应当随机选择下一个系统中可运行的协程。</li>
</ul>
</li>
<li>main 函数的执行也是一个协程，因此可以在 main 中调用 co_yield 或 co_wait。main 函数返回后，无论有多少协程，进程都将直接终止。</li>
</ul>
<h3 id="本地调试的tips"><a href="#本地调试的tips" class="headerlink" title="本地调试的tips"></a>本地调试的tips</h3><p>果你希望在本地运行时保留调试信息并且不想在提交到 Online Judge 时费力地删除散落在程序中的调试信息，你可以尝试用一个你本地的宏来控制输出的行为，例如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL_MACHINE</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> debug(...) printf(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> debug()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><br>这段本地宏定义是用来在 C 或 C++ 语言中实现调试打印的功能的。调试打印是一种在程序运行时输出一些信息，以便检查程序的状态或发现错误的方法。</p>
<p>这段代码的意思是：</p>
<p>如果定义了 LOCAL<em>MACHINE 这个宏，那么 debug(…) 就会被替换成 printf(<em>_VA_ARGS</em></em>)，也就是一个标准的输出函数，可以接受任意数量的参数。<br>如果没有定义 LOCAL_MACHINE 这个宏，那么 debug(…) 就会被替换成一个空语句，也就是什么都不做。<br>这样做的好处是，可以在开发或测试时使用 debug(…) 来输出一些有用的信息，而在发布或部署时，只需要取消 LOCAL_MACHINE 的定义，就可以自动屏蔽掉所有的 debug(…)，从而不影响程序的性能或输出结果。</p>
<p>然后通过增加 -DLOCAL_MACHINE 的编译选项来实现输出控制——在 Online Judge 上，所有的调试输出都会消失。</p>
<h3 id="共享库（或者共享对象）shared-object-so-（相当于windows中的动态链接库-dll）"><a href="#共享库（或者共享对象）shared-object-so-（相当于windows中的动态链接库-dll）" class="headerlink" title="共享库（或者共享对象）shared object(.so),（相当于windows中的动态链接库.dll）"></a>共享库（或者共享对象）shared object(.so),（相当于windows中的动态链接库.dll）</h3><p>共享库可以有自己的代码、数据，甚至可以调用其他共享库 (例如 libc, libpthread 等)。共享库中全局的符号将能被加载它的应用程序调用。共享库中不需要入口 (main 函数)。我们的 Makefile 里已经写明了如何编译共享库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(NAME)-64.so: $(DEPS) <span class="comment"># 64bit shared library</span></span></span><br><span class="line">    gcc -fPIC -shared -m64 $(CFLAGS) $(SRCS) -o $@ $(LDFLAGS)</span><br></pre></td></tr></table></figure>
<p>其中 <code>-fPIC</code> <code>-fshared</code> 就代表编译成<em>位置无关代码</em>的共享库。除此之外，共享库和普通的二进制文件没有特别的区别。虽然这个文件有 +x 属性并且可以执行，但会立即得到 Segmentation Fault (可以试着用 gdb 调试它)。</p>
<h3 id="编译相关"><a href="#编译相关" class="headerlink" title="编译相关"></a>编译相关</h3><ul>
<li>I 选项代表 <code>include path</code>，使我们可以 <code>#include &lt;co.h&gt;</code>。你可以使用 gcc —verbose 编译看到编译器使用的 include paths。</li>
<li>L 选项代表增加 <code>link search path</code>。例如可以先搜索当前的路径：$(pwd)</li>
<li>l 选项代表链接某个库，链接时会自动加上 <code>lib</code> 的前缀，即 <code>-lco-64</code> 会依次在库函数的搜索路径中查找 <code>libco-64.so</code> 和 <code>libco-64.a</code>，直到找到为止。如果你将 libco-64.so 删除后用 strace 工具查看 gcc 运行时使用的系统调用，就能清晰地看到库函数解析的流程；</li>
</ul>
<p>如果不设置 <code>LD_LIBRARY_PATH</code> 环境变量，你将会遇到 “error while loading shared libraries: libco-xx.so: cannot open shared object file: No such file or directory” 的错误。</p>
<h3 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="volatile-register-and-non-volatile-registers"><a href="#volatile-register-and-non-volatile-registers" class="headerlink" title="volatile register and non-volatile registers"></a>volatile register and non-volatile registers</h4><p>CPU registers can be classified as volatile and non-volatile by calling convension, how does does the meaning of word volatile implies the classification?</p>
<blockquote>
<p>Volatile registers’ content may change over a subroutine call.<br>易失性寄存器的内容可能在子例程调用中发生变化。</p>
<p>A non-volatile register is a type of register with contents that must be preserved over subroutine calls. Whenever the value of a nonvolatile register is changed by the routine, the old value has to be saved on the stack prior to changing the register and that value has to be restored before returning. A register is similar to a variable, except that there is a fixed number of registers. Every register is a unique location in the CPU in which a single value is saved. A register is the one and only place where mathematical functions, such as addition, multiplication, subtraction, etc., can be carried out. Registers often hold pointers that refer to the memory. Moving values between memory and registers is a common phenomenon.<br>非易失性寄存器是一种寄存器类型，其内容必须在子例程调用中保存。每当例程更改了非易失性寄存器的值时，必须在更改寄存器之前将旧值保存在堆栈上，并且必须在返回之前恢复该值。寄存器类似于变量，不同之处在于寄存器的数量是固定的。每个寄存器在CPU中都是一个唯一的位置，其中保存一个值。寄存器是唯一可以执行诸如加、乘、减等数学函数的地方。寄存器通常保存指向内存的指针。在内存和寄存器之间移动值是一种常见的现象。</p>
</blockquote>
<h4 id="System-V-ABI"><a href="#System-V-ABI" class="headerlink" title="System V ABI"></a>System V ABI</h4><p>x86-64 调用约定（System V ABI）<br>前 6 个参数寄存器：</p>
<p>前 6 个函数参数分别保存在 rdi, rsi, rdx, rcx, r8, r9 寄存器中。<br>co_yield 没有参数，因此这些寄存器的值在 co_yield 中没有意义，可以任意修改。<br>可任意改写的寄存器：</p>
<p>co_yield 可以任意改写以下寄存器的值：rdi, rsi, rdx, rcx, r8, r9, rax（返回值寄存器）, r10, r11。<br>返回后，调用者（如 foo 函数）仍然能够正确执行。<br>必须保持一致的寄存器：</p>
<p>co_yield 返回时，必须保证以下寄存器的值和调用时保持一致：rbx, rsp, rbp, r12, r13, r14, r15。<br>这些寄存器称为 “callee saved” 或 “non-volatile registers” 或 “call preserved” 寄存器。<br>与之相对的是 “caller saved” 或 “volatile” 或 “call-clobbered” 寄存器。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul>
<li>co_start 会在共享内存中创建一个新的状态机 (堆栈和寄存器也保存在共享内存中)，仅此而已。新状态机的 %rsp 寄存器应该指向它独立的堆栈，%rip 寄存器应该指向 co_start 传递的 func 参数。根据 32/64-bit，参数也应该被保存在正确的位置 (x86-64 参数在 %rdi 寄存器，而 x86 参数在堆栈中)。main 天然是个状态机，就对应了一个协程；</li>
<li>co_yield 会将当前运行协程的寄存器保存到共享内存中，然后选择一个另一个协程，将寄存器加载到 CPU 上，就完成了 “状态机的切换”；</li>
<li>co_wait 会等待状态机进入结束状态，即 func() 的返回。</li>
</ul>
<p>换句话说，我们已经有答案了：co_yield 要做的就是把 yield 瞬间的 call preserved registers “封存” 下来 (其他寄存器按照 ABI 约定，co_yield 既然是函数，就可以随意摧毁)，然后执行堆栈 (rsp) 和执行流 (rip) 的切换.</p>
<p>因此，为了实现 co_yield，我们需要做的事情其实是：</p>
<ol>
<li>为每一个协程分配独立的堆栈；堆栈顶的指针由 %rsp 寄存器确定；</li>
<li>在 co_yield 发生时，将寄存器保存到属于该协程的 struct co 中 (包括 %rsp)；</li>
<li>切换到另一个协程执行，找到系统中的另一个协程，然后恢复它 struct co 中的寄存器现场 (包括 %rsp)。</li>
</ol>
<h4 id="setjmp-longjmp-实现寄存器现场的保存和恢复"><a href="#setjmp-longjmp-实现寄存器现场的保存和恢复" class="headerlink" title="setjmp/longjmp 实现寄存器现场的保存和恢复"></a>setjmp/longjmp 实现寄存器现场的保存和恢复</h4><p>使用 C 语言标准库中的 setjmp/longjmp 函数来实现寄存器现场的保存和恢复。</p>
<p><code>setjmp</code> 将程序执行时的当前环境(程序状态)保存到一个平台特定的数据结构( jmp_buf )中，该数据结构可在以后的程序执行时由 <code>longjmp</code> 将 <code>setjmp</code> 保存的程序状态恢复到 <code>jmp_buf</code> 中。这个过程可以想象成是一个“跳转”回到 <code>setjmp</code> 保存环境的程序执行点。 <code>setjmp</code> 的返回值(表面)表明控制是正常到达该点(零)还是调用 <code>longjmp</code> (非零)。这就产生了一个常见的习语: <code>if( setjmp(x) )&#123;/* handle longjmp(x) */&#125;</code> 。</p>
<p>setjmp和longjmp不能用C语言直接实现，需要内联汇编指令。</p>
<p>简单的使用例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> jmp_buf buf;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">second</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;second\n&quot;</span>);         <span class="comment">// prints</span></span><br><span class="line">    longjmp(buf, <span class="number">1</span>);            <span class="comment">// jumps back to where setjmp was called - making setjmp now return 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">first</span><span class="params">()</span> &#123;</span><br><span class="line">    second();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;first\n&quot;</span>);          <span class="comment">// does not print</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!setjmp(buf))</span><br><span class="line">        first();                <span class="comment">// when executed, setjmp returned 0</span></span><br><span class="line">    <span class="keyword">else</span>                        <span class="comment">// when longjmp jumps back, setjmp returns 1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main\n&quot;</span>);       <span class="comment">// prints</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ps: POSIX.1没有指定 setjmp 和 longjmp 是否保存和恢复当前阻塞信号集;如果一个程序使用信号处理，它应该使用POSIX的 sigsetjmp / siglongjmp 。</p>
<h4 id="实现寄存器现场切换"><a href="#实现寄存器现场切换" class="headerlink" title="实现寄存器现场切换"></a>实现寄存器现场切换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static inline void stack_switch_call(void *sp, void *entry, uintptr_t arg) &#123;</span><br><span class="line">  asm volatile (</span><br><span class="line">#if __x86_64__</span><br><span class="line">    &quot;movq %0, %%rsp;</span><br><span class="line">     movq %2, %%rdi; </span><br><span class="line">     jmp *%1&quot;</span><br><span class="line">      : : &quot;b&quot;((uintptr_t)sp), &quot;d&quot;(entry), &quot;a&quot;(arg) : &quot;memory&quot;</span><br><span class="line">#else</span><br><span class="line">    &quot;movl %0, %%esp; movl %2, 4(%0); jmp *%1&quot;</span><br><span class="line">      : : &quot;b&quot;((uintptr_t)sp - 8), &quot;d&quot;(entry), &quot;a&quot;(arg) : &quot;memory&quot;</span><br><span class="line">#endif</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个函数的参数包括：</p>
<ul>
<li><strong>sp</strong>: 栈指针，指向当前执行函数的栈帧。</li>
<li><strong>entry</strong>: 要调用的函数的入口地址。</li>
<li><strong>arg</strong>: 要传递给调用函数的参数。</li>
</ul>
<p>这个函数的作用是在栈上创建一个新的栈帧，将入口地址和参数压入栈中，然后执行调用指令。当调用完成后，栈帧会被弹出，并恢复原来的栈指针和返回地址。</p>
</blockquote>
<p>每当 <code>co_yield()</code> 发生时，我们都会选择一个协程继续执行，此时必定为以下两种情况之一 (思考为什么)：</p>
<ol>
<li>选择的协程是新创建的，此时该协程还没有执行过任何代码，我们需要首先执行 <code>stack_switch_call</code> 切换堆栈，然后开始执行协程的代码；</li>
<li>选择的协程是调用 <code>yield()</code> 切换出来的，此时该协程已经调用过 <code>setjmp</code> 保存寄存器现场，我们直接 <code>longjmp</code> 恢复寄存器现场即可。</li>
</ol>
<h4 id="管理co-start-时分配的-struct-co-结构体资源"><a href="#管理co-start-时分配的-struct-co-结构体资源" class="headerlink" title="管理co_start 时分配的 struct co 结构体资源"></a>管理co_start 时分配的 struct co 结构体资源</h4><p>因为 co_wait 执行的时候，有两种不同的可能性：</p>
<ol>
<li>此时协程已经结束 (func 返回)，这是完全可能的。此时，co_wait 应该直接回收资源。</li>
<li>此时协程尚未结束，因此 co_wait 不能继续执行，必须调用 co_yield 切换到其他协程执行，直到协程结束后唤醒。</li>
</ol>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><blockquote>
<p>但如果想要调试代码？gdb libco-test-64 同样也会遇到共享库查找失败的问题。大家可以在终端中使用 export 将当前 shell 进程的 LD_LIBRARY_PATH 设置好，这样就可以无障碍地运行 ./libco-test-64 了。</p>
</blockquote>
<h4 id="segmentation-fault"><a href="#segmentation-fault" class="headerlink" title="segmentation fault"></a>segmentation fault</h4><h4 id="valgrind"><a href="#valgrind" class="headerlink" title="valgrind"></a>valgrind</h4><h2 id="并发控制：互斥-自旋锁、互斥锁和-futex"><a href="#并发控制：互斥-自旋锁、互斥锁和-futex" class="headerlink" title="并发控制：互斥 (自旋锁、互斥锁和 futex)"></a>并发控制：互斥 (自旋锁、互斥锁和 futex)</h2><h3 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h3><ul>
<li>原子指令：不可分割的指令</li>
<li>自旋锁：在获取锁失败时，不断循环检查锁是否可用</li>
<li>互斥锁：在获取锁失败时，将线程挂起，直到锁可用</li>
<li>futex：fast user space mutex，用户空间的快速互斥锁</li>
<li>临界区：一段代码，只能有一个线程进入</li>
<li>长临界区：临界区执行时间较长</li>
<li>短临界区：临界区执行时间较短<h3 id="原子指令和自旋锁-Spin-Lock"><a href="#原子指令和自旋锁-Spin-Lock" class="headerlink" title="原子指令和自旋锁(Spin Lock)"></a>原子指令和自旋锁(Spin Lock)</h3></li>
</ul>
<p>实现互斥的根本困难：不能同时读/写共享内存</p>
<ul>
<li><code>load</code> (环顾四周) 的时候不能写，只能 “看一眼就把眼睛闭上”，看到的东西马上就过时了</li>
<li><code>store</code> (改变物理世界状态) 的时候不能读，只能 “闭着眼睛动手”也不知道把什么改成了什么</li>
</ul>
<p>解决问题的一个思路是从硬件上着手：<em>假设硬件能为我们提供一条 “瞬间完成” 的读 + 写指令</em></p>
<p>请所有人闭上眼睛，看一眼 (load)，然后贴上标签 (store)。如果多人同时请求，硬件选出一个 “胜者”，“败者” 要等 “胜者” 完成后才能继续执行</p>
<p>那就是具有“时停”能力or“霸体”能力的原子指令啦~</p>
<p><code>xchg</code>: 最小的load + store。交换两个变量的值。这个指令是为多处理器设计的，是原子的，不会被打断。</p>
<p>Atomic exchange (load + store)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">xchg</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *addr, <span class="type">int</span> newval)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lock xchg %0, %1&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">&quot;+m&quot;</span>(*addr), <span class="string">&quot;=a&quot;</span>(result) : <span class="string">&quot;1&quot;</span>(newval))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="现实例子"><a href="#现实例子" class="headerlink" title="现实例子"></a>现实例子</h4><p>一开始桌子上放有唯一的钥匙，每个人手中也有一张校卡。来的人会把自己手中的校卡跟桌子上的东西进行交换（或者说是覆盖）（不管是钥匙还是校卡），由于钥匙是唯一的，所以每次都只有拥有钥匙（或者说最开始可以看见钥匙）的那一个人可以进入，正确性不证自明。对应的也就是这段代码每次只能由一个线程进入。</p>
<h4 id="用-xchg-实现互斥"><a href="#用-xchg-实现互斥" class="headerlink" title="用 xchg 实现互斥"></a>用 xchg 实现互斥</h4><p>如何协调宿舍若干位同学上厕所问题？</p>
<p>在厕所门口放一个桌子table (共享变量),初始时，桌上是 🔑</p>
<h5 id="实现互斥的协议"><a href="#实现互斥的协议" class="headerlink" title="实现互斥的协议"></a>实现互斥的协议</h5><p>想上厕所的同学 (一条 xchg 指令)</p>
<ul>
<li>天黑请闭眼</li>
<li>看一眼桌子上有什么 (🔑 或 🔞)</li>
<li>把 🔞 放到桌上 (覆盖之前有的任何东西)</li>
<li>天亮请睁眼；看到 🔑 才可以进厕所哦<br>出厕所的同学把 🔑 放到桌上</li>
</ul>
<h4 id="实现互斥"><a href="#实现互斥" class="headerlink" title="实现互斥"></a>实现互斥</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> table = YES;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">retry:</span><br><span class="line">  <span class="type">int</span> got = <span class="built_in">xchg</span>(&amp;table, NOPE);</span><br><span class="line">  <span class="keyword">if</span> (got == NOPE)</span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">  <span class="built_in">assert</span>(got == YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">xchg</span>(&amp;table, YES)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> locked = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; <span class="keyword">while</span> (<span class="built_in">xchg</span>(&amp;locked, <span class="number">1</span>)) ; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; <span class="built_in">xchg</span>(&amp;locked, <span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>需要做详尽的测试。</p>
<p>用原子指令可以把所有的并发进程排列出顺序，消灭了并行并且保证了可见性。保证之前的 store 都写入内存<br>，保证 load/store 不与原子指令乱序。</p>
<h4 id="原子指令的实现"><a href="#原子指令的实现" class="headerlink" title="原子指令的实现"></a>原子指令的实现</h4><p>原子指令的诞生：Bus Lock (80486)</p>
<ul>
<li>dual socket：两个处理器共享一块内存。socket：就是主板上插cpu的槽的数目，也即管理员说的”路“，一般做server chip说的dual-socket, 就是双路直连的芯片，主要是因为单芯片性能不够，而限于工艺尺寸又没办法放更多的资源在一颗芯片，所以需要多路。这样就可以把多个cpu的资源整合在一起，提高整体的性能。</li>
</ul>
<h4 id="Load-Reserved-Store-Condtitional-LR-SC"><a href="#Load-Reserved-Store-Condtitional-LR-SC" class="headerlink" title="Load-Reserved/Store-Condtitional(LR/SC)"></a>Load-Reserved/Store-Condtitional(LR/SC)</h4><p>归纳目前常见的原子指令（atomic test-and-set、lock xchg、lock add），他们的本质都是：<strong>load + 处理器本地寄存器的运算 + store</strong></p>
<p>而RISC-V有另一种原子操作的设计：(LR/SC)</p>
<ul>
<li>LR: 在内存上标记 reserved (盯上你了)，中断、其他处理器写入都会导致标记消除。</li>
<li>SC: 如果 “盯上” 未被解除，则写入</li>
</ul>
<p>例如，如果同时有两个人对同一片内存进行了标记（load reserved），总有其中一方会在完成处理器本地寄存器的运算后，率先进行写入，此时另一方先前的标记就消失了，他就没法再直接写入了，需要重新标记再重做运算再写入。</p>
<p>除此之外，这个机制和之前的原子指令相比，还可以根据标记来检测锁的拥堵。</p>
<h5 id="Campare-and-Swap-CAS-的LR-SC实现"><a href="#Campare-and-Swap-CAS-的LR-SC实现" class="headerlink" title="Campare and Swap (CAS)的LR/SC实现"></a>Campare and Swap (CAS)的LR/SC实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cas</span><span class="params">(<span class="type">int</span> *addr, <span class="type">int</span> cmp_val, <span class="type">int</span> new_val)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> old_val = *addr;</span><br><span class="line">  <span class="keyword">if</span> (old_val == cmp_val) &#123;</span><br><span class="line">    *addr = new_val; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">检查上一次获得的值是否还有效，如果有效则写入新值，否则返回失败。</span><br></pre></td></tr></table></figure>
<p>汇编代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cas:</span><br><span class="line">  lr.w  t0, (a0)       # Load original value.</span><br><span class="line">  bne   t0, a1, fail   # Doesn’t match, so fail.</span><br><span class="line">  sc.w  t0, a2, (a0)   # Try to update.</span><br><span class="line">  bnez  t0, cas        # Retry if store-conditional failed.</span><br><span class="line">  li a0, 0             # Set return to success.</span><br><span class="line">  jr ra                # Return.</span><br><span class="line">fail:</span><br><span class="line">  li a0, 1             # Set return to failure.</span><br><span class="line">  jr ra                # Return</span><br></pre></td></tr></table></figure></p>
<h4 id="cmpxchg（2023）"><a href="#cmpxchg（2023）" class="headerlink" title="cmpxchg（2023）"></a>cmpxchg（2023）</h4><p>RTFM: <a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/cmpxchg">https://www.felixcloutier.com/x86/cmpxchg</a></p>
<h3 id="系统调用和互斥锁-Mutex-Lock"><a href="#系统调用和互斥锁-Mutex-Lock" class="headerlink" title="系统调用和互斥锁 (Mutex Lock)"></a>系统调用和互斥锁 (Mutex Lock)</h3><h4 id="自旋锁的缺陷"><a href="#自旋锁的缺陷" class="headerlink" title="自旋锁的缺陷"></a>自旋锁的缺陷</h4><ul>
<li>性能问题 (0)（2022）<ul>
<li>自旋 (共享变量) 会触发处理器间的缓存同步，延迟增加</li>
</ul>
</li>
<li>性能问题 (1)<ul>
<li>除了进入临界区的线程，其他处理器上的线程都在<strong>空转</strong></li>
<li>争抢锁的处理器越多，利用率越低</li>
</ul>
</li>
<li>性能问题 (2)<ul>
<li>获得自旋锁的线程可能<strong>被操作系统切换出去</strong></li>
<li>操作系统不 “感知” 线程在做什么</li>
<li>实现 100% 的资源浪费（唯一那个有教室钥匙的人在宿舍睡觉,别的人都在白等）</li>
</ul>
</li>
<li>Scalability: 性能的新维度<br>同一份计算任务，时间 (CPU cycles) 和空间 (mapped memory) 会随处理器数量的增长而变化。为了保证读取的值是正确的，共享的变量会在处理器的L1缓存之间来回传递，增大开销。<h4 id="自旋锁的使用场景"><a href="#自旋锁的使用场景" class="headerlink" title="自旋锁的使用场景"></a>自旋锁的使用场景</h4></li>
<li>临界区几乎不 “拥堵”</li>
<li>持有自旋锁时禁止执行流切换<br>使用场景：操作系统内核的并发数据结构 (短临界区)</li>
</ul>
<p>自旋锁可以说是实现多处理器互斥的唯一方法。在操作系统内核中是很难避免的。</p>
<ul>
<li>操作系统可以<em>关闭中断和抢占</em><ul>
<li>保证锁的持有者在很短的时间内可以释放锁（自旋锁的持有者不会被操作系统切换出去，所以自旋锁的持有者必须尽快释放锁，以免其他线程长时间等待。）</li>
</ul>
</li>
<li>如果是虚拟机<ul>
<li>PAUSE 指令会触发 VM Exit</li>
</ul>
</li>
<li>但依旧很难做好<ul>
<li>An analysis of Linux scalability to many cores (OSDI’10)<h4 id="实现线程-长临界区的互斥"><a href="#实现线程-长临界区的互斥" class="headerlink" title="实现线程 + 长临界区的互斥"></a>实现线程 + 长临界区的互斥</h4><blockquote>
<p>作业那么多，与其干等 Online Judge 发布，不如把自己 (CPU) 让给其他作业 (线程) 执行？</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>操作系统先用自旋锁保护临界区，然后再去看能不能得到锁，能得到的话系统调用直接返回；得不到锁的线程，选择不浪费CPU，切换为不可运行，然后切换到另一个线程去运行。</p>
<p>“让” 不是 C 语言代码可以做到的 (C 代码只能计算)。所以把锁的实现放到操作系统里就好啦！</p>
<p><code>syscall(SYSCALL_lock, &amp;lk);</code><br>试图获得 lk，但如果失败，就切换到其他线程;</p>
<p><code>syscall(SYSCALL_unlock, &amp;lk);</code><br>释放 lk，如果有等待锁的线程就唤醒</p>
<p>线程 + 长临界区的互斥的现实例子：</p>
<blockquote>
<p>操作系统 = 更衣室管理员</p>
<p>先到的人 (线程)成功获得手环，进入游泳馆</p>
<p>*lk = 🔒，系统调用直接返回</p>
<p>后到的人 (线程)不能进入游泳馆，排队等待</p>
<p>线程放入等待队列，执行线程切换 (yield)</p>
<p>洗完澡出来的人 (线程)</p>
<p>交还手环给管理员；管理员把手环再交给排队的人</p>
<p>如果等待队列不空，从等待队列中取出一个线程允许执行</p>
<p>如果等待队列为空，*lk = ✅</p>
<p>管理员 (OS) 使用自旋锁确保有多个人同时进入的时候自己处理手环的过程是原子的，不会有并发问题。</p>
<h3 id="futex系统调用（2022）"><a href="#futex系统调用（2022）" class="headerlink" title="futex系统调用（2022）"></a>futex系统调用（2022）</h3><p>Futex = Spin + Mutex</p>
</blockquote>
<h4 id="关于互斥的一些分析（2022）"><a href="#关于互斥的一些分析（2022）" class="headerlink" title="关于互斥的一些分析（2022）"></a>关于互斥的一些分析（2022）</h4><p>自旋锁 (线程直接共享 locked)</p>
<ul>
<li>更快的 fast path<ul>
<li>xchg 成功 → 立即进入临界区，开销很小</li>
</ul>
</li>
<li>更慢的 slow path<ul>
<li>xchg 失败 → 浪费 CPU 自旋等待，而且为了自旋还得关闭中断关闭抢占</li>
</ul>
</li>
</ul>
<p>互斥锁 (通过系统调用访问 locked)</p>
<ul>
<li>更快的 slow path<ul>
<li>上锁失败线程不再占用 CPU</li>
</ul>
</li>
<li>更慢的 fast path<ul>
<li>即便上锁成功也需要进出内核 (syscall)</li>
</ul>
</li>
</ul>
<blockquote>
<p>小孩子才做选择</p>
<ul>
<li>Fast path: 一条原子指令，上锁成功立即返回</li>
<li>Slow path: 上锁失败，执行系统调用睡眠</li>
</ul>
</blockquote>
<p>POSIX线程库中的互斥锁（pthread_mutex），两种锁的好处都获得了。成功马上进临界区，失败就进入内核。</p>
<h3 id="总结（2022）"><a href="#总结（2022）" class="headerlink" title="总结（2022）"></a>总结（2022）</h3><h4 id="Take-away-message"><a href="#Take-away-message" class="headerlink" title="Take-away message"></a>Take-away message</h4><ul>
<li>软件不够，硬件来凑 (自旋锁)</li>
<li>用户不够，内核来凑 (互斥锁)<ul>
<li>找到你依赖的假设，并大胆地打破它</li>
</ul>
</li>
<li>Fast/slow paths: 性能优化的重要途径</li>
</ul>
<h2 id="并发控制：同步（信号量和条件变量，生产者和消费者，哲♂学家吃饭问题）"><a href="#并发控制：同步（信号量和条件变量，生产者和消费者，哲♂学家吃饭问题）" class="headerlink" title="并发控制：同步（信号量和条件变量，生产者和消费者，哲♂学家吃饭问题）"></a>并发控制：同步（信号量和条件变量，生产者和消费者，哲♂学家吃饭问题）</h2><p>同步：协调多个线程的执行顺序，以避免竞争条件和死锁。两个或者两个以上的随时间变化的量在变化过程中保持一定的相对关系</p>
<h3 id="生产者和消费者问题"><a href="#生产者和消费者问题" class="headerlink" title="生产者和消费者问题"></a>生产者和消费者问题</h3><p>99% 的实际并发问题都可以用生产者-消费者解决。</p>
<p>可以用生产者打印左括号，消费者打印右括号来模拟。</p>
<h3 id="信号量和条件变量"><a href="#信号量和条件变量" class="headerlink" title="信号量和条件变量"></a>信号量和条件变量</h3><p>Conditional Variables (条件变量, CV)。</p>
<h4 id="条件变量的API"><a href="#条件变量的API" class="headerlink" title="条件变量的API"></a>条件变量的API</h4><ul>
<li>wait(cv,mutex)<ul>
<li>调用的时候必须保证<strong>已经得到mutex</strong></li>
<li><strong>释放mutex</strong>，进入睡眠状态</li>
</ul>
</li>
<li>signal/notify(cv)<ul>
<li>唤醒一个等待的线程</li>
</ul>
</li>
<li>broadcast/notifyAll(cv)<ul>
<li>唤醒所有等待cv的线程<h4 id="条件变量实现生产者消费者"><a href="#条件变量实现生产者消费者" class="headerlink" title="条件变量实现生产者消费者"></a>条件变量实现生产者消费者</h4></li>
</ul>
</li>
<li><code>count</code>：当前缓冲区中的产品数量</li>
<li><code>count == 0</code>：缓冲区为空，消费者睡眠</li>
<li><code>count == n</code>：缓冲区满，生产者睡眠</li>
</ul>
<p>睡眠唤醒机制避免了自旋锁的浪费，但是需要更多的系统调用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tproduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">mutex_lock</span>(&amp;lk);</span><br><span class="line">  <span class="keyword">if</span> (count == n) <span class="built_in">cond_wait</span>(&amp;cv, &amp;lk);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>); count++; <span class="built_in">cond_signal</span>(&amp;cv);</span><br><span class="line">  <span class="built_in">mutex_unlock</span>(&amp;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tconsume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">mutex_lock</span>(&amp;lk);</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="built_in">cond_wait</span>(&amp;cv, &amp;lk);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>); count--; <span class="built_in">cond_signal</span>(&amp;cv);</span><br><span class="line">  <span class="built_in">mutex_unlock</span>(&amp;lk);</span><br><span class="line">&#125;</span><br><span class="line">jyy上课的时候还进行了压力测试。</span><br></pre></td></tr></table></figure><br>压力测试后介绍了隔离bug最小触发条件，然后通过分析得到了不能同类唤醒，否则会出现缓冲区溢出的问题。</p>
<p>唤醒失败时，可能导致两个进程都进入sleep，解决方法一是加上<code>唤醒等待位</code>，当进程接收到唤醒信号，但当前仍处于awake时，唤醒等待位置1，当下次收到sleep信号时，唤醒等待位置0，忽略此次sleep，但是每多一个进程都会多一个位，因此引出了信号量的机制。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量可以用来解决睡眠唤醒机制sleep和wakeup的累计的问题。</p>
<p>信号量相当于是互斥锁的拓展，原本只有一把钥匙，现在有很多把钥匙，就变成了一个计数器。</p>
<p>信号量（Semaphore）是一个计数器，用于控制对公共资源的访问。它是一个非负整数（计数器），用于表示可以使用的资源的数量。信号量的值大于0表示可用资源的数量，小于0表示等待资源的线程数量。</p>
<p>信号量的操作包括两个原子操作：<code>P</code> 和 <code>V</code>。</p>
<ul>
<li><code>P</code>（Proberen）：尝试获取资源，如果资源不可用，则等待。</li>
<li><code>V</code>（Verhogen）：释放资源，唤醒等待的线程。</li>
<li><code>P</code> 和 <code>V</code> 操作是原子的，不会被打断。</li>
<li><code>P</code> 操作会将信号量的值减一，如果值小于0，则线程会进入等待状态。</li>
<li><code>V</code> 操作会将信号量的值加一，如果有线程在等待，则唤醒一个线程。</li>
<li>信号量可以分为同步信号量或者互斥信号量。</li>
</ul>
<p>还是用游泳池更衣室的例子。</p>
<p>从游泳馆出来，看到有人在等，不经过管理员直接把手环给等待的人，等待的人就可以进去了。如果没人在等，就把手环交给管理员。</p>
<blockquote>
<p>由于Dijisktra是荷兰人，他用的<code>P</code>和<code>V</code>其实是相当于荷兰语的“Probeer”和“Verhoog”，可以看作是“down”和“up”（分别是一般化后的sleep和wakeup）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">P</span>(&amp;empty);   <span class="comment">// P()返回 -&gt; 得到手环</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>); <span class="comment">// 假设线程安全</span></span><br><span class="line">  <span class="built_in">V</span>(&amp;fill);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">P</span>(&amp;fill);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">  <span class="built_in">V</span>(&amp;empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DOWN</span>(S):</span><br><span class="line">  S.count = S.count - <span class="number">1</span>;<span class="comment">//减少信号量的值</span></span><br><span class="line">  <span class="keyword">if</span> (S.count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//将当前线程加入等待队列</span></span><br><span class="line">    <span class="built_in">block</span>(S);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">UP</span>(S):</span><br><span class="line">  S.count = S.count + <span class="number">1</span>;<span class="comment">//增加信号量的值</span></span><br><span class="line">  <span class="keyword">if</span> (S.count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//唤醒等待队列中的一个线程</span></span><br><span class="line">    <span class="built_in">wakeup</span>(S);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>信号量可以用来实现互斥或者同步。（互斥信号量/同步信号量）</p>
<ol>
<li>信号量的物理含义</li>
</ol>
<ul>
<li>S&gt;0表示有S个资源可用</li>
<li>S=0表示无资源可用</li>
<li>S&lt;0则|S|表示S等待队列中的进程个数</li>
<li>P(S)表示申请一个资源，V(S)表示释放一个资源</li>
<li>信号量的初值应该大于等于0</li>
</ul>
<ol>
<li>P,V操作必须成对出现，有一个P操作就一定有一个V操作</li>
</ol>
<ul>
<li>当为互斥操作时，它们同处于同一进程；当为同步操作时，则不在同一进程中出现。</li>
<li>如果P(S1)和P(S2)两个操作在一起，那么P操作的顺序至关重要，一个同步P操作与一个互斥P操作在一起时同步P操作在互斥P操作前；而两个V操作的顺序无关紧要。</li>
</ul>
<p>虽然看起来简单，但是主要是在 “一单位资源” 明确的问题上更好用，一些复杂的场景可能会有其他问题。信号量的控制分布在整个程序中，很难分析其正确性。</p>
<h3 id="（课本上也有的）哲♂学家吃饭问题"><a href="#（课本上也有的）哲♂学家吃饭问题" class="headerlink" title="（课本上也有的）哲♂学家吃饭问题"></a>（课本上也有的）哲♂学家吃饭问题</h3><ul>
<li>同时拿起左手的叉子——死锁。</li>
<li>同时拿起左手的叉子，然后发现右手的叉子被别人拿走了，于是放下左手的叉子，又一起继续等待叉子，陷入循环——饥饿。</li>
</ul>
<p>失败的尝试（信号量）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread-sync.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3</span></span><br><span class="line"><span class="type">sem_t</span> locks[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tphilosopher</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lhs = (N + id - <span class="number">1</span>) % N;</span><br><span class="line">  <span class="type">int</span> rhs = id % N;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">P</span>(&amp;locks[lhs]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;T%d Got %d\n&quot;</span>, id, lhs + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">P</span>(&amp;locks[rhs]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;T%d Got %d\n&quot;</span>, id, rhs + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">V</span>(&amp;locks[lhs]);</span><br><span class="line">    <span class="built_in">V</span>(&amp;locks[rhs]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="built_in">SEM_INIT</span>(&amp;locks[i], <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="built_in">create</span>(Tphilosopher);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>失败的原因：</p>
<p>成功的万能解决方案（条件变量）：<br>对于任意一个哲学家，只有在左右两边的叉子都可用的时候才能拿起叉子。</p>
<p>先上一把互斥锁，然后判断左右两边的叉子是否可用，如果不可用就等待，如果可用就拿起叉子。在锁的保护下，把两个叉子都拿起来，然后吃饭，吃完后放下叉子，释放锁。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mutex_lock</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span> (!(avail[lhs] &amp;&amp; avail[rhs])) &#123;</span><br><span class="line">  <span class="built_in">wait</span>(&amp;cv, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">avail[lhs] = avail[rhs] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">mutex_lock</span>(&amp;mutex);</span><br><span class="line">avail[lhs] = avail[rhs] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">broadcast</span>(&amp;cv);</span><br><span class="line"><span class="built_in">mutex_unlock</span>(&amp;mutex);</span><br></pre></td></tr></table></figure></p>
<h4 id="leader-follower模式"><a href="#leader-follower模式" class="headerlink" title="leader/follower模式"></a>leader/follower模式</h4><p>让一个人来集中管理叉子。<br>分布式系统中很常见的解决思路HDFS。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tphilosopher</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">send_request</span>(id, EAT);</span><br><span class="line">  <span class="built_in">P</span>(allowed[id]); <span class="comment">// waiter 会把叉子递给哲学家</span></span><br><span class="line">  <span class="built_in">philosopher_eat</span>();</span><br><span class="line">  <span class="built_in">send_request</span>(id, DONE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Twaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    (id, status) = <span class="built_in">receive_request</span>();</span><br><span class="line">    <span class="keyword">if</span> (status == EAT) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == DONE) &#123; ... &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>管叉子的人一定不会是性能瓶颈，抛开 <code>workload</code>谈优化就是耍流氓.</p>
<p>吃饭的时间通常远远大于请求服务员的时间。</p>
<p>如果一个 <code>manager</code> 搞不定，可以分多个<code>(fast/slow path)</code>，多层服务员分发。</p>
<p>把系统设计好，使集中管理不成为瓶颈。</p>
<h3 id="（课本上的）读者写者问题-Readers-and-Writers"><a href="#（课本上的）读者写者问题-Readers-and-Writers" class="headerlink" title="（课本上的）读者写者问题(Readers and Writers)"></a>（课本上的）读者写者问题(Readers and Writers)</h3><ul>
<li>读者写者问题：多个读者可以同时读，但是写者必须独占<h3 id="管程monitor，消息传递，屏障（简单了解）"><a href="#管程monitor，消息传递，屏障（简单了解）" class="headerlink" title="管程monitor，消息传递，屏障（简单了解）"></a>管程monitor，消息传递，屏障（简单了解）</h3>在并发编程中，管程（Monitor）、消息传递（Message Passing）和屏障（Barrier）是三种常见的同步机制或通信方式，它们在多线程和分布式系统中广泛应用，以确保数据的一致性和任务的协调执行。下面简单介绍一下这三种机制：</li>
</ul>
<h4 id="管程（Monitor）"><a href="#管程（Monitor）" class="headerlink" title="管程（Monitor）"></a>管程（Monitor）</h4><p>管程是一种同步构造，用于管理对共享资源的访问。它是由并发编程先驱Tony Hoare在1970年代提出的概念。一个管程包括一组定义在一个特定锁或互斥量（mutex）保护下的变量，以及在这个锁保护下可以执行的一组过程（函数或方法）。这意味着任何时候只有一个线程可以在管程内部执行某个过程，从而避免了并发访问共享资源时可能出现的数据不一致问题。管程通常提供了条件变量和相应的等待/通知机制（如wait和signal操作），以便在某些条件尚未满足时挂起线程，并在条件满足时唤醒线程。</p>
<h4 id="消息传递（Message-Passing）"><a href="#消息传递（Message-Passing）" class="headerlink" title="消息传递（Message Passing）"></a>消息传递（Message Passing）</h4><p>消息传递是一种在并发或分布式系统中的进程或线程之间进行通信的机制，它通过发送和接收消息来传递数据或通知。这种机制特别适用于分布式系统，其中的进程可能分布在不同的物理机器上。消息传递可以是同步的（发送方直到消息被接收方接收才继续执行）或者是异步的（发送方发送消息后立即继续执行，不等待接收方确认）。消息传递避免了共享内存的复杂性和潜在的竞态条件，但可能引入通信延迟和消息排序等问题。</p>
<h4 id="屏障（Barrier）"><a href="#屏障（Barrier）" class="headerlink" title="屏障（Barrier）"></a>屏障（Barrier）</h4><p>屏障是一种同步机制，用于多线程或多进程编程中，在执行后续操作前等待一组并行任务都达到某个点。屏障像是一个检查点，确保所有并行执行的任务都到达这个检查点后，才能继续执行后面的操作。这对于分步骤执行的并行算法非常有用，其中每个步骤的开始依赖于前一个步骤的完成。当最后一个线程到达屏障时，所有等待的线程将被释放并继续执行。</p>
<p>总的来说，这三种机制各有特点和适用场景，管程适用于管理对共享资源的同步访问，消息传递适用于进程或线程间的通信，而屏障适用于并行任务需要按步骤协同执行的情况。</p>
<h3 id="课后习题（男女共浴问题）"><a href="#课后习题（男女共浴问题）" class="headerlink" title="课后习题（男女共浴问题）"></a>课后习题（男女共浴问题）</h3><p>假设一个大学为了卖弄其政治上的正确性，准备把美国最高法院的信条“平等但隔离其本身就是不平等”既运用在种族上也运用在性别上，从而结束校园内长期使用的浴室按性别隔离的做法。但是，为了迁就传统习惯，学校颁布法令：当有一个女生在浴室里，那么其他女生可以进入，但是男生不行，反之亦然。在每个浴室的门上有一个滑动指示符号，表示当前处于以下三种可能状态之一：{空、有女生、有男生}<br>用你偏好的程序设计语言编写下面过程（可以随意采用所希望的计数器和同步技术）：</p>
<ul>
<li>woman_wants_to_enter</li>
<li>man_wants_to_enter</li>
<li>woman_leaves</li>
<li>man_leaves <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="type">int</span> woman_in_use = <span class="number">0</span>; <span class="comment">// 当前使用浴室的女性人数</span></span><br><span class="line"><span class="type">int</span> man_in_use = <span class="number">0</span>; <span class="comment">// 当前使用浴室的男性人数</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 互斥信号量，用于保护woman_in_use和man_in_use变量的访问</span></span><br><span class="line">semaphore woman_allowed = <span class="number">1</span>; <span class="comment">// 控制女性进入浴室的信号量</span></span><br><span class="line">semaphore man_allowed = <span class="number">1</span>; <span class="comment">// 控制男性进入浴室的信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">woman_wants_to_enter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">P</span>(woman_allowed);</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    <span class="keyword">if</span> (woman_in_use == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一个进入的女性负责锁定男性的进入</span></span><br><span class="line">        <span class="built_in">P</span>(man_allowed);</span><br><span class="line">    &#125;</span><br><span class="line">    woman_in_use++;</span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">    <span class="built_in">V</span>(woman_allowed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">woman_leaves</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    woman_in_use--;</span><br><span class="line">    <span class="keyword">if</span> (woman_in_use == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 最后一个离开的女性负责允许男性进入</span></span><br><span class="line">        <span class="built_in">V</span>(man_allowed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">man_wants_to_enter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">P</span>(man_allowed);</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    <span class="keyword">if</span> (man_in_use == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一个进入的男性负责锁定女性的进入</span></span><br><span class="line">        <span class="built_in">P</span>(woman_allowed);</span><br><span class="line">    &#125;</span><br><span class="line">    man_in_use++;</span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">    <span class="built_in">V</span>(man_allowed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">man_leaves</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    man_in_use--;</span><br><span class="line">    <span class="keyword">if</span> (man_in_use == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 最后一个离开的男性负责允许女性进入</span></span><br><span class="line">        <span class="built_in">V</span>(woman_allowed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>本次课回答的问题：</li>
</ul>
<p>Q: 如何在多处理器上协同多个线程完成任务？</p>
<h4 id="Take-away-message-1"><a href="#Take-away-message-1" class="headerlink" title="Take-away message"></a>Take-away message</h4><ul>
<li>实现同步的方法<ul>
<li>条件变量、信号量；生产者-消费者问题</li>
<li>Job queue 可以实现几乎任何并行算法<br>不要 “自作聪明” 设计算法，小心求证</li>
</ul>
</li>
</ul>
<h2 id="真实世界中的并发编程"><a href="#真实世界中的并发编程" class="headerlink" title="真实世界中的并发编程"></a>真实世界中的并发编程</h2><p>并发编程的基本工具：线程库、互斥和同步</p>
<ul>
<li>本次课回答的问题<br>Q: 什么样的任务是需要并行/并发的？它们应该如何实现？</li>
<li>本次课主要内容<ul>
<li>高性能计算中的并发编程</li>
<li>数据中心里的并发编程</li>
<li>我们身边的并发编程<h2 id="并发bug"><a href="#并发bug" class="headerlink" title="并发bug"></a>并发bug</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="死锁的类型"><a href="#死锁的类型" class="headerlink" title="死锁的类型"></a>死锁的类型</h4></li>
</ul>
</li>
<li>AA：一把锁，一个进程，也可以发生死锁。就在操作系统内核代码里。spinlock本该在获取锁的时候屏蔽中断、释放锁之后打开中断。而如果<strong>在获取锁的时候,中断被打开</strong>，中断程序在进程获得锁的时候打开了，中断程序想要获得这把锁；而进程又要等中断程序返回才能释放这把锁，这样就会导致死锁。</li>
<li>ABBA：更常见的十字路口型的死锁。两个进程，两把锁。两个进程分别获得一把锁，然后想要获得对方的锁，就会发生死锁。<h4 id="造成死锁的必要条件："><a href="#造成死锁的必要条件：" class="headerlink" title="造成死锁的必要条件："></a>造成死锁的必要条件：</h4></li>
<li>互斥：一个资源每次只能被一个进程使用</li>
<li>请求与保持：一个进程请求资阻塞时，不释放已获得的资源</li>
<li>不剥夺：进程已获得的资源不能强行剥夺</li>
<li>循环等待：若干进程之间形成头尾相接的循环等待资源关系</li>
</ul>
<h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><p>没有考过，但是可以考虑用图论的方法来检测死锁。如果有环，就说明发生了死锁。</p>
<h4 id="死锁的处理"><a href="#死锁的处理" class="headerlink" title="死锁的处理"></a>死锁的处理</h4><p>Windows和Linux都使用的是鸵鸟算法，即不处理死锁，让死锁发生，然后重启。但是在一些特殊的场景下，比如在飞机上，就不能使用这种方法，因此需要在设计的时候就避免死锁。</p>
<h4 id="死锁的恢复"><a href="#死锁的恢复" class="headerlink" title="死锁的恢复"></a>死锁的恢复</h4><p>考过简答题</p>
<ul>
<li>重启</li>
<li>杀死进程</li>
<li>回滚</li>
<li>什么都不做</li>
</ul>
<h4 id="避免死锁（死锁的预防）"><a href="#避免死锁（死锁的预防）" class="headerlink" title="避免死锁（死锁的预防）"></a>避免死锁（死锁的预防）</h4><h5 id="银行家算法-bank-algorithm"><a href="#银行家算法-bank-algorithm" class="headerlink" title="银行家算法 bank algorithm"></a>银行家算法 bank algorithm</h5><p>alloc、max、need、available。首先计算出need矩阵。</p>
<p>进程pn完成的时候，把alloc列中的资源还给了available，然后判断是否有进程可以完成，如果有就继续，没有就说明发生了死锁。</p>
<p>用文字方式描述。</p>
<h5 id="AA-Deadlock"><a href="#AA-Deadlock" class="headerlink" title="AA-Deadlock"></a>AA-Deadlock</h5><p>AA 型的死锁容易检测，及早报告，及早修复。</p>
<h6 id="spinlock-xv6-c-中的各种防御性编程"><a href="#spinlock-xv6-c-中的各种防御性编程" class="headerlink" title="spinlock-xv6.c 中的各种防御性编程:"></a><code>spinlock-xv6.c</code> 中的各种防御性编程:</h6><p><code>if (holding(lk)) panic();</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutual exclusion spin locks.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initlock</span><span class="params">(<span class="keyword">struct</span> spinlock *lk, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  lk-&gt;name = name;</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  push_off(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section&#x27;s memory</span></span><br><span class="line">  <span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the CPU to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that all the stores in the critical</span></span><br><span class="line">  <span class="comment">// section are visible to other CPUs before the lock is released,</span></span><br><span class="line">  <span class="comment">// and that loads in the critical section occur strictly before</span></span><br><span class="line">  <span class="comment">// the lock is released.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span></span><br><span class="line">  <span class="comment">// This code doesn&#x27;t use a C assignment, since the C standard</span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether this cpu is holding the lock.</span></span><br><span class="line"><span class="comment">// Interrupts must be off.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">holding</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  r = (lk-&gt;locked &amp;&amp; lk-&gt;cpu == mycpu());</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push_off/pop_off are like intr_off()/intr_on() except that they are matched:</span></span><br><span class="line"><span class="comment">// it takes two pop_off()s to undo two push_off()s.  Also, if interrupts</span></span><br><span class="line"><span class="comment">// are initially off, then push_off, pop_off leaves them off.</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> old = intr_get();</span><br><span class="line"></span><br><span class="line">  intr_off();</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff == <span class="number">0</span>)</span><br><span class="line">    mycpu()-&gt;intena = old;</span><br><span class="line">  mycpu()-&gt;noff += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="keyword">if</span>(intr_get())</span><br><span class="line">    panic(<span class="string">&quot;pop_off - interruptible&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;pop_off&quot;</span>);</span><br><span class="line">  c-&gt;noff -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff == <span class="number">0</span> &amp;&amp; c-&gt;intena)</span><br><span class="line">    intr_on();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="ABBA-Deadlock"><a href="#ABBA-Deadlock" class="headerlink" title="ABBA-Deadlock"></a>ABBA-Deadlock</h5><p>任意时刻系统中的锁都是有限的。<strong>严格按照固定的顺序获得所有锁</strong> (lock ordering; 消除 “循环等待”)。</p>
<h6 id="遇事不决可视化：lock-ordering-py"><a href="#遇事不决可视化：lock-ordering-py" class="headerlink" title="遇事不决可视化：lock-ordering.py"></a>遇事不决可视化：<code>lock-ordering.py</code></h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockOrdering</span>:</span><br><span class="line">    locks = [ <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span> ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tryacquire</span>(<span class="params">self, lk</span>):</span><br><span class="line">        self.locks[lk], seen = <span class="string">&#x27;🔒&#x27;</span>, self.locks[lk]</span><br><span class="line">        <span class="keyword">return</span> seen == <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">release</span>(<span class="params">self, lk</span>):</span><br><span class="line">        self.locks[lk] = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @thread</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">t1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.tryacquire(<span class="number">0</span>): <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.tryacquire(<span class="number">1</span>): <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.tryacquire(<span class="number">2</span>): <span class="keyword">pass</span></span><br><span class="line">            self.release(<span class="number">0</span>), self.release(<span class="number">1</span>), self.release(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @thread</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">t2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.tryacquire(<span class="number">1</span>): <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.tryacquire(<span class="number">2</span>): <span class="keyword">pass</span></span><br><span class="line">            self.release(<span class="number">1</span>), self.release(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @marker</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mark_negative</span>(<span class="params">self, state</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>证明 T1:A→B→C; T2:B→C 是安全的。“在任意时刻总是有获得 “最靠后” 锁的可以继续执行”。</p>
<h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>这些是破坏死锁四个必要条件的方法：</p>
<ul>
<li>Mutual Exclusion：Spool everything. 这意味着将所有资源都放入一个缓冲池（Spool）中，让每个进程在需要时从池中取用，用完后再放回。这样，资源就可以被多个进程共享，从而破坏了互斥条件。<ul>
<li>Some devices (such as printer) can be spooled<ul>
<li>only the printer daemon uses printer resource</li>
<li>printer daemon doesn’t request other resources </li>
<li>thus deadlock for printer eliminated</li>
</ul>
</li>
<li>Spooling space is limited, so deadlock is still possible with this decision<ul>
<li>Two processes each fill up half the available space and can’t continue, so there is deadlock on the disk</li>
</ul>
</li>
<li>avoid assigning resource if not absolutely necessary</li>
<li>as few processes as possible actually claim the resource</li>
<li>Not all devices can be spooled<blockquote>
<p>Spooling（Simultaneous Peripheral Operations On-Line）是一种数据管理技术，主要用于打印等I/O操作。其基本原理如下：</p>
<ol>
<li><p>当一个进程需要打印数据时，它不直接发送数据到打印机，而是将数据写入到一个磁盘文件中。这个文件通常被称为”spool”或”spool file”。</p>
</li>
<li><p>打印机守护进程（printer daemon）会监视这些spool文件。当它发现有新的spool文件时，它会从文件中读取数据，并发送到打印机。</p>
</li>
<li><p>打印机守护进程和打印机之间的通信通常是异步的。也就是说，打印机守护进程发送数据后，不需要等待打印机完成打印，就可以开始处理下一个spool文件。</p>
</li>
</ol>
<p>通过这种方式，多个进程可以同时”使用”打印机。实际上，它们是在向磁盘文件中写入数据，而打印机守护进程负责将这些数据发送到打印机。这就是Spooling的基本原理。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Hold and Wait：Request all resources at once. 这意味着进程在开始执行前，一次性请求所有需要的资源。这样，进程就不会在执行过程中持有一部分资源并等待其他资源，从而破坏了占有并等待条件。</p>
<ul>
<li>要求进程在启动前请求所有资源</li>
<li>进程永远不必等待它需要的东西</li>
<li>问题<ul>
<li>在运行开始时可能不知道所需的资源</li>
<li>还占用其他进程可能使用的资源</li>
</ul>
</li>
<li>变化：<ul>
<li>请求资源的进程必须放弃当前拥有的所有资源，然后请求所有立即需要的资源</li>
</ul>
</li>
</ul>
</li>
<li><p>No Preemption：Take resources away. 这意味着操作系统可以强行从一个进程中取走其占有的资源，然后分配给其他进程。这样，就破坏了非剥夺条件。</p>
<ul>
<li>Virtualization of Resources <ul>
<li>Spooling printer output to the disk </li>
<li>Allow only the printer daemon access to the real printer. </li>
</ul>
</li>
<li>Problem<ul>
<li>Not all resources can be virtualized</li>
</ul>
</li>
</ul>
</li>
<li><p>Circular Wait：Order resources numerically. 这意味着将所有资源进行编号，每个进程都按照编号顺序请求资源。这样，就不会形成循环等待，从而破坏了循环等待条件。</p>
<ul>
<li>Approach 1: Request one resource at a time. <ul>
<li>Release the current resource when request the next one </li>
</ul>
</li>
<li>Approach 2: Global ordering of resources <ul>
<li>Requests have to made in increasing order </li>
</ul>
</li>
<li>Approach 3: Variation of Approach 2 <ul>
<li>No process request a resource lower than what it is already holding. </li>
</ul>
</li>
<li>Problem:<ul>
<li>Finding a suitable numbering to satisfy everybody could be difficult/impossible </li>
<li>Increases burden on programmers to know the numbering <h4 id="Other-Issues"><a href="#Other-Issues" class="headerlink" title="Other Issues"></a>Other Issues</h4>❖ Two-Phase Locking<br>❖ Communication Deadlocks<br>❖ Livelock<br>❖ Starvation<h5 id="两阶段锁定"><a href="#两阶段锁定" class="headerlink" title="两阶段锁定"></a>两阶段锁定</h5></li>
</ul>
</li>
</ul>
</li>
<li>两阶段锁定协议（Two-Phase Locking Protocol）是一种并发控制方法，用于确保事务的隔离性和一致性。</li>
<li>两阶段锁定协议分为两个阶段：增长阶段（Growing Phase）和缩减阶段（Shrinking Phase）。</li>
<li>在增长阶段，事务可以获取锁，但不能释放锁；在缩减阶段，事务可以释放锁，但不能获取锁。</li>
<li>两阶段锁定协议可以防止死锁，但不能防止饥饿。</li>
</ul>
<h5 id="通信死锁"><a href="#通信死锁" class="headerlink" title="通信死锁"></a>通信死锁</h5><ul>
<li>通信死锁是指在分布式系统中，由于通信通道的限制或者通信协议的问题，导致进程之间无法正常通信，从而陷入死锁状态。</li>
<li>通信死锁的原因包括：通信通道的限制、通信协议的问题、通信消息的丢失、通信消息的延迟等。</li>
<li>避免通信死锁的方法包括：超时重传等。</li>
</ul>
<h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><ul>
<li>活锁（Livelock）是指系统中的进程或线程由于某种原因一直在忙碌地执行，但无法取得进展，从而无法完成任务。</li>
<li>活锁通常是由于进程之间的竞争条件、资源争用、消息传递等问题导致的。</li>
</ul>
<h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><ul>
<li>饥饿（Starvation）是指系统中的进程或线程由于某种原因无法获得所需的资源，从而无法继续执行任务。</li>
<li>饥饿通常是由于资源分配不公平、资源争用、优先级反转等问题导致的。</li>
</ul>
<h3 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h3><p>不使用锁的时候，也可能出现数据竞争的问题。而且无锁算法很难写对，结论是不如直接使用互斥锁来避免数据竞争。</p>
<p>如果只使用一把锁，绝对没有问题（串行）。</p>
<p>易出现的bug：</p>
<ul>
<li>上错了锁。</li>
<li><p>忘记上锁。</p>
<h3 id="其他并发bug"><a href="#其他并发bug" class="headerlink" title="其他并发bug"></a>其他并发bug</h3><p>回顾我们实现并发控制的工具：</p>
</li>
<li><p>互斥锁 (lock/unlock) - 原子性</p>
</li>
<li><p>条件变量 (wait/signal) - 同步</p>
</li>
<li><p>忘记上锁——原子性违反 (Atomicity Violation, AV)</p>
</li>
<li><p>忘记同步——顺序违反 (Order Violation, OV)</p>
</li>
</ul>
<blockquote>
<p>Empirical study: 在 105 个并发 bug 中 (non-deadlock/deadlock)</p>
<p>MySQL (14/9), Apache (13/4), Mozilla (41/16), OpenOffice (6/2)<br>97% 的非死锁并发 bug 都是 AV 或 OV。</p>
</blockquote>
<h4 id="原子性违反-AV"><a href="#原子性违反-AV" class="headerlink" title="原子性违反 (AV)"></a>原子性违反 (AV)</h4><p>“ABA” 问题：</p>
<p>一个线程读取了一个值，然后另一个线程修改了这个值。第一个线程再次读取这个值，发现没有变化，但实际上这个值已经被修改了。</p>
<p>但是有时候上锁也不解决问题：</p>
<p>“TOCTTOU” - time of check to time of use.</p>
<blockquote>
<p>TOCTTOU vulnerabilities in UNIX-style file systems: An anatomical study (FAST’05)</p>
</blockquote>
<h4 id="顺序违反-OV"><a href="#顺序违反-OV" class="headerlink" title="顺序违反 (OV)"></a>顺序违反 (OV)</h4><p>“BA”：</p>
<p>没按预想的顺序来</p>
<h3 id="Lockdep-运行时的死锁检查"><a href="#Lockdep-运行时的死锁检查" class="headerlink" title="Lockdep: 运行时的死锁检查"></a>Lockdep: 运行时的死锁检查</h3><p>Lockdep 规约 (Specification)</p>
<p>为每一个锁确定唯一的 “allocation site”</p>
<p>lock-site.c：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> locked;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *site;</span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRINGIFY(s) #s</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOSTRING(s)  STRINGIFY(s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_INIT() \</span></span><br><span class="line"><span class="meta">  ( (lock_t) &#123; .locked = 0, .site = __FILE__ <span class="string">&quot;:&quot;</span> TOSTRING(__LINE__), &#125; )</span></span><br><span class="line"></span><br><span class="line"><span class="type">lock_t</span> lk1 = LOCK_INIT();</span><br><span class="line"><span class="type">lock_t</span> lk2 = LOCK_INIT();</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lk)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;LOCK   %s\n&quot;</span>, lk-&gt;site);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lk)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;UNLOCK %s\n&quot;</span>, lk-&gt;site);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">some_object</span> &#123;</span></span><br><span class="line">  <span class="type">lock_t</span> lock;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">object_init</span><span class="params">(<span class="keyword">struct</span> some_object *obj)</span> &#123;</span><br><span class="line">  obj-&gt;lock = LOCK_INIT();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  lock(&amp;lk1);</span><br><span class="line">  lock(&amp;lk2);</span><br><span class="line">  unlock(&amp;lk1);</span><br><span class="line">  unlock(&amp;lk2);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">some_object</span> *<span class="title">obj</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> some_object));</span><br><span class="line">  assert(obj);</span><br><span class="line">  object_init(obj);</span><br><span class="line">  lock(&amp;obj-&gt;lock);</span><br><span class="line"></span><br><span class="line">  lock(&amp;lk2);</span><br><span class="line">  lock(&amp;lk1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>assert: 同一个 <code>allocation site</code> 的锁存在全局唯一的上锁顺序<br>检查方法：printf </p>
<p>记录所有观察到的上锁顺序，例如[x,y,z]⇒x→y,x→z,y→z。</p>
<p>相当于动态维护一个图，检查是否存在环或者其他不符合规定的顺序。</p>
<h4 id="Lockdep-的实现"><a href="#Lockdep-的实现" class="headerlink" title="Lockdep 的实现"></a>Lockdep 的实现</h4><p>Since Linux Kernel 2.6.17, also in OpenHarmony!</p>
<p>例子：concurrent use after free</p>
<h4 id="ThreadSanitizer-运行时的数据竞争检查"><a href="#ThreadSanitizer-运行时的数据竞争检查" class="headerlink" title="ThreadSanitizer: 运行时的数据竞争检查"></a>ThreadSanitizer: 运行时的数据竞争检查</h4><p>为所有事件建立 <code>happens-before</code> 关系图</p>
<p>Program-order + release-acquire</p>
<p>对于发生在不同线程且至少有一个是写的 x,y 检查。</p>
<p>Time, clocks, and the ordering of events in a distributed system</p>
<h4 id="更多的检查：动态程序分析"><a href="#更多的检查：动态程序分析" class="headerlink" title="更多的检查：动态程序分析"></a>更多的检查：动态程序分析</h4><p>上面这两个检查死锁和检查数据竞争的工具都属于动态程序分析的范畴。</p>
<h5 id="在事件发生时记录"><a href="#在事件发生时记录" class="headerlink" title="在事件发生时记录"></a>在事件发生时记录</h5><ul>
<li>Lockdep: lock/unlock；</li>
<li>ThreadSanitizer: 内存访问 + lock/unlock<h5 id="解析记录检查问题"><a href="#解析记录检查问题" class="headerlink" title="解析记录检查问题"></a>解析记录检查问题</h5></li>
<li>Lockdep: </li>
<li>ThreadSanitizer: <h5 id="付出的代价和权衡："><a href="#付出的代价和权衡：" class="headerlink" title="付出的代价和权衡："></a>付出的代价和权衡：</h5></li>
<li>程序执行变慢</li>
<li><p>但更容易找到 bug （因此在测试环境中常用）</p>
<h4 id="动态分析工具：Sanitizers"><a href="#动态分析工具：Sanitizers" class="headerlink" title="动态分析工具：Sanitizers"></a>动态分析工具：Sanitizers</h4><p>没用过 lint/sanitizers？</p>
<blockquote>
<ul>
<li><code>-fsanitize=address</code>：检查内存访问错误</li>
<li><code>-fsanitize=thread</code>：检查数据竞争</li>
<li><code>-fsanitize=undefined</code>：检查未定义行为</li>
<li><code>-fsanitize=memory</code>：检查未初始化读取</li>
<li><code>-fsanitize=leak</code>：检查内存泄漏</li>
<li><code>-fsanitize=pointer-compare</code>：检查指针比较</li>
<li><code>-fsanitize=pointer-subtract</code>：检查指针减法</li>
<li><code>-fsanitize=pointer-overflow</code>：检查指针溢出</li>
<li><code>-fsanitize=shift</code>：检查位移操作</li>
<li><code>-fsanitize=signed-integer-overflow</code>：检查有符号整数溢出</li>
<li><code>-fsanitize=unsigned-integer-overflow</code>：检查无符号整数溢出</li>
<li><code>-fsanitize=bounds</code>：检查数组越界</li>
<li><code>-fsanitize=bounds-strict</code>：检查数组越界（严格模式）</li>
<li>…</li>
</ul>
</blockquote>
</li>
<li><p><code>AddressSanitizer</code> (asan); (paper): 非法内存访问</p>
<ul>
<li>Buffer (heap/stack/global) overflow, <code>use-after-free(非常危险)</code>, use-after-return, double-free, …</li>
<li>Demo: uaf.c; kasan</li>
</ul>
</li>
<li><code>ThreadSanitizer</code> (tsan): 数据竞争<ul>
<li>Demo: fish.c, sum.c, peterson-barrier.c; ktsan</li>
</ul>
</li>
<li><code>MemorySanitizer</code> (msan): 未初始化的读取</li>
<li><code>UBSanitizer</code> (ubsan): undefined behavior<ul>
<li>Misaligned pointer, signed integer overflow, …</li>
<li>Kernel 会带着 <code>-fwrapv</code> 编译</li>
</ul>
</li>
</ul>
<h4 id="Buffer-Overrun-检查"><a href="#Buffer-Overrun-检查" class="headerlink" title="Buffer Overrun 检查"></a>Buffer Overrun 检查</h4><p>计算机系统中的 canary</p>
<p>“牺牲” 一些内存单元，来预警 memory error 的发生<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAGIC 0x55555555</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOTTOM (STK_SZ / sizeof(u32) - 1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span> <span class="type">char</span> data[STK_SZ]; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">canary_init</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">stack</span> *s)</span> &#123;</span><br><span class="line">  u32 *ptr = (u32 *)s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CANARY_SZ; i++)</span><br><span class="line">    ptr[BOTTOM - i] = ptr[i] = MAGIC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">canary_check</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">stack</span> *s)</span> &#123;</span><br><span class="line">  u32 *ptr = (u32 *)s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CANARY_SZ; i++) &#123;</span><br><span class="line">    panic_on(ptr[BOTTOM - i] != MAGIC, <span class="string">&quot;underflow&quot;</span>);</span><br><span class="line">    panic_on(ptr[i] != MAGIC, <span class="string">&quot;overflow&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不要把空间全部当成栈，在栈区前后设置canary，通过每隔一段时间检查canary的值，来检测栈是否溢出。</p>
<p>msvc 中 debug mode 的 guard/fence/canary：</p>
<p>未初始化栈: 0xcccccccc<br>未初始化堆: 0xcdcdcdcd<br>对象头尾: 0xfdfdfdfd<br>已回收内存: 0xdddddddd</p>
<p><code>(b&#39;\xcc&#39; * 80).decode(&#39;gb2312&#39;)</code>输出为<code>烫</code></p>
<h4 id="防御性编程：低配版-Lockdep"><a href="#防御性编程：低配版-Lockdep" class="headerlink" title="防御性编程：低配版 Lockdep"></a>防御性编程：低配版 Lockdep</h4><p>不必大费周章记录什么上锁顺序</p>
<p>统计当前的 spin count<br>如果超过某个明显不正常的数值 (1,000,000,000) 就报告<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> spin_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (xchg(&amp;locked, <span class="number">1</span>)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (spin_cnt++ &gt; SPIN_LIMIT) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Too many spin @ %s:%d\n&quot;</span>, __FILE__, __LINE__);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="防御性编程：低配版-Sanitizer-L1"><a href="#防御性编程：低配版-Sanitizer-L1" class="headerlink" title="防御性编程：低配版 Sanitizer (L1)"></a>防御性编程：低配版 Sanitizer (L1)</h4><p>内存分配要求：已分配内存 </p>
<p>thread-local allocation + 并发的 free 还蛮容易弄错的</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>本次课回答的问题：</p>
<p>Q: 如何拯救人类不擅长的并发编程？</p>
<h4 id="Take-away-message-2"><a href="#Take-away-message-2" class="headerlink" title="Take-away message"></a>Take-away message</h4><ul>
<li>常见的并发 bug<ul>
<li>死锁、数据竞争、原子性/顺序违反</li>
</ul>
</li>
<li>不要盲目相信自己：检查、检查、检查<ul>
<li>防御性编程：检查</li>
<li>动态分析：打印 + 检查</li>
</ul>
</li>
</ul>
<h2 id="操作系统的状态机模型-操作系统的加载-thread-os-代码讲解"><a href="#操作系统的状态机模型-操作系统的加载-thread-os-代码讲解" class="headerlink" title="操作系统的状态机模型 (操作系统的加载; thread-os 代码讲解)"></a>操作系统的状态机模型 (操作系统的加载; thread-os 代码讲解)</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://val213.github.io">Val</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://val213.github.io/2024/04/23/%E3%80%90%E5%A4%A7%E4%BA%8C%E4%B8%8B%E3%80%91%E5%8D%97%E5%A4%A7jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">https://val213.github.io/2024/04/23/%E3%80%90%E5%A4%A7%E4%BA%8C%E4%B8%8B%E3%80%91%E5%8D%97%E5%A4%A7jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/23/%E3%80%90%E5%A4%A7%E4%BA%8C%E4%B8%8B%E3%80%91%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">编译原理</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/23/%E3%80%90%E5%AE%9E%E4%B9%A0%E3%80%91leetcode%E5%88%B7%E9%A2%98%E8%AE%B0/" title="LeetCode刷题记"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">LeetCode刷题记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/04/23/DragonOS/%E3%80%90DragonOS%E3%80%91%E6%8B%9B%E6%96%B0%E5%B0%8F%E4%BB%BB%E5%8A%A1/" title="DragonOS招新面试小任务"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-23</div><div class="title">DragonOS招新面试小任务</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://github.com/val213/image/blob/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230630230143.jpg?raw=true" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Val</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">130</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">106</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/val213"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/val213" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:val213666@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">记录跬步 e/acc</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%E8%AF%BE"><span class="toc-number">1.</span> <span class="toc-text">概述课</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="toc-number">1.1.</span> <span class="toc-text">命令行工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tmux"><span class="toc-number">1.1.1.</span> <span class="toc-text">tmux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.1.2.</span> <span class="toc-text">其他</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gdb%EF%BC%88GNU-Debugger%EF%BC%89%EF%BC%8C%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">1.1.3.</span> <span class="toc-text">gdb（GNU Debugger），调试工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E5%92%8Clab%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6"><span class="toc-number">1.2.</span> <span class="toc-text">作业和lab代码框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#M1%EF%BC%9A%E6%89%93%E5%8D%B0%E8%BF%9B%E7%A8%8B%E6%A0%91"><span class="toc-number">1.2.1.</span> <span class="toc-text">M1：打印进程树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E6%83%85%E6%8F%90%E8%A6%81"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">前情提要</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E8%A7%A3%EF%BC%9A"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">问题分解：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8C%E7%9A%84%E9%80%89%E9%A1%B9"><span class="toc-number">1.2.1.2.1.</span> <span class="toc-text">解析命令行命令以及不同的选项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.1.2.2.</span> <span class="toc-text">获取进程信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.2.3.</span> <span class="toc-text">构建树形结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E8%A6%81%E6%B1%82%E6%89%93%E5%8D%B0"><span class="toc-number">1.2.1.2.4.</span> <span class="toc-text">按照要求打印</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8makefile%E7%BC%96%E8%AF%9132%E4%BD%8D%E5%92%8C64%E4%BD%8D%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.1.2.5.</span> <span class="toc-text">可移植性——使用makefile编译32位和64位的可执行文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">其他问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#L0%EF%BC%9A%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C%E5%9C%A8%E7%A1%AC%E4%BB%B6%E4%B8%8A%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F-amgame"><span class="toc-number">1.3.</span> <span class="toc-text">L0：直接运行在硬件上的小游戏 (amgame)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractMachine-%E6%8A%BD%E8%B1%A1%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="toc-number">1.3.1.</span> <span class="toc-text">AbstractMachine: 抽象计算机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA-Bare-Metal-%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">为 Bare-Metal 编程：编译、链接与加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">前置知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#qemu"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">qemu</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E5%91%A8%E9%98%85%E8%AF%BB%E6%9D%90%E6%96%99"><span class="toc-number">1.4.</span> <span class="toc-text">第一周阅读材料</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">【并发】多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83-%E7%BA%BF%E7%A8%8B%E5%BA%93%EF%BC%9B%E7%8E%B0%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%E5%AE%BD%E6%9D%BE%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">多处理器编程：从入门到放弃 (线程库；现代处理器和宽松内存模型)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E8%A1%A5%E5%85%85"><span class="toc-number">2.1.1.</span> <span class="toc-text">语言特性补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%A7%E8%B4%A8%E9%AA%8C%E8%AF%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">多线程性质验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%9C%89%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%A0%86%E6%A0%88"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">线程之间共享内存，线程有独立的堆栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.1.3.</span> <span class="toc-text">多线程程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E4%B8%A7%E5%A4%B1"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">原子性的丧失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%9A%84%E4%B8%A7%E5%A4%B1%EF%BC%88%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">顺序的丧失（编译优化的问题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E4%B8%A7%E5%A4%B1"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">可见性的丧失</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%BD%E6%9D%BE%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88relaxed-weak-memory-model%EF%BC%89"><span class="toc-number">2.1.3.3.1.</span> <span class="toc-text">宽松内存模型（relaxed&#x2F;weak memory model）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C-Peterson%E7%AE%97%E6%B3%95%E3%80%81%E6%A8%A1%E5%9E%8B%E6%A3%80%E9%AA%8C%E4%B8%8E%E8%BD%AF%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="toc-number">2.2.</span> <span class="toc-text">理解并发程序执行 (Peterson算法、模型检验与软件自动化工具)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD"><span class="toc-number">2.2.1.</span> <span class="toc-text">屏蔽中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">锁变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E8%BD%AE%E6%8D%A2"><span class="toc-number">2.2.3.</span> <span class="toc-text">严格轮换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#peterson%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.4.</span> <span class="toc-text">peterson算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TSL"><span class="toc-number">2.2.5.</span> <span class="toc-text">TSL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tips"><span class="toc-number">2.2.6.</span> <span class="toc-text">tips</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">优先级反转</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.2.7.</span> <span class="toc-text">实现并发程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#model-checker"><span class="toc-number">2.2.8.</span> <span class="toc-text">model checker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#M2-%E5%8D%8F%E7%A8%8B%E5%BA%93libco"><span class="toc-number">2.3.</span> <span class="toc-text">M2: 协程库libco</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95%E7%9A%84tips"><span class="toc-number">2.3.1.</span> <span class="toc-text">本地调试的tips</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%BA%93%EF%BC%88%E6%88%96%E8%80%85%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%EF%BC%89shared-object-so-%EF%BC%88%E7%9B%B8%E5%BD%93%E4%BA%8Ewindows%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93-dll%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">共享库（或者共享对象）shared object(.so),（相当于windows中的动态链接库.dll）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3"><span class="toc-number">2.3.3.</span> <span class="toc-text">编译相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-1"><span class="toc-number">2.3.4.</span> <span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-register-and-non-volatile-registers"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">volatile register and non-volatile registers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#System-V-ABI"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">System V ABI</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">2.3.5.</span> <span class="toc-text">问题分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#setjmp-longjmp-%E5%AE%9E%E7%8E%B0%E5%AF%84%E5%AD%98%E5%99%A8%E7%8E%B0%E5%9C%BA%E7%9A%84%E4%BF%9D%E5%AD%98%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">setjmp&#x2F;longjmp 实现寄存器现场的保存和恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%AF%84%E5%AD%98%E5%99%A8%E7%8E%B0%E5%9C%BA%E5%88%87%E6%8D%A2"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">实现寄存器现场切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86co-start-%E6%97%B6%E5%88%86%E9%85%8D%E7%9A%84-struct-co-%E7%BB%93%E6%9E%84%E4%BD%93%E8%B5%84%E6%BA%90"><span class="toc-number">2.3.5.3.</span> <span class="toc-text">管理co_start 时分配的 struct co 结构体资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">2.3.5.4.</span> <span class="toc-text">调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#segmentation-fault"><span class="toc-number">2.3.5.5.</span> <span class="toc-text">segmentation fault</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#valgrind"><span class="toc-number">2.3.5.6.</span> <span class="toc-text">valgrind</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%9A%E4%BA%92%E6%96%A5-%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C-futex"><span class="toc-number">2.4.</span> <span class="toc-text">并发控制：互斥 (自旋锁、互斥锁和 futex)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.1.</span> <span class="toc-text">前置概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%8C%87%E4%BB%A4%E5%92%8C%E8%87%AA%E6%97%8B%E9%94%81-Spin-Lock"><span class="toc-number">2.4.2.</span> <span class="toc-text">原子指令和自旋锁(Spin Lock)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E4%BE%8B%E5%AD%90"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">现实例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8-xchg-%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">用 xchg 实现互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.4.2.2.1.</span> <span class="toc-text">实现互斥的协议</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">实现互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.2.4.</span> <span class="toc-text">原子指令的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Load-Reserved-Store-Condtitional-LR-SC"><span class="toc-number">2.4.2.5.</span> <span class="toc-text">Load-Reserved&#x2F;Store-Condtitional(LR&#x2F;SC)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Campare-and-Swap-CAS-%E7%9A%84LR-SC%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.2.5.1.</span> <span class="toc-text">Campare and Swap (CAS)的LR&#x2F;SC实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cmpxchg%EF%BC%882023%EF%BC%89"><span class="toc-number">2.4.2.6.</span> <span class="toc-text">cmpxchg（2023）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81-Mutex-Lock"><span class="toc-number">2.4.3.</span> <span class="toc-text">系统调用和互斥锁 (Mutex Lock)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">自旋锁的缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">自旋锁的使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B-%E9%95%BF%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E4%BA%92%E6%96%A5"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">实现线程 + 长临界区的互斥</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#futex%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%882022%EF%BC%89"><span class="toc-number">2.4.4.</span> <span class="toc-text">futex系统调用（2022）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%BA%92%E6%96%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E6%9E%90%EF%BC%882022%EF%BC%89"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">关于互斥的一些分析（2022）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%882022%EF%BC%89"><span class="toc-number">2.4.5.</span> <span class="toc-text">总结（2022）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Take-away-message"><span class="toc-number">2.4.5.1.</span> <span class="toc-text">Take-away message</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%9A%E5%90%8C%E6%AD%A5%EF%BC%88%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%8C%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%8C%E5%93%B2%E2%99%82%E5%AD%A6%E5%AE%B6%E5%90%83%E9%A5%AD%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">并发控制：同步（信号量和条件变量，生产者和消费者，哲♂学家吃饭问题）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.1.</span> <span class="toc-text">生产者和消费者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">2.5.2.</span> <span class="toc-text">信号量和条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84API"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">条件变量的API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">条件变量实现生产者消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.5.2.3.</span> <span class="toc-text">信号量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E8%AF%BE%E6%9C%AC%E4%B8%8A%E4%B9%9F%E6%9C%89%E7%9A%84%EF%BC%89%E5%93%B2%E2%99%82%E5%AD%A6%E5%AE%B6%E5%90%83%E9%A5%AD%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.3.</span> <span class="toc-text">（课本上也有的）哲♂学家吃饭问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#leader-follower%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">leader&#x2F;follower模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E8%AF%BE%E6%9C%AC%E4%B8%8A%E7%9A%84%EF%BC%89%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98-Readers-and-Writers"><span class="toc-number">2.5.4.</span> <span class="toc-text">（课本上的）读者写者问题(Readers and Writers)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8Bmonitor%EF%BC%8C%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%EF%BC%8C%E5%B1%8F%E9%9A%9C%EF%BC%88%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">2.5.5.</span> <span class="toc-text">管程monitor，消息传递，屏障（简单了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%EF%BC%88Monitor%EF%BC%89"><span class="toc-number">2.5.5.1.</span> <span class="toc-text">管程（Monitor）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%EF%BC%88Message-Passing%EF%BC%89"><span class="toc-number">2.5.5.2.</span> <span class="toc-text">消息传递（Message Passing）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%8F%E9%9A%9C%EF%BC%88Barrier%EF%BC%89"><span class="toc-number">2.5.5.3.</span> <span class="toc-text">屏障（Barrier）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%EF%BC%88%E7%94%B7%E5%A5%B3%E5%85%B1%E6%B5%B4%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">2.5.6.</span> <span class="toc-text">课后习题（男女共浴问题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.5.7.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Take-away-message-1"><span class="toc-number">2.5.7.1.</span> <span class="toc-text">Take-away message</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">2.6.</span> <span class="toc-text">真实世界中的并发编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91bug"><span class="toc-number">2.7.</span> <span class="toc-text">并发bug</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">2.7.1.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">死锁的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%A0%E6%88%90%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">造成死锁的必要条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">2.7.1.3.</span> <span class="toc-text">死锁的检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">2.7.1.4.</span> <span class="toc-text">死锁的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="toc-number">2.7.1.5.</span> <span class="toc-text">死锁的恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%88%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2%EF%BC%89"><span class="toc-number">2.7.1.6.</span> <span class="toc-text">避免死锁（死锁的预防）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95-bank-algorithm"><span class="toc-number">2.7.1.6.1.</span> <span class="toc-text">银行家算法 bank algorithm</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AA-Deadlock"><span class="toc-number">2.7.1.6.2.</span> <span class="toc-text">AA-Deadlock</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#spinlock-xv6-c-%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B"><span class="toc-number">2.7.1.6.2.1.</span> <span class="toc-text">spinlock-xv6.c 中的各种防御性编程:</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ABBA-Deadlock"><span class="toc-number">2.7.1.6.3.</span> <span class="toc-text">ABBA-Deadlock</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%81%87%E4%BA%8B%E4%B8%8D%E5%86%B3%E5%8F%AF%E8%A7%86%E5%8C%96%EF%BC%9Alock-ordering-py"><span class="toc-number">2.7.1.6.3.1.</span> <span class="toc-text">遇事不决可视化：lock-ordering.py</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-number">2.7.1.7.</span> <span class="toc-text">死锁预防</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Other-Issues"><span class="toc-number">2.7.1.8.</span> <span class="toc-text">Other Issues</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%AE%9A"><span class="toc-number">2.7.1.8.1.</span> <span class="toc-text">两阶段锁定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E6%AD%BB%E9%94%81"><span class="toc-number">2.7.1.8.2.</span> <span class="toc-text">通信死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B4%BB%E9%94%81"><span class="toc-number">2.7.1.8.3.</span> <span class="toc-text">活锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF"><span class="toc-number">2.7.1.8.4.</span> <span class="toc-text">饥饿</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89"><span class="toc-number">2.7.2.</span> <span class="toc-text">数据竞争</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B9%B6%E5%8F%91bug"><span class="toc-number">2.7.3.</span> <span class="toc-text">其他并发bug</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E8%BF%9D%E5%8F%8D-AV"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">原子性违反 (AV)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%BF%9D%E5%8F%8D-OV"><span class="toc-number">2.7.3.2.</span> <span class="toc-text">顺序违反 (OV)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lockdep-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%AD%BB%E9%94%81%E6%A3%80%E6%9F%A5"><span class="toc-number">2.7.4.</span> <span class="toc-text">Lockdep: 运行时的死锁检查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lockdep-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.7.4.1.</span> <span class="toc-text">Lockdep 的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadSanitizer-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E6%A3%80%E6%9F%A5"><span class="toc-number">2.7.4.2.</span> <span class="toc-text">ThreadSanitizer: 运行时的数据竞争检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E7%9A%84%E6%A3%80%E6%9F%A5%EF%BC%9A%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90"><span class="toc-number">2.7.4.3.</span> <span class="toc-text">更多的检查：动态程序分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E6%97%B6%E8%AE%B0%E5%BD%95"><span class="toc-number">2.7.4.3.1.</span> <span class="toc-text">在事件发生时记录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E8%AE%B0%E5%BD%95%E6%A3%80%E6%9F%A5%E9%97%AE%E9%A2%98"><span class="toc-number">2.7.4.3.2.</span> <span class="toc-text">解析记录检查问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7%E5%92%8C%E6%9D%83%E8%A1%A1%EF%BC%9A"><span class="toc-number">2.7.4.3.3.</span> <span class="toc-text">付出的代价和权衡：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%9ASanitizers"><span class="toc-number">2.7.4.4.</span> <span class="toc-text">动态分析工具：Sanitizers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-Overrun-%E6%A3%80%E6%9F%A5"><span class="toc-number">2.7.4.5.</span> <span class="toc-text">Buffer Overrun 检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BD%8E%E9%85%8D%E7%89%88-Lockdep"><span class="toc-number">2.7.4.6.</span> <span class="toc-text">防御性编程：低配版 Lockdep</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BD%8E%E9%85%8D%E7%89%88-Sanitizer-L1"><span class="toc-number">2.7.4.7.</span> <span class="toc-text">防御性编程：低配版 Sanitizer (L1)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.7.5.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Take-away-message-2"><span class="toc-number">2.7.5.1.</span> <span class="toc-text">Take-away message</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%A0%E8%BD%BD-thread-os-%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3"><span class="toc-number">2.8.</span> <span class="toc-text">操作系统的状态机模型 (操作系统的加载; thread-os 代码讲解)</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/28/%E3%80%90Rust%E3%80%91tokio/" title="【Rust】tokio"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Rust】tokio"/></a><div class="content"><a class="title" href="/2024/10/28/%E3%80%90Rust%E3%80%91tokio/" title="【Rust】tokio">【Rust】tokio</a><time datetime="2024-10-28T11:29:42.554Z" title="Created 2024-10-28 19:29:42">2024-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/27/DragonOS/%E3%80%90DragonOS%E3%80%91DragonReach%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96/" title="【DragonOS】DragonReach主线程优化"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【DragonOS】DragonReach主线程优化"/></a><div class="content"><a class="title" href="/2024/10/27/DragonOS/%E3%80%90DragonOS%E3%80%91DragonReach%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96/" title="【DragonOS】DragonReach主线程优化">【DragonOS】DragonReach主线程优化</a><time datetime="2024-10-27T03:26:53.791Z" title="Created 2024-10-27 11:26:53">2024-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/26/DragonOS/%E3%80%90DragonOS%E3%80%91ssh%E6%94%AF%E6%8C%81/" title="【DragonOS】ssh支持"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【DragonOS】ssh支持"/></a><div class="content"><a class="title" href="/2024/10/26/DragonOS/%E3%80%90DragonOS%E3%80%91ssh%E6%94%AF%E6%8C%81/" title="【DragonOS】ssh支持">【DragonOS】ssh支持</a><time datetime="2024-10-25T16:16:07.125Z" title="Created 2024-10-26 00:16:07">2024-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/18/DB/DB%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/" title="数据库实践经验"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库实践经验"/></a><div class="content"><a class="title" href="/2024/10/18/DB/DB%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/" title="数据库实践经验">数据库实践经验</a><time datetime="2024-10-18T13:35:46.714Z" title="Created 2024-10-18 21:35:46">2024-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/casdoor/" title="casdoor 使用实践"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="casdoor 使用实践"/></a><div class="content"><a class="title" href="/2024/10/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/casdoor/" title="casdoor 使用实践">casdoor 使用实践</a><time datetime="2024-10-18T07:54:57.137Z" title="Created 2024-10-18 15:54:57">2024-10-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Val</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">纯粹的心，感受意义不明</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>