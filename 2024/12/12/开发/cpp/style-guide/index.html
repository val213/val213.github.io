<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Google C++ Style Guide | Val-Blog</title><meta name="author" content="Val,10425999@qq.com, val213666@gmail.com"><meta name="copyright" content="Val"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Google C++ Style Guidetable of contents    Section Subsections     C++ Version    Header Files Self-contained Headers, The #define Guard, Include What You Use, Forward Declarations, Inline Functions,">
<meta property="og:type" content="article">
<meta property="og:title" content="Google C++ Style Guide">
<meta property="og:url" content="https://val213.github.io/2024/12/12/%E5%BC%80%E5%8F%91/cpp/style-guide/index.html">
<meta property="og:site_name" content="Val-Blog">
<meta property="og:description" content="Google C++ Style Guidetable of contents    Section Subsections     C++ Version    Header Files Self-contained Headers, The #define Guard, Include What You Use, Forward Declarations, Inline Functions,">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2024-12-12T07:28:41.150Z">
<meta property="article:modified_time" content="2024-12-19T13:07:44.314Z">
<meta property="article:author" content="Val">
<meta property="article:tag" content="language">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://val213.github.io/2024/12/12/%E5%BC%80%E5%8F%91/cpp/style-guide/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: Val","link":"Link: ","source":"Source: Val-Blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Google C++ Style Guide',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-19 21:07:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://github.com/val213/image/blob/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230630230143.jpg?raw=true" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">141</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">110</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Val-Blog"><span class="site-name">Val-Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Google C++ Style Guide</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-12-12T07:28:41.150Z" title="Created 2024-12-12 15:28:41">2024-12-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-12-19T13:07:44.314Z" title="Updated 2024-12-19 21:07:44">2024-12-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Google C++ Style Guide"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Google-C-Style-Guide"><a href="#Google-C-Style-Guide" class="headerlink" title="Google C++ Style Guide"></a>Google C++ Style Guide</h1><h2 id="table-of-contents"><a href="#table-of-contents" class="headerlink" title="table of contents"></a>table of contents</h2><div class="table-container">
<table>
<thead>
<tr>
<th>Section</th>
<th>Subsections</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>C++ Version</strong></td>
<td></td>
</tr>
<tr>
<td><strong>Header Files</strong></td>
<td><strong>Self-contained Headers</strong>, <strong>The #define Guard</strong>, <strong>Include What You Use</strong>, <strong>Forward Declarations</strong>, <strong>Inline Functions</strong>, <strong>Names and Order of Includes</strong></td>
</tr>
<tr>
<td>Scoping</td>
<td><strong>Namespaces</strong>, <strong>Internal Linkage</strong>, <strong>Nonmember, Static Member, and Global Functions</strong>, Local Variables, Static and Global Variables, thread_local Variables</td>
</tr>
<tr>
<td>Classes</td>
<td>Doing Work in Constructors, Implicit Conversions, Copyable and Movable Types, Structs vs. Classes, Structs vs. Pairs and Tuples, Inheritance, Operator Overloading, Access Control, Declaration Order</td>
</tr>
<tr>
<td>Functions</td>
<td>Inputs and Outputs, Write Short Functions, Function Overloading, Default Arguments, Trailing Return Type Syntax</td>
</tr>
<tr>
<td>Google-Specific Magic</td>
<td>Ownership and Smart Pointers, cpplint</td>
</tr>
<tr>
<td>Other C++ Features</td>
<td>Rvalue References, Friends, Exceptions, noexcept, Run-Time Type Information (RTTI), Casting, Streams, Preincrement and Predecrement, Use of const, Use of constexpr, constinit, and consteval, Integer Types, Floating-Point Types, Architecture Portability, Preprocessor Macros, 0 and nullptr/NULL, sizeof, Type Deduction (including auto), Class Template Argument Deduction, Designated Initializers, Lambda Expressions, Template Metaprogramming, Concepts and Constraints, C++20 modules, Coroutines, Boost, Disallowed standard library features, Nonstandard Extensions, Aliases, Switch Statements</td>
</tr>
<tr>
<td>Inclusive Language</td>
<td></td>
</tr>
<tr>
<td>Naming</td>
<td>General Naming Rules, File Names, Type Names, Concept Names, Variable Names, Constant Names, Function Names, Namespace Names, Enumerator Names, Macro Names, Exceptions to Naming Rules</td>
</tr>
<tr>
<td>Comments</td>
<td>Comment Style, File Comments, Struct and Class Comments, Function Comments, Variable Comments, Implementation Comments, Punctuation, Spelling, and Grammar, TODO Comments</td>
</tr>
<tr>
<td>Formatting</td>
<td>Line Length, Non-ASCII Characters, Spaces vs. Tabs, Function Declarations and Definitions, Lambda Expressions, Floating-point Literals, Function Calls, Braced Initializer List Format, Looping and branching statements, Pointer and Reference Expressions, Boolean Expressions, Return Values, Variable and Array Initialization, Preprocessor Directives, Class Format, Constructor Initializer Lists, Namespace Formatting, Horizontal Whitespace, Vertical Whitespace</td>
</tr>
<tr>
<td>Exceptions to the Rules</td>
<td>Existing Non-conformant Code, Windows Code</td>
</tr>
</tbody>
</table>
</div>
<h2 id="C-Version"><a href="#C-Version" class="headerlink" title="C++ Version"></a>C++ Version</h2><p>目前风格指南针对于 C++ 20，不使用 C++ 23 的特性，且不使用非标准扩展，例如如：编译器支持各种不属于标准 C++ 的扩展。这些扩展包括 GCC 的 <code>__attribute__</code>、内置函数如 <code>__builtin_prefetch</code> 或 SIMD、<code>#pragma</code>、内联汇编、<code>__COUNTER__</code>、<code>__PRETTY_FUNCTION__</code>、复合语句表达式（例如，<code>foo = (&#123; int x; Bar(&amp;x); x &#125;)</code>）、可变长度数组和 <code>alloca()</code>，以及“Elvis 操作符” <code>a?:b</code>。</p>
<h2 id="Header-Files"><a href="#Header-Files" class="headerlink" title="Header Files"></a>Header Files</h2><h3 id="Self-contained-Headers"><a href="#Self-contained-Headers" class="headerlink" title="Self-contained Headers"></a>Self-contained Headers</h3><blockquote>
<p>google 这里说的 .cc 其实就是 .cpp<br>头文件应该是自包含的（可以单独编译）并以 .h 结尾。非头文件但用于包含的文件应以 .inc 结尾，并且应谨慎使用。</p>
</blockquote>
<p>所有头文件都应该是自包含的。用户和重构工具不应需要遵守特殊条件来包含头文件。具体来说，头文件应该有头文件保护符，并包含它所需要的所有其他头文件。</p>
<p>当头文件声明内联函数或模板时，客户端将实例化这些内联函数和模板，这些内联函数和模板的定义也必须在头文件中，直接或通过它包含的文件。不应将这些定义移动到单独包含的头文件（-inl.h）文件中；这种做法在过去很常见，但现在不再允许。当模板的所有实例化都发生在一个 .cc 文件中时，无论是因为它们是显式的，还是因为定义仅对 .cc 文件可访问，模板定义都可以保留在该文件中。</p>
<p>在极少数情况下，设计用于包含的文件不是自包含的。这些通常旨在包含在不寻常的位置，例如另一个文件的中间。它们可能不使用头文件保护符，也可能不包含它们的前提条件。将此类文件命名为 .inc 扩展名。谨慎使用，并尽可能使用自包含头文件。</p>
<p>每个 <code>.cc</code> 文件应该包含其自己的头文件，以确保它们是自包含的。这意味着 <code>.cc</code> 文件应该包含所有它们需要的头文件，而不依赖于其他 <code>.cc</code> 文件中的头文件。这样可以确保 <code>.cc</code> 文件可以独立编译，并且可以减少构建时间。</p>
<h3 id="The-define-Guard"><a href="#The-define-Guard" class="headerlink" title="The #define Guard"></a>The #define Guard</h3><p>所有头文件都应该使用 <code>#define</code> 防护，以防止头文件被多次包含。防护符号的命名应该遵循这种模式：<code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</code>。为了保证唯一性，它们应该基于项目源代码树中的完整路径。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FOO_BAR_BAZ_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOO_BAR_BAZ_H_</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// FOO_BAR_BAZ_H_</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="Include-What-You-Use"><a href="#Include-What-You-Use" class="headerlink" title="Include What You Use"></a>Include What You Use</h3><p>如果源文件或头文件引用了在其他地方定义的符号，则该文件应直接包含一个正确地提供了该符号的声明或定义的头文件。</p>
<p>不要依赖 include 的传递。这允许人们在不影响引用了 A 头文件的 B 文件的情况下从 A 头文件中删除不再需要的 #include 语句。例如，如果 foo.cc 使用了 bar.h 中的符号，即使 foo.h 包含了 bar.h，foo.cc 也应该包含 bar.h。</p>
<h3 id="Forrward-Declarations"><a href="#Forrward-Declarations" class="headerlink" title="Forrward Declarations"></a>Forrward Declarations</h3><p>Avoid using forward declarations where possible. Instead, include the headers you need. 避免使用前向声明，取而代之的是包含需要的头文件。</p>
<p>前向声明指的是一个没有相关定义但是声明了一个符号。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In a C++ source file:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FuncInB</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> variable_in_b;</span><br><span class="line"><span class="built_in">ABSL_DECLARE_FLAG</span>(flag_in_b);</span><br></pre></td></tr></table></figure><br>pros:</p>
<ul>
<li>前向声明可以节省编译时间，因为如果用 <code>#include</code> 会强制编译器去打开另一个文件并处理更多输入。</li>
<li>前向声明可以避免一些不必要的重复编译，由于不相关的头文件的改变，<code>#include</code> 会强制多次编译你的代码。<br>cons：</li>
<li>前向声明会隐藏依赖关系，当头文件改变的时候允许用户的代码跳过必要的重编译。</li>
<li>相对于 <code>#include</code>，前向声明使得自动工具难以发现定义符号的模块。</li>
<li>前向声明可能会因库的后续更改而失效。</li>
<li>函数和模板的前向声明可能会阻止头文件所有者对其 API 进行其他兼容性更改，例如扩展参数类型、添加带默认值的模板参数或迁移到新命名空间。</li>
<li>前向声明来自 <code>std::</code> 命名空间的符号会导致未定义行为。</li>
<li>很难确定是需要前向声明还是完整的 <code>#include</code>。用前向声明替换 <code>#include</code> 可能会悄悄地改变代码的含义。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.h:</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : B &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good_user.cc:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;b.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(B*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(D* x)</span> </span>&#123; <span class="built_in">f</span>(x); &#125;  <span class="comment">// Calls f(B*)</span></span><br></pre></td></tr></table></figure></li>
<li>如果将 #include 替换为 B 和 D 的前向声明，则 test() 将调用 f(void*)。</li>
<li>前向声明多个符号可能比简单地 #include 更冗长。</li>
<li>构造代码以启用前向声明（例如，使用指针成员而不是对象成员）会使代码更慢、更复杂。<h3 id="Inline-Functions"><a href="#Inline-Functions" class="headerlink" title="Inline Functions"></a>Inline Functions</h3>只有当函数非常简单时（10行或者更少），才应该将函数定义为内联函数。<br>pros：</li>
<li>只要内联函数很小，内联函数就可以生成更高效的目标代码。 可以随意内联accessors and mutators （getter 和 setter）以及其他简短、性能关键的函数。<br>cons:</li>
<li>过度使用内联实际上会使程序变慢。 根据函数的大小，内联它可能会导致代码大小增加或减少。 内联非常小的访问器函数通常会减少代码大小，而内联非常大的函数会显著增加代码大小。 在现代处理器上，较小的代码通常运行得更快，因为可以更好地利用指令缓存。</li>
</ul>
<p>一个不错的经验法则是，如果函数长度超过 10 行，则不要内联它。 小心析构函数，由于隐式成员和基函数析构函数调用，它们通常比看起来的要长！</p>
<p>另一个有用的经验法则：使用循环或 switch 语句内联函数通常不太划算（除非在常见情况下循环或 switch 语句永远不会执行）。</p>
<p>重要的是要知道，即使函数被声明为内联函数，它们也并不总是内联的；例如，虚函数和递归函数通常不会内联。通常，递归函数不应内联。将虚函数设为内联的主要原因是将其定义放在类中，以方便使用或记录其行为，例如，用于 accessors and mutators （getter 和 setter）。</p>
<h3 id="Names-and-Order-of-Includes"><a href="#Names-and-Order-of-Includes" class="headerlink" title="Names and Order of Includes"></a>Names and Order of Includes</h3><p>遵循以下顺序包含头文件：相关头文件、C系统头文件、C标准库头文件、其他库的头文件以及项目的头文件。<br>项目的所有头文件都应作为项目源代码目录的子目录列出，不使用UNIX目录别名（当前目录）或（父目录）。 For example, <code>google-awesome-project/src/base/logging.h</code> should be included as:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/logging.h&quot;</span></span></span><br></pre></td></tr></table></figure><br>只有库要求的时候，才使用尖括号路径包含头文件。特别是以下头文件：</p>
<ul>
<li>C 和 C++ 标准库标头（例如 <stdlib.h> 和 <string>）。</li>
<li>POSIX、Linux 和 Windows 系统标头（例如 <unistd.h> 和 <windows.h>）。</li>
<li>在极少数情况下，第三方库（例如 <Python.h>）。</li>
</ul>
<p>在 <code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 中，其主要目的是实现或测试 <code>dir2/foo2.h</code> 中的内容，请按以下顺序排列包含内容：</p>
<ol>
<li>dir2/foo2.h</li>
<li><code>空行</code></li>
<li>C system 头文件 ，以及带有 .h 扩展名的需要用尖括号的其他头文件，例如 <unistd.h>、<stdlib.h>、<Python.h>。</li>
<li><code>空行</code></li>
<li>C++ 标准库头文件（不带文件扩展名），例如 <algorithm>、<cstddef>。</li>
<li><code>空行</code></li>
<li>其他库的 .h 文件</li>
<li><code>空行</code></li>
<li>项目的 .h 文件<blockquote>
<p>用一个 <code>空行</code> 分隔每个非空组。</p>
</blockquote>
</li>
</ol>
<p>按照首选顺序，如果相关头文件 dir2/foo2.h 省略了任何必要的包含，则 dir/foo.cc 或 dir/foo_test.cc 的构建将中断。因此，此规则可确保构建中断首先显示给处理这些文件的人员，而不是其他软件包中的无辜人员。</p>
<p>在每个部分中，包含的内容应按字母顺序排列。</p>
<p>例如，<code>google-awesome-project/src/foo/internal/fooserver.cc</code> 中的包含内容可能如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo/server/fooserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/basictypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo/server/bar.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;third_party/absl/flags/flag.h&quot;</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="Scoping-作用域"><a href="#Scoping-作用域" class="headerlink" title="Scoping 作用域"></a>Scoping 作用域</h2><h3 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h3><p>Namespaces 将全局所用与划分为不同的、命名的作用域，对于防止全局作用域中的名称冲突非常有用。</p>
<p>除了少数例外，应该将代码放在 namespace 中。 namespace 应该有基于项目的或者可能的路径的独一无二的名字，并且不应使用 <code>using-directives</code> (e.g., <code>using namespace foo</code> ) 。不要使用 <code>inline namespace</code>，对于未命名的 namespace，请参见 <strong><code>Internal Linkage</code></strong>。</p>
<p>Pros:</p>
<ul>
<li>是一种在大型程序中防止名称冲突的方法，同时允许大多数代码使用相对简短的名称。</li>
<li>例如，如果两个不同的项目在全局作用域中有一个名为 Foo 的类，这些符号可能会在编译时或运行时发生冲突。如果每个项目将代码放在一个命名空间中， project1::Foo 和 project2::Foo 现在是两个不同的符号，不会发生冲突，并且每个项目命名空间中的代码可以继续引用 Foo 而不用添加前缀。</li>
<li>inline namespace 会自动将它们的名称放入包含它们的作用域中。考虑以下示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> outer &#123;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> inner &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace inner</span></span><br><span class="line">&#125;  <span class="comment">// namespace outer</span></span><br></pre></td></tr></table></figure>
表达式 <code>outer::inner::foo()</code> 和 <code>outer::foo()</code> 是等价的，可以互换使用。inline namespace 的主要目的是在不同版本之间实现ABI（应用程序二进制接口）兼容性。</li>
</ul>
<p>Cons：</p>
<ul>
<li>命名空间可能会让人感到困惑，因为它们会复杂化确定某个名称所指定义的机制。</li>
<li>特别是 inline namespace 可能会让人感到困惑，因为 names 实际上并不受限于它们声明的命名空间。 它们只有作为某些更大的版本控制策略的一部分才有用。<ul>
<li>在一个库中，通常只有一个版本会被标记为 inline namespace，以便在不指定版本的情况下默认使用该版本。这样可以确保默认情况下使用的是最新的或最稳定的版本，同时仍然允许用户显式地选择其他版本。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">namespace</span> MyLibrary &#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">namespace</span> v1 &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// v1 implementation</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> v2 &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// v2 implementation</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyLibrary::<span class="built_in">foo</span>(); <span class="comment">// Calls v1::foo() due to inline namespace</span></span><br><span class="line">    MyLibrary::v2::<span class="built_in">foo</span>(); <span class="comment">// Calls v2::foo()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在某些情况下，有必要在使用符号时始终使用其完全限定名称。对于嵌套较深的命名空间，这可能会导致代码变得杂乱无章。</li>
</ul>
<p>Decision：</p>
<ul>
<li><p>遵循命名空间的名称规则(Namespace Names)</p>
<ul>
<li>命名空间名称全部小写，单词之间用下划线分隔。顶级命名空间名称基于项目名称。避免嵌套命名空间和众所周知的顶级命名空间之间的冲突。</li>
<li>顶级命名空间的名称通常应该是包含该命名空间中代码的项目或团队的名称。该命名空间中的代码通常应该在其基本名称与命名空间名称匹配的目录中（或其子目录中）。</li>
<li>命名空间的名称应该遵循与变量名称相同的命名约定，但由于命名空间内的代码通常不需要频繁地引用命名空间名称，因此不需要特别考虑缩写命名空间名称。</li>
<li>避免嵌套命名空间与众所周知的顶级命名空间匹配。命名空间名称之间的冲突可能会导致由于名称查找规则而导致令人惊讶的构建中断。特别是，不要创建任何嵌套的 std 命名空间。优先使用唯一的项目标识符（websearch::index，websearch::index_util），而不是容易发生冲突的名称，如 websearch::util。还要避免过于深层次的嵌套命名空间。</li>
<li>对于内部命名空间，要警惕将其他代码添加到相同的内部命名空间中导致冲突（团队内部的内部助手往往是相关的，可能会导致冲突）。在这种情况下，使用文件名创建唯一的内部名称是有帮助的（用于 frobber.h 中的 websearch::index::frobber_internal）。</li>
</ul>
</li>
<li><p>使用示例中所示的注释来终止多行命名空间</p>
</li>
<li>命名空间在包含文件之后包裹整个源文件。 <code>gflags</code> 可以定义/声明来自其他命名空间的类和类的前向声明。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In the .h file</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// All declarations are within the namespace scope.</span></span><br><span class="line"><span class="comment">// 所有声明都在命名空间范围内</span></span><br><span class="line"><span class="comment">// Notice the lack of indentation.</span></span><br><span class="line"><span class="comment">// 注意缺少缩进</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In the .cc file</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition of functions is within scope of the namespace.</span></span><br><span class="line"><span class="comment">// 函数的定义在命名空间范围内</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure>
  更复杂的源文件可能包含其他细节，比如 flags 和 声明的使用。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ABSL_FLAG</span>(<span class="type">bool</span>, someflag, <span class="literal">false</span>, <span class="string">&quot;a flag&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ::foo::Bar;</span><br><span class="line"></span><br><span class="line">...code <span class="keyword">for</span> mynamespace...    <span class="comment">// Code goes against the left margin.</span></span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure></li>
<li>在生成的协议消息代码中使用命名空间，请在 <code>.proto</code> 文件中使用 <code>package</code> 指示符。有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated#package">https://developers.google.com/protocol-buffers/docs/reference/cpp-generated#package</a> 有关Protocol Buffer包的详细信息。</li>
<li>不要在命名空间 <code>std</code> 中声明任何东西，包括标准库类的前向声明。在命名空间 <code>std</code> 中声明实体是未定义的行为，即不可移植的。要声明标准库中的实体，请包含相应的头文件。</li>
<li>不能使用 using-directive 来让整个命名空间可见，因为这会导致命名空间污染。使用 using-declaration 来引入单个符号。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forbidden 污染命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> foo;</span><br></pre></td></tr></table></figure></li>
<li>Do not use Namespace aliases at namespace scope in header files except in explicitly marked internal-only namespaces, because anything imported into a namespace in a header file becomes part of the public API exported by that file. / 在头文件中，除非在明确标记为仅内部的命名空间中，否则不要在命名空间范围内使用命名空间别名，因为在头文件中导入到命名空间中的任何内容都将成为该文件导出的公共 API 的一部分。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shorten access to some commonly used names in .cc files.</span></span><br><span class="line"><span class="keyword">namespace</span> baz = ::foo::bar::baz;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shorten access to some commonly used names (in a .h file).</span></span><br><span class="line"><span class="keyword">namespace</span> librarian &#123;</span><br><span class="line"><span class="keyword">namespace</span> internal &#123;  <span class="comment">// Internal, not part of the API.</span></span><br><span class="line"><span class="keyword">namespace</span> sidetable = ::pipeline_diagnostics::sidetable;</span><br><span class="line">&#125;  <span class="comment">// namespace internal</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">my_inline_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// namespace alias local to a function (or method).</span></span><br><span class="line">  <span class="comment">// 函数（或方法）中的命名空间别名</span></span><br><span class="line">  <span class="keyword">namespace</span> baz = ::foo::bar::baz;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace librarian</span></span><br></pre></td></tr></table></figure></li>
<li>不要使用内联命名空间</li>
<li>使用名称包含 “internal” 的命名空间来文档化 API 中不应被 API 用户提及的部分。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在非 Abseil 库的代码中，不应该使用 absl::container_internal::ImplementationDetail 这个内部实现细节的名称。这是为了避免依赖 Abseil 库的内部实现细节，从而提高代码的可维护性和稳定性</span></span><br><span class="line"><span class="keyword">using</span> ::absl::container_internal::ImplementationDetail;</span><br></pre></td></tr></table></figure></li>
<li>在新代码中，首选单行嵌套命名空间声明，但不是必需的。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行嵌套</span></span><br><span class="line"><span class="keyword">namespace</span> MyLibrary::v1 &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// v1 implementation</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> MyLibrary::v2 &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// v2 implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多行嵌套</span></span><br><span class="line"><span class="keyword">namespace</span> MyLibrary &#123;</span><br><span class="line">    <span class="keyword">namespace</span> v1 &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// v1 implementation</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> v2 &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// v2 implementation</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Internal-Linkage-内部链接"><a href="#Internal-Linkage-内部链接" class="headerlink" title="Internal Linkage 内部链接"></a>Internal Linkage 内部链接</h3><p><strong>所有声明都可以通过将其置于未命名命名空间中获得内部链接</strong>。<strong>通过声明函数和变量的名称（ static ），也可以将它们赋予内部链接</strong>。这意味着您<strong>声明的任何内容都无法从其他文件中访问</strong>。如果另一个文件也声明了具有相同名称的实体，那么这两个实体<strong>完全独立</strong>。</p>
<p>当 .cc 文件中的定义不需要在该文件外部被引用时，可以通过将它们放入未命名命名空间或使用 static 进行内部链接。不要在 .h 文件中使用这些构造。</p>
<p>Decision:</p>
<ul>
<li>鼓励在 .cc 文件中使用内部链接，用于所有不需要在其他地方引用的代码。不要在 .h 文件中使用内部链接。</li>
<li>像命名空间一样格式化未命名命名空间。在终止注释中，将命名空间名称留空：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Nonmember-Static-Member-and-Global-Functions-非成员、静态成员和全局函数"><a href="#Nonmember-Static-Member-and-Global-Functions-非成员、静态成员和全局函数" class="headerlink" title="Nonmember, Static Member, and Global Functions 非成员、静态成员和全局函数"></a>Nonmember, Static Member, and Global Functions 非成员、静态成员和全局函数</h3><p>非成员函数应该放在命名空间中；很少使用完全的全局函数。不要仅仅为了分组静态成员而使用类。类的静态方法通常与类的实例或类的静态数据密切相关。</p>
<p>Pros:</p>
<ul>
<li>在某些情况下，非成员函数和静态成员函数可能很有用。将非成员函数放在命名空间中可以避免污染全局命名空间。<br>Cons:</li>
<li>如果非成员函数和静态成员函数访问外部资源或具有重要依赖关系，则将其作为新类的成员可能更有意义。</li>
</ul>
<p>Decision:</p>
<ul>
<li>有时定义一个不绑定到类实例的函数是有用的。这样的函数可以是静态成员函数或非成员函数。非成员函数不应依赖于外部变量，并且几乎总是存在于命名空间中。不要创建仅用于分组静态成员的类；这与仅给名称一个公共前缀没有区别，而且这种分组通常是不必要的。</li>
<li>如果定义了一个非成员函数，并且它只在其 .cc 文件中需要，请使用内部链接来限制其范围。</li>
</ul>
<h3 id="Local-Variables"><a href="#Local-Variables" class="headerlink" title="Local Variables"></a>Local Variables</h3><p>将函数的变量放在尽可能狭窄的范围内，并在声明中初始化变量。</p>
<p>C++ 允许在函数中的任何位置声明变量。我们鼓励将它们声明在尽可能局部的范围内，并尽可能靠近第一次使用。这使读者更容易找到声明，并查看变量的类型以及它的初始化方式。特别是，应使用初始化而不是声明和赋值，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="built_in">f</span>();  <span class="comment">// Good -- declaration has initialization.</span></span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> jobs = <span class="built_in">NumJobs</span>();</span><br><span class="line"><span class="built_in">f</span>(jobs);      <span class="comment">// Good -- declaration immediately (or closely) followed by use.</span></span><br></pre></td></tr></table></figure><br>Prefer initializing using brace initialization. /<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;  <span class="comment">// Good -- v starts initialized.</span></span><br></pre></td></tr></table></figure><br>在 if、while 和 for 语句中通常应声明需要的变量，以便这些变量被限制在这些作用域中。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="type">const</span> <span class="type">char</span>* p = <span class="built_in">strchr</span>(str, <span class="string">&#x27;/&#x27;</span>)) str = p + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><br>警告：如果变量是一个对象，那么每次进入作用域并创建时都会调用其构造函数，每次退出作用域时都会调用其析构函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inefficient implementation:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">  Foo f;  <span class="comment">// My ctor and dtor get called 1000000 times each.</span></span><br><span class="line">  f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在循环中使用的变量可能更有效地在循环外部声明：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo f;  <span class="comment">// My ctor and dtor get called once each.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">  f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Static-and-Global-Variables-静态和全局变量"><a href="#Static-and-Global-Variables-静态和全局变量" class="headerlink" title="Static and Global Variables 静态和全局变量"></a>Static and Global Variables 静态和全局变量</h3><p>禁止使用不是 平凡可销毁 (trivially destructible) 的具有static storage duration 的对象。这意味着就算考虑到成员和基类的析构函数，析构函数也不执行任何操作。也就是说，该类型没有用户定义的或虚拟的析构函数，并且所有基类和非静态成员都是平凡可销毁的。静态函数局部变量可以使用动态初始化。静态类成员变量或命名空间范围内的变量使用动态初始化是不鼓励的，但在有限的情况下是允许的；详情见下文。</p>
<p>一个经验法则：如果考虑到它的声明，一个全局变量满足这些要求，那么它的声明在隔离的情况下可以是 <code>constexpr</code>。</p>
<blockquote>
<p>在C++中，”非平凡”（non-trivial）通常用于描述构造函数、析构函数、复制构造函数和赋值操作符等函数的复杂性。具体来说，非平凡的函数是指那些执行了超出简单内存操作的额外工作。</p>
<ul>
<li><strong>非平凡的构造函数</strong>：如果构造函数执行了比如分配内存、调用其他函数或执行逻辑操作，那么它就是非平凡的。</li>
<li><strong>平凡的构造函数</strong>：如果构造函数只执行简单的内存初始化（例如，设置成员变量为默认值），那么它就是平凡的。</li>
<li><strong>非平凡的析构函数</strong>：如果析构函数执行了比如释放动态分配的内存、关闭文件或释放资源，那么它就是非平凡的。</li>
<li><strong>平凡的析构函数</strong>：如果析构函数不执行任何操作，或者只执行简单的内存释放，那么它就是平凡的。</li>
<li><strong>非平凡的复制构造函数和赋值操作符</strong>：如果这些函数执行比如深拷贝、分配内存或调用其他函数，那么它们就是非平凡的。</li>
<li><strong>平凡的复制构造函数和赋值操作符</strong>：如果这些函数只执行简单的内存复制，那么它们就是平凡的。</li>
</ul>
</blockquote>
<p>Define:<br>每个对象都有一个 storage duration，与它的生命周期相关。具有 static storage duration 的对象从初始化点一直存活到程序结束。此类对象在命名空间范围内作为变量出现（全局变量），作为<strong>类的静态数据成员</strong>，或者作为<strong>使用 static 关键字声明的函数局部变量</strong>。</p>
<p><strong>函数局部静态变量</strong>在控制流<strong>首次通过其声明时初始化</strong>；<br>其他具有 static storage duration 的对象<strong>在程序启动时初始化</strong>。所有具有static storage duration 的对象在程序退出时被销毁（在未终止的线程之前发生）。</p>
<p>初始化可能是动态的，这意味着在初始化过程中会发生一些非平凡的事情。（例如，考虑一个构造函数，它分配内存，或者一个被初始化为当前进程ID的变量。）另一种初始化是静态初始化。尽管这两种初始化方式并不完全对立，但静态初始化总是发生在具有静态存储持续时间的对象上（将对象初始化为给定的常量或所有字节都被设置为零的表示），而动态初始化则在必要时在静态初始化之后发生。</p>
<p>Pros:</p>
<ul>
<li>全局和静态变量对于大量应用程序非常有用：命名常量、某个翻译单元内部的辅助数据结构、命令行标志、日志记录、注册机制、后台基础设施等。</li>
</ul>
<p>Cons:</p>
<ul>
<li>全局静态变量如果使用动态初始化或有复杂的析构函数，会带来复杂性，容易导致难以发现的错误。动态初始化不会在翻译单元之间按顺序进行，同样，析构也不按顺序进行（除非是按初始化顺序的逆序进行）。当一个初始化操作引用另一个具有静态存储期的变量时，有可能导致在该对象的生存期开始之前或结束之后对其进行访问。此外，如果程序启动了未在退出时关闭的线程，这些线程可能会在它们的析构函数已经运行之后尝试访问已经结束生命周期的对象。</li>
</ul>
<p>Decision</p>
<ul>
<li><p>Decision on destruction / 析构函数的决策</p>
<ul>
<li><p>当析构函数是平凡的时，它们的执行根本不受顺序的影响（它们实际上没有“运行”）；否则，我们有可能在对象生命周期结束后尝试访问对象。所以我们只允许平凡可销毁的具有 static storage duration 的对象。基本类型（如指针和 int 整型）是平凡可销毁的，平凡可销毁类型的数组也是如此。注意，用 <code>constexpr</code> 标记的常量表达式也是平凡可销毁的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> kNum = <span class="number">10</span>;  <span class="comment">// Allowed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123; <span class="type">int</span> n; &#125;;</span><br><span class="line"><span class="type">const</span> X kX[] = &#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;&#125;;  <span class="comment">// Allowed</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> kMessages[] = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;  <span class="comment">// Allowed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allowed: constexpr 保证了平凡析构</span></span><br><span class="line"><span class="keyword">constexpr</span> std::array&lt;<span class="type">int</span>, 3&gt; kArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad: 非平凡析构</span></span><br><span class="line"><span class="type">const</span> std::string kFoo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad for the same reason, 尽管 kBar 是一个引用（该规则也适用于存活时间延长的临时对象），但由于非平凡析构函数，所以是不好的。</span></span><br><span class="line"><span class="type">const</span> std::string&amp; kBar = <span class="built_in">StrCat</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Bad: 非平凡析构</span></span><br><span class="line"><span class="type">static</span> std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; kData = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">3</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Decision on initialization / 初始化的决策</p>
</li>
<li><p>Common patterns / 通用模式</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://val213.github.io">Val</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://val213.github.io/2024/12/12/%E5%BC%80%E5%8F%91/cpp/style-guide/">https://val213.github.io/2024/12/12/%E5%BC%80%E5%8F%91/cpp/style-guide/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/language/">language</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/12/12/%E5%BC%80%E5%8F%91/cpp/protobuf/" title="Protobuf"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Protobuf</div></div></a></div><div class="next-post pull-right"><a href="/2024/12/12/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/leveldb/" title="google/LevelDB"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">google/LevelDB</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://github.com/val213/image/blob/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230630230143.jpg?raw=true" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Val</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">141</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">110</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/val213"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/val213" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:val213666@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">记录跬步 e/acc</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Google-C-Style-Guide"><span class="toc-number">1.</span> <span class="toc-text">Google C++ Style Guide</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#table-of-contents"><span class="toc-number">1.1.</span> <span class="toc-text">table of contents</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-Version"><span class="toc-number">1.2.</span> <span class="toc-text">C++ Version</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Header-Files"><span class="toc-number">1.3.</span> <span class="toc-text">Header Files</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Self-contained-Headers"><span class="toc-number">1.3.1.</span> <span class="toc-text">Self-contained Headers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-define-Guard"><span class="toc-number">1.3.2.</span> <span class="toc-text">The #define Guard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Include-What-You-Use"><span class="toc-number">1.3.3.</span> <span class="toc-text">Include What You Use</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Forrward-Declarations"><span class="toc-number">1.3.4.</span> <span class="toc-text">Forrward Declarations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inline-Functions"><span class="toc-number">1.3.5.</span> <span class="toc-text">Inline Functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Names-and-Order-of-Includes"><span class="toc-number">1.3.6.</span> <span class="toc-text">Names and Order of Includes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scoping-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.4.</span> <span class="toc-text">Scoping 作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Namespaces"><span class="toc-number">1.4.1.</span> <span class="toc-text">Namespaces</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Internal-Linkage-%E5%86%85%E9%83%A8%E9%93%BE%E6%8E%A5"><span class="toc-number">1.4.2.</span> <span class="toc-text">Internal Linkage 内部链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nonmember-Static-Member-and-Global-Functions-%E9%9D%9E%E6%88%90%E5%91%98%E3%80%81%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8C%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text">Nonmember, Static Member, and Global Functions 非成员、静态成员和全局函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Local-Variables"><span class="toc-number">1.4.4.</span> <span class="toc-text">Local Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Static-and-Global-Variables-%E9%9D%99%E6%80%81%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.5.</span> <span class="toc-text">Static and Global Variables 静态和全局变量</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/22/%E5%BC%80%E5%8F%91/%E4%B8%AD%E9%97%B4%E4%BB%B6/minikube/" title="minikube"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="minikube"/></a><div class="content"><a class="title" href="/2024/12/22/%E5%BC%80%E5%8F%91/%E4%B8%AD%E9%97%B4%E4%BB%B6/minikube/" title="minikube">minikube</a><time datetime="2024-12-22T06:53:52.213Z" title="Created 2024-12-22 14:53:52">2024-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/12/%E5%BC%80%E5%8F%91/cpp/protobuf/" title="Protobuf"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Protobuf"/></a><div class="content"><a class="title" href="/2024/12/12/%E5%BC%80%E5%8F%91/cpp/protobuf/" title="Protobuf">Protobuf</a><time datetime="2024-12-12T11:54:32.065Z" title="Created 2024-12-12 19:54:32">2024-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/12/%E5%BC%80%E5%8F%91/cpp/style-guide/" title="Google C++ Style Guide"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Google C++ Style Guide"/></a><div class="content"><a class="title" href="/2024/12/12/%E5%BC%80%E5%8F%91/cpp/style-guide/" title="Google C++ Style Guide">Google C++ Style Guide</a><time datetime="2024-12-12T07:28:41.150Z" title="Created 2024-12-12 15:28:41">2024-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/12/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/leveldb/" title="google/LevelDB"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="google/LevelDB"/></a><div class="content"><a class="title" href="/2024/12/12/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/leveldb/" title="google/LevelDB">google/LevelDB</a><time datetime="2024-12-11T16:36:12.083Z" title="Created 2024-12-12 00:36:12">2024-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/12/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/brpc/" title="apache/brpc"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="apache/brpc"/></a><div class="content"><a class="title" href="/2024/12/12/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/brpc/" title="apache/brpc">apache/brpc</a><time datetime="2024-12-11T16:36:05.118Z" title="Created 2024-12-12 00:36:05">2024-12-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Val</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">纯粹的心，感受意义不明</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>