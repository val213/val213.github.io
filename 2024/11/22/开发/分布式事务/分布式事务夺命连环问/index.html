<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>分布式事务夺命连环问 | Val-Blog</title><meta name="author" content="Val,10425999@qq.com, val213666@gmail.com"><meta name="copyright" content="Val"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么是分布式事务？分布式事务是指一个业务流程跨越多个分布式系统或服务的事务处理。他需要确保在多个参与者之间的数据一致性和原子性。 分布式事务中只有最合适的方案，没有最好的方案。根据业务场景的不同，选择不同的分布式事务解决方案。 请解释 2PC 协议的基本过程2PC 协议是指两阶段提交协议，是一种保证分布式事务的一致性的协议。 基本组成： 1个协调者（Coordinator）：负责协调事务的提交和">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式事务夺命连环问">
<meta property="og:url" content="https://val213.github.io/2024/11/22/%E5%BC%80%E5%8F%91/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%BA%E5%91%BD%E8%BF%9E%E7%8E%AF%E9%97%AE/index.html">
<meta property="og:site_name" content="Val-Blog">
<meta property="og:description" content="什么是分布式事务？分布式事务是指一个业务流程跨越多个分布式系统或服务的事务处理。他需要确保在多个参与者之间的数据一致性和原子性。 分布式事务中只有最合适的方案，没有最好的方案。根据业务场景的不同，选择不同的分布式事务解决方案。 请解释 2PC 协议的基本过程2PC 协议是指两阶段提交协议，是一种保证分布式事务的一致性的协议。 基本组成： 1个协调者（Coordinator）：负责协调事务的提交和">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2024-11-22T14:47:40.664Z">
<meta property="article:modified_time" content="2024-11-26T09:55:34.075Z">
<meta property="article:author" content="Val">
<meta property="article:tag" content="分布式事务">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://val213.github.io/2024/11/22/%E5%BC%80%E5%8F%91/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%BA%E5%91%BD%E8%BF%9E%E7%8E%AF%E9%97%AE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: Val","link":"Link: ","source":"Source: Val-Blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '分布式事务夺命连环问',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-26 17:55:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://github.com/val213/image/blob/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230630230143.jpg?raw=true" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">135</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">108</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Val-Blog"><span class="site-name">Val-Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">分布式事务夺命连环问</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-11-22T14:47:40.664Z" title="Created 2024-11-22 22:47:40">2024-11-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-11-26T09:55:34.075Z" title="Updated 2024-11-26 17:55:34">2024-11-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="分布式事务夺命连环问"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><!-- https://www.cnblogs.com/crazymakercircle/p/13917517.html
https://www.bilibili.com/video/BV1bM4y1z71o/?spm_id_from=333.788.player.switch&vd_source=847221b55474b08239f9c09c5099e6ac&p=7 -->
<h1 id="什么是分布式事务？"><a href="#什么是分布式事务？" class="headerlink" title="什么是分布式事务？"></a>什么是分布式事务？</h1><p>分布式事务是指一个业务流程跨越多个分布式系统或服务的事务处理。他需要确保在多个参与者之间的数据一致性和原子性。</p>
<p>分布式事务中只有最合适的方案，没有最好的方案。根据业务场景的不同，选择不同的分布式事务解决方案。</p>
<h1 id="请解释-2PC-协议的基本过程"><a href="#请解释-2PC-协议的基本过程" class="headerlink" title="请解释 2PC 协议的基本过程"></a>请解释 2PC 协议的基本过程</h1><p>2PC 协议是指两阶段提交协议，是一种保证分布式事务的一致性的协议。</p>
<h2 id="基本组成："><a href="#基本组成：" class="headerlink" title="基本组成："></a>基本组成：</h2><ul>
<li>1个协调者（Coordinator）：负责协调事务的提交和回滚。例如事务管理器。</li>
<li>n个参与者（Participant）：事务的执行者，根据协调者的指令执行事务。例如数据库、消息队列等。<h2 id="它的基本过程如下："><a href="#它的基本过程如下：" class="headerlink" title="它的基本过程如下："></a>它的基本过程如下：</h2></li>
</ul>
<ol>
<li>准备阶段：协调者询问所有参与者是否可以提交事务，参与者返回<strong>事务的执行结果</strong>。</li>
<li>提交阶段：如果所有参与者在准备阶段都<strong>返回可以提交事务</strong>，进入提交阶段，协调者向所有参与者发送提交请求，参与者执行事务提交操作。</li>
</ol>
<p><img src="image.png" alt="2PC示意图"></p>
<h2 id="2pc解决了什么问题？比起一阶段提交有什么好处？"><a href="#2pc解决了什么问题？比起一阶段提交有什么好处？" class="headerlink" title="2pc解决了什么问题？比起一阶段提交有什么好处？"></a>2pc解决了什么问题？比起一阶段提交有什么好处？</h2><p>两阶段提交（2PC, Two-Phase Commit）是一种分布式事务协议，旨在确保跨多个节点的分布式事务能够<strong>原子性地提交或回滚</strong>，从而解决<strong>单阶段提交无法协调多节点一致性的问题</strong>。</p>
<hr>
<h3 id="一阶段提交的问题"><a href="#一阶段提交的问题" class="headerlink" title="一阶段提交的问题"></a><strong>一阶段提交的问题</strong></h3><p>一阶段提交（One-Phase Commit, 1PC）指的是直接让每个参与者节点在收到请求后执行事务（提交或回滚）而不进行协调。这种方式的问题在于：</p>
<ol>
<li><p><strong>缺乏协调机制</strong>：</p>
<ul>
<li>每个参与者独立决策，可能<strong>导致部分节点成功提交，部分节点失败</strong>，事务结果不一致（<strong>数据不一致性</strong>）。</li>
</ul>
</li>
<li><p><strong>无法处理失败情况</strong>：</p>
<ul>
<li>若某些节点提交成功，但<strong>其他节点失败或因网络问题无法响应，事务的整体状态无法回滚或重试</strong>，导致数据不完整。</li>
</ul>
</li>
<li><p><strong>缺少分布式原子性</strong>：</p>
<ul>
<li><strong>没有机制保证事务要么在所有节点上完成，要么在所有节点上回滚</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2PC-解决的问题"><a href="#2PC-解决的问题" class="headerlink" title="2PC 解决的问题"></a><strong>2PC 解决的问题</strong></h3><p>两阶段提交通过将事务拆分为两个阶段（<strong>准备阶段</strong>和<strong>提交阶段</strong>），引入协调者角色，确保所有节点在提交事务前达成一致，解决了一阶段提交中的核心问题：</p>
<h4 id="1-保证分布式事务的原子性"><a href="#1-保证分布式事务的原子性" class="headerlink" title="1. 保证分布式事务的原子性"></a><strong>1. 保证分布式事务的原子性</strong></h4><ul>
<li>通过 <strong>准备阶段</strong>，协调者会询问所有参与者是否可以提交事务。只有所有参与者都回复 “准备好”（即返回 <code>Yes</code>）时，事务才会进入 <strong>提交阶段</strong>。</li>
<li>如果有任何一个参与者返回 <code>No</code>，协调者会指示所有参与者回滚事务，避免数据不一致。</li>
</ul>
<h4 id="2-提高容错能力"><a href="#2-提高容错能力" class="headerlink" title="2. 提高容错能力"></a><strong>2. 提高容错能力</strong></h4><ul>
<li>在准备阶段，事务状态会被持久化（例如日志存储）。即使协调者或某个参与者节点在提交过程中发生故障，事务状态可以在恢复后重新处理。</li>
</ul>
<h4 id="3-引入事务协调者"><a href="#3-引入事务协调者" class="headerlink" title="3. 引入事务协调者"></a><strong>3. 引入事务协调者</strong></h4><ul>
<li>协调者充当全局决策者，负责统一管理参与者的状态：<ul>
<li>参与者仅执行协调者的指令，避免节点独立决策造成的冲突。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2PC-相比-1PC-的好处"><a href="#2PC-相比-1PC-的好处" class="headerlink" title="2PC 相比 1PC 的好处"></a><strong>2PC 相比 1PC 的好处</strong></h3><div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>一阶段提交（1PC）</th>
<th>两阶段提交（2PC）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>一致性</strong></td>
<td>可能导致数据不一致（部分提交，部分失败）。</td>
<td>确保所有节点的一致性：要么全提交，要么全回滚。</td>
</tr>
<tr>
<td><strong>容错能力</strong></td>
<td>节点失败后无法恢复事务状态。</td>
<td>通过日志或状态记录，支持故障恢复。</td>
</tr>
<tr>
<td><strong>原子性</strong></td>
<td>无法保证事务的原子性。</td>
<td>事务提交和回滚是全局一致的，确保原子性。</td>
</tr>
<tr>
<td><strong>协调机制</strong></td>
<td>无统一协调，节点独立操作。</td>
<td>协调者统一管理事务的状态与提交流程。</td>
</tr>
<tr>
<td><strong>复杂性</strong></td>
<td>简单，适合单节点事务或对一致性要求较低的场景。</td>
<td>较复杂，但适用于高一致性、高可靠性的分布式场景。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="2PC-的局限性"><a href="#2PC-的局限性" class="headerlink" title="2PC 的局限性"></a><strong>2PC 的局限性</strong></h3><p>虽然 2PC 在一致性和原子性方面较 1PC 有明显优势，但也存在以下问题：</p>
<ol>
<li><strong>性能开销</strong>：<ul>
<li>多次通信和日志记录增加了事务提交的延迟。</li>
<li>长时间的资源占用，可能会导致系统的吞吐量下降。</li>
</ul>
</li>
<li><p><strong>同步阻塞问题</strong>：</p>
<ul>
<li>如果协调者或某些参与者发生故障，其他节点可能会<strong>阻塞等待</strong>，影响系统并发性能。</li>
</ul>
</li>
<li><p><strong>单点故障</strong>：</p>
<ul>
<li>协调者（事务管理器）如果发生宕机，可能导致事务状态无法推进。尽管可以通过<strong>备份协调器，日志</strong>来实现一定程度上容错，但是也存在</li>
</ul>
</li>
<li><p><strong>脑裂问题</strong>：</p>
<ul>
<li>如果<strong>协调者和参与者之间的通信发生故障</strong>，可能<strong>导致事务状态不一致</strong>，需要额外的机制来解决。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>相比一阶段提交，2PC 提供了一种简单但有效的方式来解决分布式事务的一致性和原子性问题，适用于小规模分布式系统或对事务性能要求不高的场景。然而，在需要高性能、高可用的分布式系统中，通常会选择改进的分布式协议（如 3PC、Paxos、Raft）或弱一致性事务模型（如 BASE 理论）来解决 2PC 的性能和可用性问题。</p>
<h1 id="2PC-协议中，如何处理协调者和参与者之间的通信故障？请列举一些解决方案。"><a href="#2PC-协议中，如何处理协调者和参与者之间的通信故障？请列举一些解决方案。" class="headerlink" title="2PC 协议中，如何处理协调者和参与者之间的通信故障？请列举一些解决方案。"></a>2PC 协议中，如何处理协调者和参与者之间的通信故障？请列举一些解决方案。</h1><p><strong>在 2PC 协议中，协调者和参与者之间的通信故障是不可避免的</strong>。为了保证分布式事务的一致性和可靠性，需要采取一些措施来处理这种故障情况。以下是一些常见的解决方案：</p>
<ul>
<li>超时机制（Timeout）：协调者和参与者之间的通信需要设置超时时间，如果<strong>在规定时间内没有收到对方的响应，可以认为对方发生了故障。此时直接通知其他参与者回滚事务</strong>。</li>
<li>心跳检测（Heartbeat）：协调者和参与者之间<strong>定期发送</strong>心跳消息，检测对方的存活状态。如<strong>果长时间未收到心跳消息，可以认为对方发生了故障</strong>。</li>
<li><strong>预备性提交（Prepared Commit）</strong>：在 2PC 的准备阶段，协调者会询问所有参与者是否可以提交事务。<strong>如果某个参与者在准备阶段返回“可以提交”，但在提交阶段发生通信故障</strong>，无法收到参与者的确认请求，那么向该参与者发送回滚请求。</li>
<li>备份协调器（Backup Coordinator）：为了防止协调者发生故障，可以引入备份协调器。备份协调器会定期同步协调者的状态，一旦协调者发生故障，备份协调器可以接管事务的协调工作。</li>
</ul>
<h1 id="说说你了解的3PC协议，它在2PC的基础上有什么改进？"><a href="#说说你了解的3PC协议，它在2PC的基础上有什么改进？" class="headerlink" title="说说你了解的3PC协议，它在2PC的基础上有什么改进？"></a>说说你了解的3PC协议，它在2PC的基础上有什么改进？</h1><p>3PC 协议（Three-Phase Commit）是一种改进的分布式事务协议，相比 2PC 协议，引入了一个<strong>额外的准备阶段，以减少 2PC 中的同步阻塞和单点故障的风险</strong>。</p>
<h2 id="3PC-协议的基本过程"><a href="#3PC-协议的基本过程" class="headerlink" title="3PC 协议的基本过程"></a>3PC 协议的基本过程</h2><ol>
<li><strong>CanCommit 阶段</strong>：协调者询问所有参与者是否可以提交事务。如果所有参与者都返回“可以提交”，则进入第二阶段；否则直接回滚。</li>
<li><strong>PreCommit 阶段</strong>：协调者向所有参与者发送预提交请求，参与者执行事务的预提交操作，但是不会立即提交，而是<strong>处于就绪状态，等待协调者的下一步指示。如果所有参与者都成功，进入第三阶段；否则回滚</strong>。</li>
<li><strong>DoCommit 阶段</strong>：如果所有参与者都处于就绪状态，那么协调者向所有参与者发送提交请求，参与者执行事务的提交操作；否则协调者会向所有参与者发送 Abort 请求回滚，要求他们放弃事务。</li>
</ol>
<h3 id="3PC-对-2PC-的改进"><a href="#3PC-对-2PC-的改进" class="headerlink" title="3PC 对 2PC 的改进"></a>3PC 对 2PC 的改进</h3><p>3PC 的改进点可以总结为以下几个方面：</p>
<ol>
<li><strong>非阻塞性</strong></li>
</ol>
<ul>
<li>引入超时机制：3PC 在<strong>预提交阶段加入超时检测</strong>，使参与者在无法与协调者通信时，根据状态独立决策（如回滚或提交）。</li>
<li>状态更加细化：通过 “预提交” 阶段，参与者能清楚知道事务的中间状态，避免了因为协调者失败而陷入两难。</li>
</ul>
<ol>
<li><strong>减少单点故障的影响</strong><br>在协调者失败的情况下，参与者可以依据自己的状态（是已预提交还是未提交）决定下一步操作，而不是一直等待协调者。</li>
<li><strong>容错性更高</strong><br>如果某些参与者或协调者出现网络分区，系统可以尝试根据已有的状态继续达成一致，而不会因网络问题导致全局阻塞。</li>
</ol>
<h2 id="3PC-的局限性"><a href="#3PC-的局限性" class="headerlink" title="3PC 的局限性"></a>3PC 的局限性</h2><p>尽管 3PC 相比 2PC 改进了非阻塞性，但它仍然有以下局限：</p>
<ul>
<li><strong>网络分区下可能违背一致性</strong>：在严重的网络分区中，可能存在 “脑裂” 问题，即不同分区内的节点可能做出不同的决策。</li>
<li><strong>性能开销更大</strong>：引入了一个额外的阶段，增加了事务延迟和网络通信开销。</li>
<li><strong>并未完全消除阻塞</strong>：虽然概率更低，但某些极端情况下仍可能发生阻塞。</li>
</ul>
<h1 id="请描述-AT-模式的基本过程"><a href="#请描述-AT-模式的基本过程" class="headerlink" title="请描述 AT 模式的基本过程"></a>请描述 AT 模式的基本过程</h1><p>AT 模式（自动补偿型事务模式，Automatic Compensation Transaction）是一种基于补偿机制的分布式事务模式，通过在事务执行过程中记录补偿操作，实现事务的原子性和一致性。</p>
<p>在分布式事务中，AT 模式通过使用一种称为“业务补偿”的方法，对事务过程进行改进：每个参与者都会在完成本地事务后，生成一个补偿操作。补偿操作用于在事务失败时，将已完成的本地事务回滚到之前的状态。通过这种方式解决了 2PC 中的阻塞问题，提高了系统的可用性。</p>
<h2 id="AT-模式的基本过程"><a href="#AT-模式的基本过程" class="headerlink" title="AT 模式的基本过程"></a>AT 模式的基本过程</h2><ol>
<li><strong>Try 阶段</strong>：参与者执行本地事务，并生成补偿操作。如果所有参与者都成功，进入 Confirm 阶段；否则进入 Cancel 阶段。<ul>
<li>保存本地快照：在执行本地事务前，保存当前状态的快照，以便在回滚时恢复数据。</li>
<li>执行本地事务：参与者执行本地事务，生成补偿操作。</li>
<li>保存新快照：在事务执行成功后，保存新的快照，用于回滚操作。</li>
<li>生成行锁：为了保证事务的一致性，可以在执行本地事务时生成行锁，避免数据冲突。</li>
</ul>
</li>
<li><strong>Confirm 阶段</strong>：在协调者收到所有参与者的执行结果后，会对这些结果进行汇总和分析。如果所有参与者都成功执行了本地事务，则协调者会向所有参与者发送提交事务的请求，参与者收到请求后会提交本地事务并向协调者返回提交结果。如果任何一个参与者在执行本地事务的时候出现了错误或者超时，协调者会向所有参与者发送回滚事务的请求，参与者收到请求后会撤销本地事务并向协调者返回回滚结果。<ul>
<li>删除行锁和两个快照：在确认阶段，如果所有参与者都成功，可以删除行锁和两个快照，释放资源。</li>
</ul>
</li>
<li><strong>Cancel 阶段</strong>：参与者执行补偿操作，回滚本地事务。如果所有参与者都成功，事务回滚成功；否则需要人工介入处理。<br><img src="image-1.png" alt="撤销阶段"><h2 id="AT-模式的应用场景"><a href="#AT-模式的应用场景" class="headerlink" title="AT 模式的应用场景"></a>AT 模式的应用场景</h2>AT 模式适用于以下场景：</li>
</ol>
<ul>
<li><strong>高可用性要求</strong>：AT 模式通过补偿机制，避免了 2PC 中的阻塞问题，提高了系统的可用性。</li>
<li><strong>异步通信</strong>：AT 模式中，参与者在 Try 阶段执行本地事务，生成补偿操作，不需要等待其他参与者的响应，适用于异步通信的场景。</li>
<li><strong>业务逻辑简单</strong>：AT 模式通过补偿机制实现事务的原子性和一致性，适用于业务逻辑相对简单的场景。</li>
</ul>
<h2 id="AT-模式的局限性"><a href="#AT-模式的局限性" class="headerlink" title="AT 模式的局限性"></a>AT 模式的局限性</h2><p>尽管 AT 模式在可用性和性能方面有一定优势，但也存在以下局限性：</p>
<ul>
<li>AT 模式无法处理参与者之间存在依赖关系的事务，例如一个事务的结果依赖于另一个事务的结果，则无法使用 AT 模式来处理。</li>
<li>在尝试阶段，参与者需要锁定涉及的资源，会增加系统的并发性能开销</li>
<li>如果在确认阶段出现协调者故障，则需要使用一些额外的机制来恢复事务，否则可能导致数据不一致。</li>
</ul>
<h1 id="XA（eXtended-Architecture）是什么？它是如何实现分布式事务的？"><a href="#XA（eXtended-Architecture）是什么？它是如何实现分布式事务的？" class="headerlink" title="XA（eXtended Architecture）是什么？它是如何实现分布式事务的？"></a>XA（eXtended Architecture）是什么？它是如何实现分布式事务的？</h1><p>// todo!()<br>XA 是一个分布式事务的标准，XA 接口定义了事务管理器和资源管理器之间的通信协议，用于协调分布式事务的提交和回滚。XA 事务是一个全局事务，包含多个参与者，每个参与者是一个资源管理器，可以是数据库、消息队列等。</p>
<p>XA是由X/Open组织提出的分布式事务的规范，XA规范主要定义了(全局)事务管理器(TM)和(局部)资源管理器(RM)之间的接口。本地的数据库如mysql 在 XA 中扮演的是 RM 角色</p>
<p>XA一共分为两阶段：</p>
<ul>
<li>第一阶段（prepare）：即所有的参与者 RM 准备执行事务<strong>并锁住需要的资源</strong>。参与者 ready 时，向TM报告已准备就绪。</li>
<li>第二阶段 (commit/rollback)：当事务管理者(TM)确认所有参与者(RM)都 ready 后，向所有参与者发送 commit 命令。</li>
</ul>
<p>目前主流的数据库基本都支持XA事务，包括mysql、oracle、sqlserver、postgre</p>
<p>XA 事务由一个或多个资源管理器（RM）、一个事务管理器（TM）和一个应用程序（ApplicationProgram）组成。</p>
<h1 id="请描述-TCC-模式的基本过程"><a href="#请描述-TCC-模式的基本过程" class="headerlink" title="请描述 TCC 模式的基本过程"></a>请描述 TCC 模式的基本过程</h1><p><strong>其他需要锁定资源的协议不太适用于高并发的场景</strong>。而 TCC 协议则是一种<strong>更加适用于高并发场景的分布式事务协议</strong>。TCC 协议是一种基于“尝试”、“确认”、“取消”三个操作的分布式事务协议，通过这三个操作来实现事务的原子性和一致性。</p>
<h2 id="TCC-模式的基本过程"><a href="#TCC-模式的基本过程" class="headerlink" title="TCC 模式的基本过程"></a>TCC 模式的基本过程</h2><p><img src="image-2.png" alt="TCC 协议"></p>
<ol>
<li><strong>Try 阶段</strong>：在 Try 阶段，参与者会尝试执行本地事务，并预留资源。如果所有参与者都成功，进入 Confirm 阶段；否则进入 Cancel 阶段。<ul>
<li><strong>Try</strong>：参与者执行本地事务，尝试锁定资源。</li>
<li><strong>Confirm</strong>：参与者确认执行本地事务，释放资源。</li>
<li><strong>Cancel</strong>：参与者取消执行本地事务，释放资源。</li>
</ul>
</li>
<li><strong>Confirm 阶段</strong>：在 Confirm 阶段，协调者会向所有参与者发送确认请求，参与者执行本地事务并释放资源。如果所有参与者都成功，事务提交成功；否则进入 Cancel 阶段。<ul>
<li>具备幂等性：Confirm 阶段的操作需要具备幂等性，即多次执行结果相同。</li>
</ul>
</li>
<li><strong>Cancel 阶段</strong>：在 Cancel 阶段，协调者会向所有参与者发送取消请求，参与者撤销本地事务并释放资源。如果所有参与者都成功，事务回滚成功；否则需要人工介入处理。</li>
</ol>
<h2 id="TCC-模式的优劣"><a href="#TCC-模式的优劣" class="headerlink" title="TCC 模式的优劣"></a>TCC 模式的优劣</h2><ul>
<li><p>TCC 还是一种2阶段的提交协议，但是相比于2PC，TCC 更加适用于高并发的场景，<strong>因为 TCC 在 Try 阶段只是尝试锁定资源，并不会阻塞其他事务的执行。另外，TCC 通过 Confirm 和 Cancel 两个操作，实现了更加细粒度的事务控制，可以根据业务逻辑来决定事务的提交或回滚</strong>。</p>
</li>
<li><p>TCC 开发成本更高：2pc、3pc 对业务代码没有侵入性，<strong>而 TCC 模式需要业务代码实现 Try、Confirm、Cancel 三个操作</strong>，因此需要在业务代码中实现这三个操作，增加了业务代码的复杂性。</p>
</li>
</ul>
<h1 id="Saga-模式的基本过程"><a href="#Saga-模式的基本过程" class="headerlink" title="Saga 模式的基本过程"></a>Saga 模式的基本过程</h1><p>Saga 模式是一种基于补偿机制的分布式事务模式，<strong>通过将事务拆分为多个子事务，并在每个子事务中引入补偿操作，实现事务的原子性和一致性。</strong></p>
<h2 id="Saga-模式的基本过程-1"><a href="#Saga-模式的基本过程-1" class="headerlink" title="Saga 模式的基本过程"></a>Saga 模式的基本过程</h2><ol>
<li><strong>分解事务</strong>：将整个事务拆分为多个子事务，每个子事务对应一个业务操作。</li>
<li><strong>执行事务</strong>：依次执行每个子事务，如果所有子事务都执行成功，则事务提交成功；否则进入补偿阶段。</li>
<li><strong>补偿事务</strong>：对于执行失败的子事务，按照相反的顺序执行补偿操作，将事务回滚到之前的状态。</li>
</ol>
<h2 id="Saga-模式的优势"><a href="#Saga-模式的优势" class="headerlink" title="Saga 模式的优势"></a>Saga 模式的优势</h2><p><img src="image-3.png" alt="saga模式"></p>
<h2 id="Saga-的实现方式"><a href="#Saga-的实现方式" class="headerlink" title="Saga 的实现方式"></a>Saga 的实现方式</h2><p>在分布式事务中，Saga 模式可以分为基于事件的和基于命令的两种类型。要辨别这段代码中的 Saga 事务是基于事件的还是基于命令的，可以从以下几个方面进行分析：</p>
<ul>
<li>基于事件的 Saga：<ul>
<li>使用事件驱动的方式来协调事务。</li>
<li>每个子事务完成后，会发布一个事件，其他子事务根据事件来决定是否继续执行或回滚。</li>
</ul>
</li>
<li>基于命令的 Saga：<ul>
<li>使用命令驱动的方式来协调事务。</li>
<li>事务协调器直接发送命令给每个子事务，指示它们执行或回滚。<h3 id="基于事件的-saga"><a href="#基于事件的-saga" class="headerlink" title="基于事件的 saga"></a>基于事件的 saga</h3><img src="image-5.png" alt="基于消息的 Saga 执行"></li>
</ul>
</li>
<li>基于事件的方式中，第一个服务执行完本地事务后，会产生一个事件，其他服务会监听这个事件，触发该服务本地事务的执行，并产生新的事件。<br><img src="image-4.png" alt="基于消息的 Saga 回滚"></li>
<li>每个服务需要实现两个接口：<code>handle</code> 和 <code>compensate</code>。<code>handle</code> 用于执行业务操作，<code>compensate</code> 用于执行补偿操作，将事务回滚到之前的状态。<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4></li>
<li>优点<ul>
<li>简单且容易理解。各参与方之间没有直接沟通，完全解耦。比较适合整个分布式事务只有 2~4 个参与方的场景。</li>
<li>而且没有中心化的协调者，各个参与方可以自己决定是否执行补偿操作。</li>
</ul>
</li>
<li>缺点<ul>
<li>如果涉及过多的业务参与方，则比较容易失控。各业务参与方可以随意监听对方的消息，以至于最后没有人知道到底有哪些系统在监听哪些信息；</li>
<li>有可能会产生环形监听：两个事务相互监听对方产生的事件<h3 id="基于命令的-saga"><a href="#基于命令的-saga" class="headerlink" title="基于命令的 saga"></a>基于命令的 saga</h3>基于命令的 saga 模式会定义一个新的服务——协调中心，告诉各个参与方什么时候该做什么事情。协调中心通过命令/回复的方式来和 Saga 中其他服务进行交互。</li>
</ul>
</li>
</ul>
<p><img src="image-7.png" alt="基于命令的 Saga 执行"><br><img src="image-6.png" alt="基于命令的 Saga 回滚"></p>
<p>在 dtm 的 quick start 例子中，我们可以画出如下的时序图：</p>
<h4 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h4><p><img src="image-8.png" alt="saga事务成功"></p>
<h4 id="失败"><a href="#失败" class="headerlink" title="失败"></a>失败</h4><p><img src="image-9.png" alt="saga事务失败"></p>
<h1 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h1><p>本地消息表是一种基于数据库的解决方案。其核心思路是通过<strong>一个附加的本地表（即消息表）来记录消息</strong>，这个消息表和主业务数据在同一个数据库事务中操作。</p>
<p>本地消息表这个方案最初是 ebay 架构师 Dan Pritchett 在 2008 年发表给 ACM 的文章。<strong>设计核心是将需要分布式处理的任务通过消息的方式来异步确保执行</strong>。</p>
<h2 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h2><ul>
<li>事务开始，业务数据和消息表的记录同时被插入或更新。</li>
<li>如果事务成功提交，消息表的数据会持久化。</li>
<li>后续由一个<strong>异步任务</strong>（通常是定时任务或监听器）将消息表的记录发送到目标系统（例如<strong>消息队列</strong>或另一个服务）。</li>
</ul>
<p><img src="image-13.png" alt="本地消息表流程"></p>
<h2 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>强一致性：因为<strong>消息表与业务表共享同一个事务，天然确保消息和业务数据的一致性</strong>。</li>
<li>简单易实现：只需依赖现有的数据库，<strong>无需引入额外的中间件</strong>。<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3></li>
<li>延迟高：消息发送通常是<strong>异步</strong>的，有时会带来较高的延迟。</li>
<li>数据库压力：需要<strong>定期扫描消息表</strong>，可能会增加数据库的负载。</li>
<li>复杂度：需要编写额外的异步任务和清理逻辑。</li>
</ul>
<h1 id="MQ-事务消息"><a href="#MQ-事务消息" class="headerlink" title="MQ 事务消息"></a>MQ 事务消息</h1><p>在上述的<strong>本地消息表方案中，生产者需要额外创建消息表，还需要对本地消息表进行轮询，业务负担较重</strong>。阿里开源的 RocketMQ 4.3 之后的版本正式支持事务消息，该事务消息本质上是<strong>把本地消息表放到RocketMQ上，解决生产端的消息发送与本地事务执行的原子性问题</strong>。</p>
<p>事务消息发送及提交：</p>
<ul>
<li>生产者首先向MQ发送一个准备消息，但此时消息并未真正投递给消费者。</li>
<li>生产者执行本地事务逻辑（例如更新数据库）。</li>
<li>如果本地事务成功，则向MQ确认提交消息；如果本地事务失败，则通知MQ回滚消息。</li>
</ul>
<p><img src="image-14.png" alt="MQ 消息队列流程"></p>
<h2 id="优点与缺点-1"><a href="#优点与缺点-1" class="headerlink" title="优点与缺点"></a>优点与缺点</h2><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>实时性高：消息会在事务完成后立即被投递，无需扫描或延迟。</li>
<li>解耦性强：通过MQ中间件，可以与多个系统灵活对接。<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3></li>
<li>复杂性较高：需要依赖消息中间件的事务特性，涉及到更多配置和编程工作。</li>
<li>潜在性能开销：准备消息和确认过程可能增加系统延迟。</li>
</ul>
<h1 id="DTM-的二阶段消息"><a href="#DTM-的二阶段消息" class="headerlink" title="DTM 的二阶段消息"></a>DTM 的二阶段消息</h1><p>二阶段消息是 dtm 首创的事务模式，用于替换本地事务表和事务消息这两种现有的方案。它能够保证本地事务的提交和全局事务提交是“原子的”，适合解决不需要回滚的分布式事务场景。下面我们来看看二阶段消息，如何解决这个业务场景的问题。</p>
<h2 id="二阶段消息-vs-本地消息表"><a href="#二阶段消息-vs-本地消息表" class="headerlink" title="二阶段消息 vs 本地消息表"></a>二阶段消息 vs 本地消息表</h2><p>如果采用本地消息表，需要的工作包括：</p>
<ul>
<li>在本地事务中执行本地业务逻辑，将消息插入消息表并最后提交</li>
<li>编写轮询任务，将本地消息表的消息，发给消息队列</li>
<li>消费消息，并将消息发给相应的处理服务</li>
</ul>
<p>两者对比，二阶段消息有以下优点：</p>
<ul>
<li>无需学习或维护任何消息队列</li>
<li>不需要处理轮询任务</li>
<li>不需要消费消息<h2 id="二阶段消息-vs-事务消息"><a href="#二阶段消息-vs-事务消息" class="headerlink" title="二阶段消息 vs 事务消息"></a>二阶段消息 vs 事务消息</h2></li>
<li>无需学习或维护任何消息队列</li>
<li>本地事务与发送消息之间的复杂操作需要手动处理，一不小心，可能出现bug。而二阶段消息则是全自动处理</li>
<li>不需要消费消息</li>
</ul>
<h2 id="其他优点"><a href="#其他优点" class="headerlink" title="其他优点"></a>其他优点</h2><ul>
<li>二阶段消息整个暴露的接口，完全与队列无关，只跟实际的业务和服务调用相关，对开发人员更加友好</li>
<li>二阶段消息不用考虑消息队列消息堆积及其他故障等问题，因为二阶段消息只依赖DTM，开发人员可以认为DTM与系统中其他一个普通无状态服务一样，只依赖背后的存储 MySQL/Redis。</li>
<li>消息队列是异步的，而二阶段消息同时支持异步和同步，默认异步，只需要打开msg.WaitResult=true，那么可以同步等待下游服务完成</li>
<li>二阶段消息还支持同时指定多个下游服务</li>
</ul>
<h1 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h1><p>发起通知方通过一定的机制最大努力将业务处理结果通知到接收方。具体包括：</p>
<ul>
<li>有一定的消息重复通知机制。因为接收通知方可能没有接收到通知，此时要有一定的机制对消息重复通知。</li>
<li>消息校对机制。如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求。</li>
</ul>
<p><strong>前面介绍的的本地消息表和事务消息都属于可靠消息，与这里介绍的最大努力通知有什么不同？</strong></p>
<ul>
<li><p>可靠消息一致性，发起通知方需要保证将消息发出去，并且将消息发到接收通知方，消息的可靠性关键由发起通知方来保证。</p>
</li>
<li><p>最大努力通知，发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，通知的可靠性关键在接收通知方。</p>
</li>
</ul>
<p>解决方案上，最大努力通知需要：</p>
<ul>
<li>提供接口，让接受通知放能够通过接口查询业务处理结果</li>
<li>消息队列ACK机制，消息队列按照间隔1min、5min、10min、30min、1h、2h、5h、10h的方式，逐步拉大通知间隔 ，直到达到通知要求的时间窗口上限。之后不再通知</li>
</ul>
<p>最大努力通知<strong>适用于业务通知类型</strong>，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://val213.github.io">Val</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://val213.github.io/2024/11/22/%E5%BC%80%E5%8F%91/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%BA%E5%91%BD%E8%BF%9E%E7%8E%AF%E9%97%AE/">https://val213.github.io/2024/11/22/%E5%BC%80%E5%8F%91/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%BA%E5%91%BD%E8%BF%9E%E7%8E%AF%E9%97%AE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/23/%E5%BC%80%E5%8F%91/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/" title="Redis"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Redis</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/20/CS%E8%AF%BE%E7%A8%8B/%E3%80%90xv6%E3%80%91%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80/" title="【xv6】夯实基础"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">【xv6】夯实基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/11/25/%E5%BC%80%E5%8F%91/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/dtm/" title="dtm"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-25</div><div class="title">dtm</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://github.com/val213/image/blob/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230630230143.jpg?raw=true" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Val</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">135</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">108</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/val213"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/val213" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:val213666@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">记录跬步 e/acc</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是分布式事务？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E8%A7%A3%E9%87%8A-2PC-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">请解释 2PC 协议的基本过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">基本组成：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">它的基本过程如下：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2pc%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E6%AF%94%E8%B5%B7%E4%B8%80%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">2pc解决了什么问题？比起一阶段提交有什么好处？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">一阶段提交的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2PC-%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.2.</span> <span class="toc-text">2PC 解决的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BF%9D%E8%AF%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">1. 保证分布式事务的原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8F%90%E9%AB%98%E5%AE%B9%E9%94%99%E8%83%BD%E5%8A%9B"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">2. 提高容错能力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BC%95%E5%85%A5%E4%BA%8B%E5%8A%A1%E5%8D%8F%E8%B0%83%E8%80%85"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">3. 引入事务协调者</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2PC-%E7%9B%B8%E6%AF%94-1PC-%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.3.3.</span> <span class="toc-text">2PC 相比 1PC 的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2PC-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">2.3.4.</span> <span class="toc-text">2PC 的局限性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2PC-%E5%8D%8F%E8%AE%AE%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%8D%8F%E8%B0%83%E8%80%85%E5%92%8C%E5%8F%82%E4%B8%8E%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%95%85%E9%9A%9C%EF%BC%9F%E8%AF%B7%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82"><span class="toc-number">3.</span> <span class="toc-text">2PC 协议中，如何处理协调者和参与者之间的通信故障？请列举一些解决方案。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%843PC%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%AE%83%E5%9C%A82PC%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E6%9C%89%E4%BB%80%E4%B9%88%E6%94%B9%E8%BF%9B%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">说说你了解的3PC协议，它在2PC的基础上有什么改进？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3PC-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">3PC 协议的基本过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3PC-%E5%AF%B9-2PC-%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">4.1.1.</span> <span class="toc-text">3PC 对 2PC 的改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3PC-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">3PC 的局限性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E6%8F%8F%E8%BF%B0-AT-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">请描述 AT 模式的基本过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AT-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">AT 模式的基本过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AT-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.2.</span> <span class="toc-text">AT 模式的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AT-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">5.3.</span> <span class="toc-text">AT 模式的局限性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#XA%EF%BC%88eXtended-Architecture%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">XA（eXtended Architecture）是什么？它是如何实现分布式事务的？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E6%8F%8F%E8%BF%B0-TCC-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">请描述 TCC 模式的基本过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCC-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B"><span class="toc-number">7.1.</span> <span class="toc-text">TCC 模式的基本过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCC-%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E5%8A%A3"><span class="toc-number">7.2.</span> <span class="toc-text">TCC 模式的优劣</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Saga-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">Saga 模式的基本过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Saga-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B-1"><span class="toc-number">8.1.</span> <span class="toc-text">Saga 模式的基本过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Saga-%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">8.2.</span> <span class="toc-text">Saga 模式的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Saga-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">8.3.</span> <span class="toc-text">Saga 的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84-saga"><span class="toc-number">8.3.1.</span> <span class="toc-text">基于事件的 saga</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">8.3.1.1.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%91%BD%E4%BB%A4%E7%9A%84-saga"><span class="toc-number">8.3.2.</span> <span class="toc-text">基于命令的 saga</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%8A%9F"><span class="toc-number">8.3.2.1.</span> <span class="toc-text">成功</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B1%E8%B4%A5"><span class="toc-number">8.3.2.2.</span> <span class="toc-text">失败</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8"><span class="toc-number">9.</span> <span class="toc-text">本地消息表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">9.1.</span> <span class="toc-text">过程：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="toc-number">9.2.</span> <span class="toc-text">优点与缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">9.2.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">9.2.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MQ-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">10.</span> <span class="toc-text">MQ 事务消息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9-1"><span class="toc-number">10.1.</span> <span class="toc-text">优点与缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-1"><span class="toc-number">10.1.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-1"><span class="toc-number">10.1.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DTM-%E7%9A%84%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%B6%88%E6%81%AF"><span class="toc-number">11.</span> <span class="toc-text">DTM 的二阶段消息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%B6%88%E6%81%AF-vs-%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8"><span class="toc-number">11.1.</span> <span class="toc-text">二阶段消息 vs 本地消息表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%B6%88%E6%81%AF-vs-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">11.2.</span> <span class="toc-text">二阶段消息 vs 事务消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BC%98%E7%82%B9"><span class="toc-number">11.3.</span> <span class="toc-text">其他优点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5"><span class="toc-number">12.</span> <span class="toc-text">最大努力通知</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/04/%E8%BF%90%E7%BB%B4/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" title="内网穿透理论与实践"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="内网穿透理论与实践"/></a><div class="content"><a class="title" href="/2024/12/04/%E8%BF%90%E7%BB%B4/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" title="内网穿透理论与实践">内网穿透理论与实践</a><time datetime="2024-12-03T17:11:12.792Z" title="Created 2024-12-04 01:11:12">2024-12-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/27/%E5%A4%A7%E4%B8%89%E8%AF%BE%E7%A8%8B/%E3%80%90%E5%A4%A7%E4%B8%89%E4%B8%8A%E3%80%91%E5%B7%A5%E4%B8%9A%E6%95%B0%E6%8D%AE/" title="【大三上】工业数据"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【大三上】工业数据"/></a><div class="content"><a class="title" href="/2024/11/27/%E5%A4%A7%E4%B8%89%E8%AF%BE%E7%A8%8B/%E3%80%90%E5%A4%A7%E4%B8%89%E4%B8%8A%E3%80%91%E5%B7%A5%E4%B8%9A%E6%95%B0%E6%8D%AE/" title="【大三上】工业数据">【大三上】工业数据</a><time datetime="2024-11-27T06:13:09.184Z" title="Created 2024-11-27 14:13:09">2024-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/25/%E5%BC%80%E5%8F%91/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/dtm/" title="dtm"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="dtm"/></a><div class="content"><a class="title" href="/2024/11/25/%E5%BC%80%E5%8F%91/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/dtm/" title="dtm">dtm</a><time datetime="2024-11-25T07:11:10.400Z" title="Created 2024-11-25 15:11:10">2024-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/23/%E5%BC%80%E5%8F%91/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/" title="Redis"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis"/></a><div class="content"><a class="title" href="/2024/11/23/%E5%BC%80%E5%8F%91/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/" title="Redis">Redis</a><time datetime="2024-11-23T03:33:20.230Z" title="Created 2024-11-23 11:33:20">2024-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/22/%E5%BC%80%E5%8F%91/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%BA%E5%91%BD%E8%BF%9E%E7%8E%AF%E9%97%AE/" title="分布式事务夺命连环问"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式事务夺命连环问"/></a><div class="content"><a class="title" href="/2024/11/22/%E5%BC%80%E5%8F%91/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%BA%E5%91%BD%E8%BF%9E%E7%8E%AF%E9%97%AE/" title="分布式事务夺命连环问">分布式事务夺命连环问</a><time datetime="2024-11-22T14:47:40.664Z" title="Created 2024-11-22 22:47:40">2024-11-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Val</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">纯粹的心，感受意义不明</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>