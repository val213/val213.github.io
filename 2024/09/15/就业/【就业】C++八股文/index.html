<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++八股文 | Val-Blog</title><meta name="author" content="Val,10425999@qq.com, val213666@gmail.com"><meta name="copyright" content="Val"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++八股文C++智能指针C++标准库中的几种常见智能指针类型包括： std::unique_ptr: 独占所有权，一个对象只能被一个unique_ptr所管理，不能被拷贝，只能通过移动语义转移所有权。 std::shared_ptr: 共享所有权，多个shared_ptr可以同时管理同一个对象，当最后一个引用销毁时，内存才被释放。 std::weak_ptr: 辅助shared_ptr，不会增加">
<meta property="og:type" content="article">
<meta property="og:title" content="C++八股文">
<meta property="og:url" content="https://val213.github.io/2024/09/15/%E5%B0%B1%E4%B8%9A/%E3%80%90%E5%B0%B1%E4%B8%9A%E3%80%91C++%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="Val-Blog">
<meta property="og:description" content="C++八股文C++智能指针C++标准库中的几种常见智能指针类型包括： std::unique_ptr: 独占所有权，一个对象只能被一个unique_ptr所管理，不能被拷贝，只能通过移动语义转移所有权。 std::shared_ptr: 共享所有权，多个shared_ptr可以同时管理同一个对象，当最后一个引用销毁时，内存才被释放。 std::weak_ptr: 辅助shared_ptr，不会增加">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2024-09-14T16:32:58.664Z">
<meta property="article:modified_time" content="2025-07-03T01:18:29.733Z">
<meta property="article:author" content="Val">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://val213.github.io/2024/09/15/%E5%B0%B1%E4%B8%9A/%E3%80%90%E5%B0%B1%E4%B8%9A%E3%80%91C++%E5%85%AB%E8%82%A1%E6%96%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: Val","link":"Link: ","source":"Source: Val-Blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++八股文',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-03 09:18:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://github.com/val213/image/blob/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230630230143.jpg?raw=true" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">149</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">111</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Val-Blog"><span class="site-name">Val-Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++八股文</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-09-14T16:32:58.664Z" title="Created 2024-09-15 00:32:58">2024-09-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-07-03T01:18:29.733Z" title="Updated 2025-07-03 09:18:29">2025-07-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%89%BE%E4%B8%AA%E7%8F%AD%E4%B8%8A%E5%90%A7/">找个班上吧</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++八股文"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="C-八股文"><a href="#C-八股文" class="headerlink" title="C++八股文"></a>C++八股文</h1><h2 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h2><p>C++标准库中的几种常见智能指针类型包括：</p>
<p><code>std::unique_ptr</code>: 独占所有权，一个对象只能被一个<code>unique_ptr</code>所管理，不能被拷贝，只能通过移动语义转移所有权。</p>
<p><code>std::shared_ptr</code>: 共享所有权，多个<code>shared_ptr</code>可以同时管理同一个对象，当最后一个引用销毁时，内存才被释放。</p>
<p><code>std::weak_ptr</code>: 辅助<code>shared_ptr</code>，不会增加引用计数，避免循环引用（内存泄漏问题），通常用于打破 shared_ptr 之间的环状依赖。</p>
<p>这些智能指针的核心作用是自动管理动态分配的内存，使得程序员不必手动释放内存，避免内存泄漏等问题。</p>
<ol>
<li>Rust中的引用类型简介<br>Rust中没有智能指针的概念，但它有一套独特的所有权机制和引用类型来管理内存。常见的引用类型包括：</li>
</ol>
<p>引用（&amp; 和 &amp;mut）: 借用机制，用于临时访问数据而不转移所有权。&amp;代表不可变引用，&amp;mut代表可变引用。</p>
<p>Box<T>: 类似于C++的<code>unique_ptr</code>，表示堆上分配的单一所有权。只有拥有<code>Box</code>的地方能销毁这个堆内存。</p>
<p>Rc<T>: 类似于C++的<code>shared_ptr</code>，允许多个所有者共享同一个数据。Rc用于单线程环境中。</p>
<p>Arc<T>: 类似于Rc，但用于<code>多线程</code>环境。Arc是<code>原子引用计数</code>的，保证跨线程安全。</p>
<p>Weak<T>: 类似于C++的<code>weak_ptr</code>，辅助Rc或Arc，用于<code>避免循环引用</code>。<br>在 C++ 和 Rust 中，<code>weak_ptr</code> 和 <code>Weak&lt;T&gt;</code> 分别用于避免循环引用问题。循环引用会导致内存泄漏，因为引用计数器无法降到零，从而导致对象无法被释放。<code>weak_ptr</code>/<code>Weak&lt;T&gt;</code> 不会增加引用计数，因此不会阻止对象被销毁。</p>
<ol>
<li>相似之处</li>
</ol>
<ul>
<li>所有权与自动内存管理:<br>Rust和C++的核心相似之处是都通过所有权的概念实现自动内存管理。Rust的Box<T>和C++的unique_ptr都表示对资源的独占所有权，自动在对象不再使用时释放内存。<br>C++的shared_ptr和Rust的Rc/Arc则都用于共享资源的场景，并通过引用计数（reference counting）来决定何时释放内存。</li>
<li>弱引用:<br>C++的weak_ptr与Rust的Weak<T>功能相似，都是为了避免共享资源时的循环引用问题，防止内存泄漏。</li>
</ul>
<ol>
<li>不同之处</li>
</ol>
<ul>
<li>语言机制:<br>C++中的智能指针是库中的工具，程序员需要手动选择并使用智能指针管理内存。C++没有强制性的所有权检查或引用规则。</li>
</ul>
<p>Rust的所有权系统是内置在语言中的，编译器通过<code>借用检查器</code>（<code>borrow checker</code>）在编译期严格保证内存安全，强制程序员遵循所有权规则。</p>
<ul>
<li>可变性和借用检查:<br>Rust通过 <code>&amp;</code> 和 <code>&amp;mut</code> <strong>引入了明确的可变性借用规则，编译期保证同一时刻只能有一个可变引用或者多个不可变引用</strong>。这是Rust防止数据竞争和悬垂指针的一个关键机制。</li>
</ul>
<p>C++的智能指针没有类似的编译时检查机制。虽然 <code>shared_ptr</code> 和 <code>weak_ptr</code> 可以用来共享资源，但没有Rust那样严格的规则来防止多线程竞争等问题，程序员需要自行保证线程安全。</p>
<ul>
<li>多线程安全:<br>Rust中的 <code>Arc</code> 是线程安全的，保证了引用计数的原子性，适合在多线程环境中共享数据。</li>
</ul>
<p>C++中的 <code>shared_ptr</code> 在多线程环境中是<code>非线程安全</code>的，<strong>必须手动添加锁或使用其他同步机制</strong>。</p>
<ul>
<li>内存管理方式:<br>Rust通过<strong>编译期静态检查内存的生命周期，减少了运行时开销</strong>。大部分的所有权和借用问题在编译时被检测到，避免了潜在的运行时错误。</li>
</ul>
<p><strong>C++的智能指针则是在运行时进行引用计数和内存管理</strong>。这意味着在性能上，Rust的机制可能更高效，尤其是在没有共享引用的场景下。</p>
<ol>
<li>总结</li>
</ol>
<p>在C++中，智能指针是一种帮助程序员更好地管理内存的工具，但它们仍然依赖程序员主动使用和遵循。Rust则将内存管理机制直接融入到了语言的核心设计中，通过所有权系统和借用检查器从编译时就强制保证了内存的安全性。</p>
<p>相似性：两者都提供了工具来管理动态内存，防止内存泄漏和悬垂指针（通过引用计数和弱引用）。</p>
<p>不同点：Rust具有更严格的编译期检查机制，能防止数据竞争和引用问题，而C++的智能指针需要运行时的引用计数，且没有内置的可变性检查。</p>
<h2 id="C-中内存分配情况"><a href="#C-中内存分配情况" class="headerlink" title="C++ 中内存分配情况"></a>C++ 中内存分配情况</h2><ul>
<li>栈：由编译器管理分配和回收，存放局部变量和函数参数。</li>
<li>堆：由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，空间较⼤，但可能会出现内存泄漏和空闲碎片的情况。</li>
<li>全局/静态存储区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。</li>
<li>常量存储区：存储常量，一般不允许修改。</li>
<li>代码区：存放程序的⼆进制代码。</li>
</ul>
<h2 id="C-和-Java-区别（语言特性，垃圾回收，应用场景等）"><a href="#C-和-Java-区别（语言特性，垃圾回收，应用场景等）" class="headerlink" title="C++ 和 Java 区别（语言特性，垃圾回收，应用场景等）"></a>C++ 和 Java 区别（语言特性，垃圾回收，应用场景等）</h2><ul>
<li>指针：Java 语⾔让程序员没法找到指针来直接访问内存，没有指针的概念，并有内存的⾃动管理功能，从而有效的防止了 C++ 语⾔中的指针操作失误的影响。但并非 Java 中没有指针，JVM 内部中还是用了指针，保证了 Java 程序的安全。</li>
<li>多继承：C++ ⽀持多继承但 Java 不⽀持，但支持一个类继承多个接⼝，实现 C++ 中多继承的功能，⼜避免<br>了 C++ 的多继承带来的不便。</li>
<li>数据类型和类：Java 是完全面向对象的语⾔，所有的函数和变量必须是类的一部分。除了基本数据类型之外，其余的都作为类对象，对象将数据和方法结合起来，把它们封装在类中，这样每个对象都可以实现自己的特点和行为。</li>
</ul>
<p>Java 中取消了 C++ 中的 struct 和 union 。</p>
<ul>
<li>自动内存管理：Java 程序中所有对象都是用 new 操作符建立在内存堆栈上，Java 自动进行无用内存回收操作，不需要程序员进行手动删除。而 C++ 中必须由程序员释放内存资源，增加了程序设计者的负担。<br>Java 中当一个对象不再被用到时， 无用内存回收器将给他们加上标签。Java 里无用内存回收程序是以线程方式在后台运行的，利用空闲时间工作来删除。</li>
<li><p>Java 不⽀持操作符重载。操作符重载被认为是 C++ 的突出特性。</p>
</li>
<li><p>Java 不支持预处理功能。C++ 在编译过程中都有一个预编译阶段，Java 没有预处理器，但它提供了 import 与 C++ 预处理器具有类似功能。</p>
</li>
<li><p>类型转换：C++ 中有数据类型隐含转换的机制，Java 中需要限时强制类型转换。</p>
</li>
<li><p>字符串：C++中字符串是以 Null 终⽌符代表字符串的结束，而 Java 的字符串 是用类对象（string 和<br>stringBuffer）来实现的。</p>
</li>
<li>Java 中不提供 goto 语句，虽然指定 goto 作为关键字，但不支持它的使用，使程序简洁易读。</li>
<li>Java 的异常机制用于捕获例外事件，增强系统容错能力。</li>
</ul>
<h2 id="说一下-const-修饰指针如何区分？"><a href="#说一下-const-修饰指针如何区分？" class="headerlink" title="说一下 const 修饰指针如何区分？"></a>说一下 const 修饰指针如何区分？</h2><p>下⾯都是合法的声明，但是含义⼤不同：</p>
<blockquote>
<ul>
<li>const int * p1; //指向整形常量的指针，它指向的值不能修改</li>
<li>int * const p2; //指向整形的常ᰁ指针 ，它不能在指向别的变量，但指向（变量）的值可以修改。 </li>
<li>const int *const p3; //指向整形常量 的 常量指针 。它既不能再指向别的常量，指向的值也不能修改。<br>理解这些声明的技巧在于，查看关键字const右边来确定什么被声明为常量，如果该关键字的右边是类型，则值是<br>常量；如果关键字的右边是指针变量，则指针本身是常量。</li>
</ul>
</blockquote>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>从定义和用途两方面来说下理解：<br>首先是定义：函数指针是指向函数的指针变量。函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这⾥是指向函数。</p>
<p>在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。<br>其次是用途：调用函数和做函数的参数，比如回调函数。<br>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">fun</span><span class="params">(<span class="type">char</span> * p)</span> </span>&#123;…&#125; <span class="comment">// 函数fun</span></span><br><span class="line"><span class="type">char</span> * (*pf)(<span class="type">char</span> * p); <span class="comment">// 函数指针pf</span></span><br><span class="line">pf = fun; <span class="comment">// 函数指针pf指向函数fun</span></span><br><span class="line"><span class="built_in">pf</span>(p); <span class="comment">// 通过函数指针pf调用函数fun</span></span><br></pre></td></tr></table></figure></p>
<h2 id="堆和栈区别"><a href="#堆和栈区别" class="headerlink" title="堆和栈区别"></a>堆和栈区别</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>由编译器进⾏管理，在需要时由编译器⾃动分配空间，在不需要时候自动回收空间，一般保存的是局部变量和函数参数等。<br>连续的内存空间，在函数调用的时候，首先入栈的主函数的下一条可执行指令的地址，然后是函数的各个参数。<br>大多数编译器中，<strong>参数是从右向左入栈</strong>（这种顺序是为了让程序员在使用C/C++的“函数参数长度可变”这个特性时更方便。如果是从左向右压栈，第一个参数（即描述可变参数表各变类量型的那个参数）将被放在栈底，由于可变参的函数第一步就需要解析可变参数表的各参数类型，即第一步就需要得到上述参数，因此，将它放在栈底是很不方便的。）本次函数调用结束时，局部变量先出栈，然后是参数，最后是栈顶指针最开始存放的地址，程序由该点继续运行，不会产⽣碎片。<br>栈是高地址向低地址扩展，栈低高地址，空间较小。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>由程序员管理，需要手动 new malloc delete free 进⾏分配和回收，如果不回收的话，会造成内存泄漏的问题。<br>不连续的空间，实际上系统中有一个空闲链表，当有程序申请的时候，系统遍历空闲链表找到第一个⼤于等于申请大小的空间分配给程序，一般在分配程序的时候，也会空间头部写⼊内存大小，方便 delete 回收空间大小。当然如果有剩余的，也会将剩余的插⼊到空闲链表中，这也是产⽣内存碎⽚的原因。<br>堆是低地址向高地址扩展，空间交⼤，较为灵活。</p>
<h2 id="new-delete-，malloc-free-区别"><a href="#new-delete-，malloc-free-区别" class="headerlink" title="new / delete ，malloc / free 区别"></a>new / delete ，malloc / free 区别</h2><p>都可以用来在堆上分配和回收空间。<strong>new /delete 是操作符，malloc/free 是库函数</strong>。<br><strong>执行 new 实际上有两个过程</strong>：</p>
<ol>
<li>分配未初始化的内存空间（<strong>malloc</strong>）；</li>
<li>使用对象的<strong>构造函数</strong>对空间进行初始化；返回空间的首地址。</li>
</ol>
<p>如果在第一步分配空间中出现问题，则抛出  <code>std::bad_alloc</code> 异常，或被某个设定的异常处理函数捕获处理；如果在第⼆步构造对象时出现异常，则自动调用 delete 释放内存。</p>
<p><strong>执行 delete 实际上也有两个过程</strong>：</p>
<ol>
<li>使用析构函数对对象进行析构；</li>
<li>回收内存空间（free）。</li>
</ol>
<p>以上也可以看出 new 和 malloc 的区别，<strong>new 得到的是经过初始化的空间，而且 malloc 得到的是未初始化的空间</strong>。<br>所以 <strong>new 是 new 一个类型，而 malloc 则是malloc 一个字节长度的空间</strong>。delete 和 free 同理，delete 不仅释放空间还析构对象，delete 一个类型，free 一个字节长度的空间。</p>
<p>为什么有了 malloc／free 还需要 new／delete？因为<strong>对于非内部数据类型， malloc／free 无法满足动态对象的要求。对象在创建的同时需要自动调用构造函数，对象在消亡以前要自动调用析构函数。</strong>由于 mallo／free 是库函数不是运算符，<strong>不在编译器控制权限之内，不能够把执行的构造函数和析构函数的任务强加于</strong> malloc／free，所以有了 new／delete 操作符。</p>
<ul>
<li>new 和 new[] 是类型安全的，不需要进行类型转换。</li>
<li><p>malloc 返回 void*，需要进行类型转换。</p>
</li>
<li><p>new[] 和 delete[] 专门用于数组的分配和释放。</p>
</li>
<li><p>malloc 和 free 没有专门的数组分配和释放函数。</p>
</li>
<li><p>new 和 new[] 在分配失败时会抛出 std::bad_alloc 异常。</p>
</li>
<li>malloc 在分配失败时返回 NULL。</li>
</ul>
<h2 id="volatile-和-extern-关键字"><a href="#volatile-和-extern-关键字" class="headerlink" title="volatile 和 extern 关键字"></a>volatile 和 extern 关键字</h2><h3 id="volatile-三个特性"><a href="#volatile-三个特性" class="headerlink" title="volatile 三个特性"></a>volatile 三个特性</h3><ul>
<li>易变性：在汇编层⾯反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的 volatile 变量的寄存器内容，而是重新从内存中读取。</li>
<li>不可优化性：volatile 告诉编译器，不要对我这个变量进⾏各种激进的优化，甚⾄将变量直接消除，保证程序员写在代码中的指令，一定会被执⾏。<br>顺序性：能够保证 volatile 变量之间的顺序性，编译器不会乱序优化。<h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3>在 C 语⾔中，修饰符 extern 用在变量或者函数的声明前，用来说明 “此变量/函数是在别处定义的，要在此处引用”。<br>注意 extern 声明的位置对其作用域也有关系，如果是在 main 函数中进行声明的，则只能在 main 函数中调用，<strong>在其它函数中不能调用</strong>。其实要调用其它⽂件中的函数和变量，只需把该文件用 #include 包含进来即可，为啥要用 extern？<strong>因为 extern 会加速程序的编译过程，这样能节省时间</strong>。</li>
</ul>
<p>在 C++ 中 extern 还有另外一种作用，<strong>用于指示 C 或者 C＋＋函数的调用规范。比如在 C＋＋ 中调用 C 库函数，就需要在 C＋＋ 程序中用 extern “C” 声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用 C 函数规范来链接。主要原因是 C＋＋ 和 C 程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。</strong></p>
<h3 id="define-和-const-区别（编译阶段、安全性、内存占用等）"><a href="#define-和-const-区别（编译阶段、安全性、内存占用等）" class="headerlink" title="define 和 const 区别（编译阶段、安全性、内存占用等）"></a>define 和 const 区别（编译阶段、安全性、内存占用等）</h3><p>对于 define 来说，宏定义实际上是在预编译阶段进行处理，没有类型，也就没有类型检查，仅仅做的是遇到宏定义进⾏字符串的展开，遇到多少次就展开多少次，而且这个简单的展开过程中，很容易出现边界效应，达不到预期的效果。因为 define 宏定义仅仅是展开，因此<strong>运行时系统并不为宏定义分配内存</strong>，但是从汇编 的角度来讲，define 却<strong>以立即数的方式保留了多份数据的拷贝</strong>。</p>
<p>对于 const 来说，const 是在编译期间处理的，const 有类型，也有类型检查，<strong>程序运行时系统会为 const 常量分配内存</strong>，而且<strong>从汇编的角度讲，const 常量在出现的地方保留的是真正数据的内存地址，只保留了一份数据的拷贝</strong>，省去了不必要的内存空间。而且，有时编译器不会为普通的 const 常量分配内存，而是<strong>直接将 const 常量添加到符号表中</strong>，省去了读取和写⼊内存的操作，效率更⾼。</p>
<h2 id="虚函数相关（虚函数表，虚函数指针），虚函数的实现原理"><a href="#虚函数相关（虚函数表，虚函数指针），虚函数的实现原理" class="headerlink" title="虚函数相关（虚函数表，虚函数指针），虚函数的实现原理"></a>虚函数相关（虚函数表，虚函数指针），虚函数的实现原理</h2><p>构造函数不能为虚函数。原因有两个：</p>
<ul>
<li>一是构造函数在对象构造时调用，<strong>对象构造时虚函数表还没有构造</strong>，所以不能为虚函数；</li>
<li>二是<strong>构造函数是静态的，虚函数是动态绑定的</strong>，构造函数构造对象实例的时候，对象的类型还没有确定，无法决定是使用什么函数，静态函数不能是虚函数。</li>
</ul>
<h3 id="虚函数指针和虚函数表存放在哪里？"><a href="#虚函数指针和虚函数表存放在哪里？" class="headerlink" title="虚函数指针和虚函数表存放在哪里？"></a>虚函数指针和虚函数表存放在哪里？</h3><ul>
<li><strong>虚函数指针的位置是在对象的内存空间的最前面4个字节</strong>，具体在内存的哪个区域取决于对象是创建在栈上还是堆上。</li>
<li><strong>虚函数表是在代码段，是全局的，存放的是虚函数的地址。</strong></li>
</ul>
<p>⾸先我们来说一下，C++中多态的表象是，在基类的函数前加上 <strong>virtual</strong> 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数，如果是基类，就调用基类的函数。</p>
<p><strong>实际上，当一个类中包含虚函数时，编译器会为该类生成一个虚函数表，保存该类中虚函数的地址</strong>，同样，派生类继承基类，派生类中自然一定有虚函数，所以编译器也会为派生类生成自己的虚函数表。当我们定义一个派生类对象时，编译器检测该类型有虚函数，所以为这个派生类对象生成一个虚函数指针，指向该类型的虚函数表，<strong>这个虚函数指针的初始化是在构造函数中完成的</strong>。</p>
<p>后续如果有一个基类类型的指针，指向派生类，那么当调用虚函数时，就会根据<strong>所指真正对象的虚函数表指针去寻找虚函数的地址</strong>，也就可以调用派生类的虚函数表中的虚函数以此实现多态。</p>
<h3 id="非-virtual-的多态"><a href="#非-virtual-的多态" class="headerlink" title="非 virtual 的多态"></a>非 virtual 的多态</h3><p>如果基类中没有定义成 virtual，那么进行<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base B;</span><br><span class="line">Derived D;</span><br><span class="line">Base *p = D;</span><br><span class="line">p-&gt;<span class="built_in">function</span>();</span><br></pre></td></tr></table></figure><br>这种情况下调用的则是 Base 中的 function()。<strong>因为基类和派生类中都没有虚函数的定义，那么编译器就会认为不用留给动态多态的机会</strong>，就事先进行函数地址的绑定（早绑定），详述过程就是，定义了一个派生类对象，首先要构造基类的空间，然后构造派生类的自身内容，形成一个派生类对象，那么在进行类型转换时，直接截取基类的部分的内存，编译器认为类型就是基类，那么（函数符号表［不同于虚函数表的另一个表］中）绑定的函数地址也就是基类中函数的地址，所以执行的是基类的函数。</p>
<h3 id="对于派生类来说，编译器建立虚函数表的过程其实一共是三个步骤："><a href="#对于派生类来说，编译器建立虚函数表的过程其实一共是三个步骤：" class="headerlink" title="对于派生类来说，编译器建立虚函数表的过程其实一共是三个步骤："></a>对于派生类来说，编译器建立虚函数表的过程其实一共是三个步骤：</h3><p>拷贝基类的虚函数表，如果是多继承，就拷贝每个有虚函数的基类的虚函数表。</p>
<p>当然还有一个基类的虚函数表和派生类自身的虚函数表共用了一个虚函数表，也称为某个基类为派生类的主基类。</p>
<p>查看派生类中是否有重写基类中的虚函数， 如果有，就替换成已经重写的虚函数地址；查看派生类是否有自己的虚函数，如果有，就追加自身的虚函数到自身的虚函数表中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Derived *pd = <span class="keyword">new</span> <span class="built_in">D</span>(); <span class="comment">// pd 指向 D 类的对象</span></span><br><span class="line">B *pb = pd;            <span class="comment">// pb 指向 D 类的对象</span></span><br><span class="line">C *pc = pd;            <span class="comment">// pc 指向 D 类的对象</span></span><br><span class="line">pb-&gt;<span class="built_in">function</span>();        <span class="comment">// 调用 D 类对象的 B 类部分的 function() 方法</span></span><br><span class="line">pc-&gt;<span class="built_in">function</span>();        <span class="comment">// 调用 D 类对象的 C 类部分的 function() 方法</span></span><br></pre></td></tr></table></figure>
<p>其中 pb，pd，pc 的指针位置是不同的，要注意的是派生类的自身的内容要追加在主基类的内存块后。</p>
<h3 id="析构函数一般写成虚函数的原因"><a href="#析构函数一般写成虚函数的原因" class="headerlink" title="析构函数一般写成虚函数的原因"></a>析构函数一般写成虚函数的原因</h3><p>直观的讲：是为了降低内存泄漏的可能性。</p>
<p>举例来说就是，一个基类的指针指向一个派生类的对象，在使用完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那么编译器根据指针类型就会认为当前对象的类型是基类，调用基类的析构函数 （该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执行基类的析构，派生类的自身内容将无法被析构，造成内存泄漏。</p>
<p>如果基类的析构函数定义成虚函数，<strong>那么编译器就可以根据实际对象，执行派生类的析构函数，再执行基类的析构函数，成功释放内存</strong>。</p>
<h2 id="char-a-char-a-char-a-char-char-a-之间的区别"><a href="#char-a-char-a-char-a-char-char-a-之间的区别" class="headerlink" title="char a,char a[],char a,char [],char  a 之间的区别"></a>char a,char a[],char <em>a,char </em>[],char <em> </em>a 之间的区别</h2><ul>
<li>char a<br> 定义了一个存储空间，存储的是一个字符（char 类型的变量），占用一个字节的空间。</li>
<li>char a[]<ul>
<li>定义了一个数组，数组中的每个元素都是字符类型，占用一个字节的空间。</li>
</ul>
</li>
<li>char <em>a<br> 对于 char </em>a 来说，a 是一个指针，指向一个字符串的首地址，字符串以 ‘\0’ 结尾，占用 4 个字节的空间。<br> char s[] 的 s 和 char *a 的 a 都是指向字符串的首地址，可以有 a = s，但是不能有 s = a。因为创建数组的时候，系统会为数组 s 分配一块内存，而 a 只是一个空指针，不能将非空的地址指向空指针。</li>
<li>char *a[]<ul>
<li>的优先级低于 []，所以要先看 []再看 <code>*</code>，具体来说，a 是一个指向 <code>char*</code> 类型的数组的指针。这个数组中的每个元素都是一个指向字符的指针。</li>
</ul>
</li>
<li>char <em> </em>a<br> 两个 <code>*</code> 优先级相同，所以从右往左看，即 char<em>(</em>a)，<code>char **</code>a 是一个指向字符指针的指针。具体来说，它是一个指向 <code>char*</code> 类型的指针的指针。</li>
</ul>
<h2 id="C-内存布局-程序分段"><a href="#C-内存布局-程序分段" class="headerlink" title="C++内存布局/程序分段"></a>C++内存布局/程序分段</h2><p>也可以叫做<strong>进程逻辑地址空间</strong></p>
<p>内存从上到下分别是：<br>用户态</p>
<ul>
<li>栈 stack |高地址|</li>
<li>堆 heap</li>
<li>bss 段</li>
<li>data 段</li>
<li>代码段text |低地址|<h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3></li>
<li><p>栈：保存函数的局部变量，参数以及返回值。在函数调用后，系统会清楚栈上保存的栈帧和局部变量，函数参数等信息。栈是从高到低增长的。</p>
</li>
<li><p>堆：动态内存分配的都放在堆上。堆是从低到高的。</p>
</li>
<li><p>bss段：（Block Started by Symbol）存放程序<strong>中未初始化的全局变量</strong>的一块内存区域，在程序载入时由内核置为0。</p>
</li>
<li><p>data 段：<strong>static 变量和所有初始化的全局变量都在 data 段</strong>中。</p>
</li>
<li><p>bss 段和 data 段都是<strong>静态内存分配，也就是说在编译的时候自动分配的</strong>。</p>
</li>
<li><p>bss 和 data 段也有一种说法合起来叫数据段，有三种类型：</p>
<ul>
<li>只读数据段，常量与 const 修饰的全局变量</li>
<li>可读可写数据段，存放初始化的全局变量和 static 变量</li>
<li>bss段，存放未初始化的全局变量</li>
</ul>
</li>
<li>text段：代码段，text段在内存中被映射为只读，但.data和.bss是可写的。由编译器在编译连接时自动计算的，当你在链接定位文件中将该符号放置在代码段后，那么该符号表示的值就是代码段大小，编译连接时，该符号所代表的值会自动代入到源程序中。<blockquote>
<p>这里说的符号是指编译器在编译和链接过程中生成的标识符，用于表示特定的内存地址或段的大小。例如，编译器可能会生成一个符号来表示代码段的起始地址或大小，这些符号在链接过程中会被替换为实际的内存地址或大小值。</p>
</blockquote>
</li>
</ul>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="static对于变量"><a href="#static对于变量" class="headerlink" title="static对于变量"></a>static对于变量</h3><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><ul>
<li>在局部变量之前加上关键字 static，局部变量就被定义成为一个<strong>局部静态变量</strong>。</li>
<li>内存中的位置：data 段</li>
<li>初始化：局部的静态变量只能被初始化一次</li>
<li>作用域：作用域仍为<strong>局部作用域</strong>，当定义它的函数或者语句块结束的时候，作用域随之结束。</li>
</ul>
<p><strong>当 static 用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域</strong>。</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。</p>
<ul>
<li>内存中的位置：<strong>静态存储区（静态存储区在整个程序运行期间都存在）</strong></li>
<li>初始化：未经初始化的全局静态变量会被程序自动初始化为 0</li>
<li>作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。(只能在本文件中存在和使用)<br><strong>全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式</strong>。两者的区别在于<strong>非静态全局变量的作用域是整个源程序</strong>， <strong>当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的（在其他源文件中使用时加上extern关键字重新声明即可）</strong>。 <strong>而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它</strong>。</li>
</ul>
<h3 id="static-对于函数"><a href="#static-对于函数" class="headerlink" title="static 对于函数"></a>static 对于函数</h3><p>修饰普通函数，表明函数的作用范围，<strong>仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。（和全局变量一样限制了作用域而已）</strong></p>
<h3 id="static对于类"><a href="#static对于类" class="headerlink" title="static对于类"></a>static对于类</h3><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><ul>
<li>用 static 修饰类的数据成员实际使其成为<strong>类的全局变量</strong>，会<strong>被类的所有对象共享，包括派生类的对象。</strong></li>
<li>因此，<strong>static 成员变量必须在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用 const 修饰 static 数据成员在类内初始化</strong>。</li>
</ul>
<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ul>
<li>用 static 修饰成员函数，<strong>使这个类只存在这一份函数，所有对象共享该函数，不含 this 指针</strong>。</li>
<li><strong>静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问</strong>。</li>
<li>static和const可以同时修饰成员函数吗?</li>
</ul>
<p>答：不可以。C++ 编译器在实现 const 的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数 <code>const this*</code>。但当一个成员为 static 的时候，该函数是没有 this 指针的。也就是说此时 const 的用法和 static 是冲突的。两者的语意是矛盾的。static 的作用是表示<strong>该函数只作用在类型的静态变量</strong>上，与类的实例没有关系；而 const 的作用是<strong>确保函数不能修改类的实例的状态</strong>，与类型的静态变量没有关系。因此不能同时用它们。</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h4 id="const-与指针"><a href="#const-与指针" class="headerlink" title="const 与指针"></a>const 与指针</h4><h2 id="static-初始化时机和线程安全问题"><a href="#static-初始化时机和线程安全问题" class="headerlink" title="static 初始化时机和线程安全问题"></a>static 初始化时机和线程安全问题</h2><h2 id="C-局部静态变量"><a href="#C-局部静态变量" class="headerlink" title="C++ 局部静态变量"></a>C++ 局部静态变量</h2><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><h2 id="变量存储类"><a href="#变量存储类" class="headerlink" title="变量存储类"></a>变量存储类</h2><p>C++的变量存储类指的是变量的存储方式、生命周期和可见性。主要有以下几种存储类：</p>
<ol>
<li><code>auto</code>：自动存储类，默认存储类，局部变量。</li>
<li><code>register</code>：寄存器存储类，建议将变量存储在CPU寄存器中。</li>
<li><code>static</code>：静态存储类，变量在程序的生命周期内保持存在。</li>
<li><code>extern</code>：外部存储类，引用其他文件中的全局变量。</li>
<li><code>mutable</code>：可变存储类，允许在const对象中修改成员变量。</li>
</ol>
<h2 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h2><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><ul>
<li>静态链接是指在<strong>编译阶段</strong>将所有依赖的库（如标准库或第三方库）和程序代码链接在一起，形成一个完全独立的可执行文件。<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4></li>
<li>独立性：生成的可执行文件无需依赖外部库，拷贝到任何地方都可以运行。</li>
<li>文件体积大：因为所有依赖库的代码都嵌入了可执行文件中，导致体积较大。</li>
<li>更新成本高：库代码嵌入后，如果依赖库有更新，必须重新编译程序。</li>
<li>加载地址固定：程序加载时，代码的内存地址是确定的。<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4></li>
<li>不受运行时环境的依赖，适用于没有动态链接支持的环境（如某些嵌入式系统）。</li>
<li>运行速度稍快（无需动态加载和符号解析）。<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4></li>
<li>安全性较差：缺少地址随机化，易受攻击者利用。</li>
<li>维护复杂：每次库更新都需要重新编译程序。</li>
<li>内存浪费：多个程序的静态链接会导致库代码重复加载，占用更多内存。<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3>动态链接在<strong>运行时</strong>加载依赖库（通常是动态共享对象，简称 DSO，例如 .so 文件）。可执行文件本身只包含必要的接口调用信息，实际实现保存在动态库中。</li>
</ul>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>依赖库动态加载：运行时加载库代码，按需解析符号。</li>
<li>内存共享：多个进程共享库代码的物理内存。</li>
<li>地址随机化支持：动态库加载地址可以随机化，增强安全性。<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4></li>
<li>更新灵活：只需更新动态库文件，无需重新编译程序。</li>
<li>资源利用率高：共享库占用的内存可以被多个进程复用。</li>
<li>更强的功能扩展：支持在运行时加载模块，如LD_PRELOAD、NSS。<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4></li>
<li>运行时对外部环境有依赖，可能因缺失动态库或版本不符导致程序无法运行。</li>
<li>首次加载时需要解析符号和绑定库，启动速度略慢。</li>
</ul>
<h3 id="静态链接还是动态链接？文章导读：《Static-Linking-Considered-Harmful》"><a href="#静态链接还是动态链接？文章导读：《Static-Linking-Considered-Harmful》" class="headerlink" title="静态链接还是动态链接？文章导读：《Static Linking Considered Harmful》"></a>静态链接还是动态链接？文章导读：<strong>《Static Linking Considered Harmful》</strong></h3><h2 id="这篇文章全面批判了静态链接的使用，论述了动态链接的诸多优越性，核心观点是动态链接在多方面优于静态链接，并建议在开发和部署中尽量避免静态链接。"><a href="#这篇文章全面批判了静态链接的使用，论述了动态链接的诸多优越性，核心观点是动态链接在多方面优于静态链接，并建议在开发和部署中尽量避免静态链接。" class="headerlink" title="这篇文章全面批判了静态链接的使用，论述了动态链接的诸多优越性，核心观点是动态链接在多方面优于静态链接，并建议在开发和部署中尽量避免静态链接。"></a>这篇文章全面批判了静态链接的使用，论述了动态链接的诸多优越性，核心观点是<strong>动态链接在多方面优于静态链接</strong>，并建议在开发和部署中尽量避免静态链接。</h2><h4 id="主要论点"><a href="#主要论点" class="headerlink" title="主要论点"></a><strong>主要论点</strong></h4><h5 id="1-安全性与维护性"><a href="#1-安全性与维护性" class="headerlink" title="1. 安全性与维护性"></a>1. <strong>安全性与维护性</strong></h5><ul>
<li><strong>集中修复问题</strong>：动态链接允许对共享库的更新在一处完成，静态链接则需要重建所有依赖的应用程序，增加维护成本。</li>
<li><strong>地址随机化</strong>：静态链接固定了代码的加载地址，给攻击者提供了便利。动态链接通过随机加载共享库（DSO），增强了安全性。</li>
<li><strong>GPL遵从性</strong>：静态链接可能意外违反开源许可证要求，需要提供程序重新链接的能力。<h5 id="2-性能和资源利用"><a href="#2-性能和资源利用" class="headerlink" title="2. 性能和资源利用"></a>2. <strong>性能和资源利用</strong></h5></li>
<li><strong>物理内存共享</strong>：动态链接允许多个进程共享同一份库代码，减少内存占用。而静态链接的程序会将每个库的副本加载到自己的地址空间，导致重复占用内存。</li>
<li><strong>启动速度</strong>：结合预链接技术，动态链接的启动速度可以媲美静态链接。<h5 id="3-功能性"><a href="#3-功能性" class="headerlink" title="3. 功能性"></a>3. <strong>功能性</strong></h5></li>
<li><strong>支持库的动态加载</strong>：如<code>libc</code>中的某些功能需要动态加载模块（如NSS、国际化支持等），这些模块通常无法在静态链接中正常工作。</li>
<li><strong>调试工具支持</strong>：动态链接支持诸如 <code>ltrace</code>、<code>LD_PRELOAD</code> 等工具，可以动态修改程序行为，便于调试和性能分析。这些工具在静态链接中无法使用。<h5 id="4-跨平台能力"><a href="#4-跨平台能力" class="headerlink" title="4. 跨平台能力"></a>4. <strong>跨平台能力</strong></h5></li>
<li>静态链接表面上看起来更“可移植”，但许多非平凡的程序实际上仍然需要动态链接的支持。</li>
</ul>
<hr>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>作者明确反对静态链接的使用，认为动态链接不仅更高效、安全，还能减少开发和运维负担。<br><strong>推荐做法</strong>：  </p>
<ul>
<li>避免将项目代码分散到过多动态库中，特别是在发布给用户时，将同一项目中高度相关的代码合并成单个大型动态库。</li>
<li>动态库应合理划分：保持开发灵活性的同时，避免将第三方库强行嵌入。</li>
</ul>
<hr>
<h4 id="作者的澄清与建议"><a href="#作者的澄清与建议" class="headerlink" title="作者的澄清与建议"></a><strong>作者的澄清与建议</strong></h4><ul>
<li>作者并非完全反对动态库的拆分，而是主张根据开发和部署场景优化动态库的数量。</li>
<li>在开发中，将代码拆分为多个动态库有助于测试和快速迭代；但在用户部署时，合并动态库可以减少加载时间，提高效率。</li>
</ul>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><ul>
<li><strong>核心观点</strong>：静态链接的劣势明显，从安全性、维护性到性能，动态链接都有显著优势。</li>
<li><strong>适用场景</strong>：动态链接适合绝大多数软件的开发和部署，静态链接仅在极少数场景（如独立的嵌入式系统）才可能有用。</li>
</ul>
<p>如果在实际开发中面临选择，可以参考本文的论点，结合自己的需求权衡动态和静态链接的取舍。</p>
<h2 id="静态联编和动态联编"><a href="#静态联编和动态联编" class="headerlink" title="静态联编和动态联编"></a>静态联编和动态联编</h2><h3 id="静态联编（Static-Binding）"><a href="#静态联编（Static-Binding）" class="headerlink" title="静态联编（Static Binding）"></a>静态联编（Static Binding）</h3><p><strong>静态联编</strong>是指在<strong>编译阶段</strong>确定程序中调用的函数或变量的绑定关系。这意味着程序在编译时已经知道所需的所有函数或变量地址，运行时不会改变这种绑定。</p>
<h4 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h4><ol>
<li><strong>编译时确定</strong>：所有的函数地址或变量的引用在编译阶段完成，生成的可执行文件直接包含这些地址。</li>
<li><strong>运行速度快</strong>：因为绑定关系已经固定，程序运行时无需额外解析或搜索。</li>
<li><strong>灵活性较低</strong>：静态联编不支持运行时根据条件选择具体实现。</li>
</ol>
<h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><strong>高效性</strong>：静态联编消除了运行时绑定的开销，运行速度更快。</li>
<li><strong>简单性</strong>：减少了程序在运行时的复杂性。</li>
</ul>
<h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><strong>不灵活</strong>：无法在运行时根据需要调整行为（例如动态加载模块）。</li>
<li><strong>二进制文件体积大</strong>：所有的依赖都被直接嵌入到可执行文件中，可能增加文件体积。</li>
</ul>
<hr>
<h3 id="动态联编（Dynamic-Binding）"><a href="#动态联编（Dynamic-Binding）" class="headerlink" title="动态联编（Dynamic Binding）"></a>动态联编（Dynamic Binding）</h3><p><strong>动态联编</strong>是指在<strong>运行时</strong>确定函数调用或变量访问的绑定关系。这通常发生在需要通过动态库（DSO）加载函数、或者使用多态和虚函数时。</p>
<h4 id="特点：-3"><a href="#特点：-3" class="headerlink" title="特点："></a>特点：</h4><ol>
<li><strong>运行时确定</strong>：程序在运行时解析和绑定所需的函数地址或变量。</li>
<li><strong>灵活性高</strong>：支持根据运行时的实际情况选择函数或模块。</li>
<li><strong>开销稍大</strong>：因为绑定关系在运行时确定，可能会带来额外的性能开销。</li>
</ol>
<h4 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><strong>灵活性强</strong>：支持多态、动态加载和模块化开发。</li>
<li><strong>节省内存</strong>：动态库可以被多个进程共享，减少整体内存占用。</li>
<li><strong>易于更新</strong>：程序依赖的动态库可以独立更新，无需重新编译主程序。</li>
</ul>
<h4 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><strong>运行时开销</strong>：动态解析可能导致程序启动时间稍长。</li>
<li><strong>依赖环境</strong>：如果运行环境缺少所需的动态库，程序可能无法正常运行。</li>
</ul>
<hr>
<h3 id="对比静态联编和动态联编"><a href="#对比静态联编和动态联编" class="headerlink" title="对比静态联编和动态联编"></a>对比静态联编和动态联编</h3><div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>静态联编</th>
<th>动态联编</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>绑定时间</strong></td>
<td>编译时完成</td>
<td>运行时完成</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td><strong>运行效率</strong></td>
<td>高</td>
<td>略低</td>
</tr>
<tr>
<td><strong>内存利用</strong></td>
<td>无法共享库，占用更多内存</td>
<td>可共享动态库，节省内存</td>
</tr>
<tr>
<td><strong>可维护性</strong></td>
<td>依赖的库更新需重新编译</td>
<td>直接替换动态库即可完成更新</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>嵌入式设备、离线环境</td>
<td>通用软件、多态和插件化系统</td>
</tr>
</tbody>
</table>
</div>
<p>动态联编由于灵活性和扩展性更强，已经成为大多数现代软件开发的主流方式，但在一些对独立性和效率要求较高的场景中，静态联编仍然有其优势。</p>
<h2 id="内联函数和宏定义的区别"><a href="#内联函数和宏定义的区别" class="headerlink" title="内联函数和宏定义的区别"></a>内联函数和宏定义的区别</h2><h2 id="模板和-Concept"><a href="#模板和-Concept" class="headerlink" title="模板和 Concept"></a>模板和 Concept</h2><h3 id="函数模板、类模板、模板特化"><a href="#函数模板、类模板、模板特化" class="headerlink" title="函数模板、类模板、模板特化"></a>函数模板、类模板、模板特化</h3><ol>
<li>函数模板：定义泛型函数，可处理多种数据类型。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">5.5</span>, y = <span class="number">10.1</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; std::endl; <span class="comment">// 输出：10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">max</span>(x, y) &lt;&lt; std::endl; <span class="comment">// 输出：10.1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>类模板：定义泛型类，常用于实现容器或者数据结构<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; elem)</span> </span>&#123; elements.<span class="built_in">push_back</span>(elem); &#125;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T elem = elements.<span class="built_in">back</span>();</span><br><span class="line">        elements.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Stack&lt;<span class="type">int</span>&gt; intStack;</span><br><span class="line">intStack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">intStack.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">std::cout &lt;&lt; intStack.<span class="built_in">pop</span>() &lt;&lt; std::endl; <span class="comment">// 输出：2</span></span><br></pre></td></tr></table></figure></li>
<li>模板特化：为特定类型提供特定实现<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;std::string&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::string&gt; elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> std::string&amp; elem)</span> </span>&#123; elements.<span class="built_in">push_back</span>(elem); &#125;</span><br><span class="line">      <span class="function">std::string <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         std::string elem = elements.<span class="built_in">back</span>();</span><br><span class="line">         elements.<span class="built_in">pop_back</span>();</span><br><span class="line">         <span class="keyword">return</span> elem;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h4></li>
</ol>
<ul>
<li>支持泛型编程，增强代码复用性。</li>
<li>提供了类型安全的接口。</li>
<li>编译时生成专用代码，性能接近手写的类型特定代码。<h4 id="缺点：-4"><a href="#缺点：-4" class="headerlink" title="缺点："></a>缺点：</h4></li>
<li>编译错误信息复杂，调试难度大。</li>
<li>代码膨胀（代码实例化导致二进制文件体积增大）。</li>
<li>不支持直接的运行时多态。<h3 id="C-Concepts"><a href="#C-Concepts" class="headerlink" title="C++ Concepts"></a>C++ Concepts</h3>Concepts是C++20引入的一个特性，用来约束模板参数。它提供了一种声明模板期望类型特性的方式，使得模板代码更清晰且错误信息更易读。</li>
</ul>
<h4 id="为什么需要Concepts？"><a href="#为什么需要Concepts？" class="headerlink" title="为什么需要Concepts？"></a>为什么需要Concepts？</h4><p>模板代码虽然灵活，但对传入的类型几乎没有约束，容易导致编译时错误信息难以理解。Concepts通过约束模板参数：</p>
<ul>
<li>提高可读性：直接明确指定模板的使用范围。</li>
<li>更早发现错误：在模板实例化之前检查参数类型是否符合要求。</li>
<li>提升维护性：文档化了模板参数的要求。</li>
</ul>
<p>concept 的定义和使用如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concept Addable 约束模板参数T必须支持+操作符，且结果可以转换为T类型。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Addable = <span class="built_in">requires</span>(T a, T b) &#123;</span><br><span class="line">    &#123; a + b &#125; -&gt; std::convertible_to&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;Addable T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl;     <span class="comment">// 正确：int符合Addable</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1.1</span>, <span class="number">2.2</span>) &lt;&lt; std::endl; <span class="comment">// 正确：double符合Addable</span></span><br><span class="line">    <span class="comment">// add(&quot;a&quot;, &quot;b&quot;); // 编译错误：string不支持&quot;+&quot;操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>标准库中的 Concepts：<br>C++标准库提供了一些通用的 Concept，例如：</p>
<ul>
<li>std::same_as<T, U>：T和U是相同类型。</li>
<li>std::integral<T>：T是一个整型类型。</li>
<li>std::floating_point<T>：T是一个浮点型类型。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;std::integral T&gt;</span><br><span class="line"><span class="function">T <span class="title">factorial</span><span class="params">(T n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n == <span class="number">0</span>) ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="和-Rust-的-trait-imlp-对比"><a href="#和-Rust-的-trait-imlp-对比" class="headerlink" title="和 Rust 的 trait/imlp 对比"></a>和 Rust 的 trait/imlp 对比</h3><p>C++ 的模板与 Concepts 和 Rust 的 <strong>trait/impl</strong> 都是泛型编程的工具，但它们在设计目标、表达能力和运行时表现等方面有所不同。以下是它们的详细对比：</p>
<hr>
<h4 id="1-基本功能与核心对比"><a href="#1-基本功能与核心对比" class="headerlink" title="1. 基本功能与核心对比"></a><strong>1. 基本功能与核心对比</strong></h4><div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th><strong>C++ 模板</strong></th>
<th><strong>C++ Concepts</strong></th>
<th><strong>Rust trait/impl</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>定义方式</strong></td>
<td>泛型编程，通过模板参数定义通用代码</td>
<td>对模板参数进行约束，提升模板的可读性和错误提示</td>
<td>定义行为接口（trait），通过 <code>impl</code> 为类型实现特定行为</td>
</tr>
<tr>
<td><strong>类型检查</strong></td>
<td><strong>实例化时</strong>检查模板参数是否有效</td>
<td><strong>编译时</strong>约束模板参数是否合法</td>
<td><strong>编译时</strong>检查类型是否实现了对应的 trait</td>
</tr>
<tr>
<td><strong>语法复杂性</strong></td>
<td>灵活但容易导致复杂的错误提示</td>
<td>增加语法约束，错误提示更清晰</td>
<td>语法清晰，trait 提供明确的接口和行为描述</td>
</tr>
<tr>
<td><strong>多态支持</strong></td>
<td>编译时多态，无运行时开销</td>
<td>与模板结合，提供编译时多态</td>
<td>支持编译时多态（泛型）和运行时多态（通过 <code>dyn</code> 动态分发）</td>
</tr>
<tr>
<td><strong>实现方式</strong></td>
<td>模板实例化：按需生成专用代码</td>
<td>扩展模板机制：约束类型</td>
<td>使用 trait：通过行为契约明确定义代码功能</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h4 id="2-具体对比"><a href="#2-具体对比" class="headerlink" title="2. 具体对比"></a><strong>2. 具体对比</strong></h4><h5 id="A-泛型表达能力"><a href="#A-泛型表达能力" class="headerlink" title="A. 泛型表达能力"></a><strong>A. 泛型表达能力</strong></h5><h6 id="C-模板"><a href="#C-模板" class="headerlink" title="C++ 模板"></a><strong>C++ 模板</strong></h6><ul>
<li><strong>非常灵活</strong>：可以接收任何符合模板操作的类型参数。</li>
<li><p><strong>无约束</strong>：默认对模板参数没有类型限制，可能导致复杂的编译错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b; <span class="comment">// 假设 T 支持 +</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缺点：</p>
<ul>
<li>若类型参数不支持 <code>+</code> 运算，编译器在实例化时才会报错，错误信息难以理解。</li>
</ul>
</li>
</ul>
<h6 id="Rust-trait"><a href="#Rust-trait" class="headerlink" title="Rust trait"></a><strong>Rust trait</strong></h6><ul>
<li><p><strong>明确约束</strong>：通过 <code>trait</code> 明确定义类型需要实现哪些行为。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Addable</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: <span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Addable</span> <span class="keyword">for</span> <span class="title class_">i32</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: <span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">self</span> + other</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T: Addable&gt;(a: T, b: T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    a.<span class="title function_ invoke__">add</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类型安全</strong>：</p>
<ul>
<li>如果参数未实现 <code>Addable</code>，编译器在解析泛型时会立即报错。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="B-类型约束机制"><a href="#B-类型约束机制" class="headerlink" title="B. 类型约束机制"></a><strong>B. 类型约束机制</strong></h5><h6 id="C-Concepts-1"><a href="#C-Concepts-1" class="headerlink" title="C++ Concepts"></a><strong>C++ Concepts</strong></h6><ul>
<li><p><strong>静态检查</strong>：</p>
<ul>
<li>通过 <code>concept</code> 明确模板参数的能力，避免不必要的实例化错误。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Addable = <span class="built_in">requires</span>(T a, T b) &#123;</span><br><span class="line">    &#123; a + b &#125; -&gt; std::convertible_to&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;Addable T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>改进模板错误信息</strong>：</p>
<ul>
<li>如果类型参数不满足 <code>Addable</code>，错误信息会直接指出问题所在。</li>
</ul>
</li>
</ul>
<h6 id="Rust-trait-1"><a href="#Rust-trait-1" class="headerlink" title="Rust trait"></a><strong>Rust trait</strong></h6><ul>
<li><p><strong>天然类型约束</strong>：</p>
<ul>
<li>Rust 的泛型自动与 trait 结合使用，不需要额外的语法支持。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a: T, b: T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>灵活性与可扩展性</strong>：</p>
<ul>
<li>Rust 的 trait 支持默认方法、关联类型等高级特性，比 Concepts 更加强大。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="C-多态支持"><a href="#C-多态支持" class="headerlink" title="C. 多态支持"></a><strong>C. 多态支持</strong></h5><h6 id="C-模板-amp-Concepts"><a href="#C-模板-amp-Concepts" class="headerlink" title="C++ 模板 &amp; Concepts"></a><strong>C++ 模板 &amp; Concepts</strong></h6><ul>
<li><p><strong>编译时多态</strong>：</p>
<ul>
<li>模板实例化生成不同的代码版本，没有运行时开销。</li>
<li>只能提供编译时多态，无法支持运行时行为切换。</li>
</ul>
</li>
<li><p><strong>运行时多态依赖虚函数</strong>：</p>
<ul>
<li>如果需要运行时多态，必须通过传统的继承和虚函数机制。</li>
</ul>
</li>
</ul>
<h6 id="Rust-trait-2"><a href="#Rust-trait-2" class="headerlink" title="Rust trait"></a><strong>Rust trait</strong></h6><ul>
<li><p><strong>编译时多态</strong>：</p>
<ul>
<li>泛型函数通过静态分发，在编译时生成具体实现代码。</li>
</ul>
</li>
<li><p><strong>运行时多态</strong>：</p>
<ul>
<li>通过 <code>dyn Trait</code> 实现动态分发，支持运行时行为切换。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">make_sound</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">make_sound</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">speak</span>(animal: &amp;<span class="keyword">dyn</span> Animal) &#123;</span><br><span class="line">    animal.<span class="title function_ invoke__">make_sound</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="D-错误提示与调试"><a href="#D-错误提示与调试" class="headerlink" title="D. 错误提示与调试"></a><strong>D. 错误提示与调试</strong></h5><h6 id="C-模板-1"><a href="#C-模板-1" class="headerlink" title="C++ 模板"></a><strong>C++ 模板</strong></h6><ul>
<li>模板错误信息复杂，尤其在深度嵌套模板时难以调试。</li>
</ul>
<h6 id="C-Concepts-2"><a href="#C-Concepts-2" class="headerlink" title="C++ Concepts"></a><strong>C++ Concepts</strong></h6><ul>
<li>改善了模板错误信息：<ul>
<li>提前检查类型约束，明确指出错误位置。</li>
<li>但仍存在模板实例化阶段的潜在复杂性。</li>
</ul>
</li>
</ul>
<h6 id="Rust-trait-3"><a href="#Rust-trait-3" class="headerlink" title="Rust trait"></a><strong>Rust trait</strong></h6><ul>
<li>错误信息更直观：<ul>
<li>编译器直接报告类型与 trait 的不匹配，提示明确。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-总结与优缺点对比"><a href="#3-总结与优缺点对比" class="headerlink" title="3. 总结与优缺点对比"></a><strong>3. 总结与优缺点对比</strong></h4><div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th><strong>C++ 模板</strong></th>
<th><strong>C++ Concepts</strong></th>
<th><strong>Rust trait/impl</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>灵活性</strong></td>
<td>高，但易产生隐式错误</td>
<td>高，增强了约束能力</td>
<td>高，支持静态和动态分发</td>
</tr>
<tr>
<td><strong>类型安全</strong></td>
<td>无，类型不符合时才报错</td>
<td>强，提前检查约束</td>
<td>强，通过 trait 提供行为契约</td>
</tr>
<tr>
<td><strong>多态性</strong></td>
<td>编译时</td>
<td>编译时</td>
<td>编译时 + 运行时</td>
</tr>
<tr>
<td><strong>错误提示清晰度</strong></td>
<td>差，错误信息复杂</td>
<td>清晰，概念明确</td>
<td>清晰，编译器提示友好</td>
</tr>
<tr>
<td><strong>代码膨胀</strong></td>
<td>是，模板实例化会增加代码体积</td>
<td>是，概念未直接解决此问题</td>
<td>少，静态分发与动态分发平衡</td>
</tr>
<tr>
<td><strong>语法复杂度</strong></td>
<td>低，简单灵活但易滥用</td>
<td>中，约束增加了额外复杂度</td>
<td>低，语法清晰，设计现代</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h5 id="选择场景"><a href="#选择场景" class="headerlink" title="选择场景"></a><strong>选择场景</strong></h5><ul>
<li><strong>C++ 模板</strong>：适合对性能敏感但逻辑简单的泛型代码。</li>
<li><strong>C++ Concepts</strong>：需要类型约束的泛型代码，可读性和调试性要求高的项目。</li>
<li><strong>Rust trait</strong>：泛型代码和行为约束场景，尤其是需要静态与动态分发结合的应用。</li>
</ul>
<h2 id="C-出现的内存问题"><a href="#C-出现的内存问题" class="headerlink" title="C++ 出现的内存问题"></a>C++ 出现的内存问题</h2><ul>
<li>缓冲区溢出</li>
<li>指针悬挂/野指针</li>
<li>重复释放</li>
<li>内存泄漏：程序中分配的内存没有被释放，导致内存泄漏。</li>
<li>new 和 delete 不匹配</li>
<li>内存碎片</li>
</ul>
<h2 id="编译期多态和运行期多态"><a href="#编译期多态和运行期多态" class="headerlink" title="编译期多态和运行期多态"></a>编译期多态和运行期多态</h2><h2 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C++ 异常处理"></a>C++ 异常处理</h2><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h2 id="介绍一下-fork-的流程"><a href="#介绍一下-fork-的流程" class="headerlink" title="介绍一下 fork 的流程"></a>介绍一下 fork 的流程</h2><p><code>fork()</code> 函数是 Unix 和类 Unix 操作系统中用于创建进程的系统调用。它属于进程控制的一部分，用于复制当前进程（称为父进程），创建一个新的子进程。<code>fork()</code> 的基本流程如下：</p>
<ol>
<li><p><strong>调用 fork()</strong>：</p>
<ul>
<li>父进程调用 <code>fork()</code> 函数。</li>
</ul>
</li>
<li><p><strong>系统分配资源</strong>：</p>
<ul>
<li>操作系统为新的子进程分配必要的资源，如内存空间、文件描述符等。</li>
</ul>
</li>
<li><p><strong>复制进程</strong>：</p>
<ul>
<li>操作系统复制父进程的地址空间、堆、栈等内存内容到子进程。这通常涉及到写时复制（Copy-On-Write，COW）技术，以减少内存的复制开销。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li><code>fork()</code> 函数在父进程中返回新创建的子进程的进程ID（PID）。</li>
<li><code>fork()</code> 函数在子进程中返回0。</li>
</ul>
</li>
<li><p><strong>执行流程分支</strong>：</p>
<ul>
<li>父进程和子进程从 <code>fork()</code> 调用之后开始执行不同的代码路径。通常，父进程会使用返回的子进程PID来对子进程进行进一步的操作，如等待子进程结束（<code>wait()</code> 系统调用）。</li>
<li>子进程通常会使用返回的0来确认自己的身份，并执行特定的任务。</li>
</ul>
</li>
<li><p><strong>进程调度</strong>：</p>
<ul>
<li>操作系统的调度器根据调度策略决定哪个进程（父进程或子进程）继续执行。</li>
</ul>
</li>
<li><p><strong>进程终止</strong>：</p>
<ul>
<li>当子进程执行完毕，它会通过 <code>exit()</code> 函数或返回语句来结束自己的执行。</li>
<li>父进程可以通过 <code>wait()</code> 或 <code>waitpid()</code> 函数来等待子进程结束，获取子进程的退出状态。</li>
</ul>
</li>
<li><p><strong>资源回收</strong>：</p>
<ul>
<li>子进程结束后，操作系统会回收其占用的资源，包括内存、文件描述符等。</li>
</ul>
</li>
</ol>
<p><code>fork()</code> 函数的使用需要注意一些问题，比如避免在子进程中进行可能改变父进程状态的操作，以及正确处理 <code>fork()</code> 调用失败的情况（通常返回 -1）。此外，<code>fork()</code> 在多线程程序中的行为可能会更加复杂，因为它可能会创建包含所有线程副本的子进程。</p>
<h2 id="介绍一下-copy-on-write（COW）技术"><a href="#介绍一下-copy-on-write（COW）技术" class="headerlink" title="介绍一下 copy-on-write（COW）技术"></a>介绍一下 copy-on-write（COW）技术</h2><p>写时复制（Copy-On-Write，COW）是一种计算机程序设计中的优化策略，用于减少内存复制的开销。这种技术在创建进程、线程或者进行内存分配时特别有用。写时复制的核心思想是，<strong>只有在原始数据需要被修改时，才进行数据的复制</strong>。</p>
<h3 id="写时复制的工作原理："><a href="#写时复制的工作原理：" class="headerlink" title="写时复制的工作原理："></a>写时复制的工作原理：</h3><ol>
<li><p><strong>共享数据</strong>：</p>
<ul>
<li>当一个进程或者线程需要创建一个新的进程或线程时，它首先会共享其内存空间，而不是立即复制。这意味着新创建的进程或线程最初会使用相同的物理内存页。</li>
</ul>
</li>
<li><p><strong>检测写操作</strong>：</p>
<ul>
<li>操作系统会监控这些共享的内存页。如果检测到任何写操作（即尝试修改这些内存页），操作系统会立即将这些页复制到新的物理内存地址。</li>
</ul>
</li>
<li><p><strong>复制内存页</strong>：</p>
<ul>
<li>当检测到写操作时，操作系统会创建这些内存页的副本，并将副本分配给执行写操作的进程或线程。这样，原始的进程或线程仍然可以访问原始数据，而执行写操作的进程或线程则在修改其自己的数据副本。</li>
</ul>
</li>
<li><p><strong>更新页表</strong>：</p>
<ul>
<li>操作系统更新页表，使得执行写操作的进程或线程的虚拟地址指向新的物理内存地址（即复制后的内存页），而其他进程或线程的虚拟地址仍然指向原始的物理内存地址。</li>
</ul>
</li>
</ol>
<h3 id="写时复制的优点："><a href="#写时复制的优点：" class="headerlink" title="写时复制的优点："></a>写时复制的优点：</h3><ul>
<li><strong>节省内存</strong>：在数据被修改之前，不需要复制整个内存空间，从而节省了内存资源。</li>
<li><strong>提高性能</strong>：减少了不必要的数据复制，可以提高程序的执行效率。</li>
</ul>
<h3 id="写时复制的应用场景："><a href="#写时复制的应用场景：" class="headerlink" title="写时复制的应用场景："></a>写时复制的应用场景：</h3><ol>
<li><strong>进程创建</strong>：在 <code>fork()</code> 系统调用中，写时复制技术可以减少创建子进程时的内存复制开销。</li>
<li><strong>线程创建</strong>：在创建线程时，可以使用写时复制来共享数据，只有在数据需要被修改时才进行复制。</li>
<li><strong>内存分配</strong>：在某些内存分配策略中，写时复制可以用来优化内存的使用和分配。</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><strong>同步问题</strong>：由于多个进程或线程可能共享相同的内存页，因此需要妥善处理同步问题，以避免数据竞争和一致性问题。</li>
<li><strong>性能影响</strong>：虽然写时复制可以减少内存复制的开销，但在高负载或频繁写操作的情况下，可能会增加系统的页错误率，从而影响性能。</li>
</ul>
<p>写时复制是一种有效的内存管理技术，它在需要共享和复制大量数据时提供了一种高效的解决方案。</p>
<h2 id="fork、vfork-和-clone-的区别"><a href="#fork、vfork-和-clone-的区别" class="headerlink" title="fork、vfork 和 clone 的区别"></a>fork、vfork 和 clone 的区别</h2><p><code>fork()</code>, <code>vfork()</code>, 和 <code>clone()</code> 都是 Unix 和类 Unix 操作系统中用于创建进程的系统调用，但它们在创建进程的方式和使用场景上有所不同。</p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><ul>
<li><strong>用途</strong>：<code>fork()</code> 用于创建一个与父进程几乎完全相同的子进程。</li>
<li><strong>内存</strong>：子进程获得父进程数据段、堆和栈的副本。在 <code>fork()</code> 之后，父子进程拥有独立的地址空间，但开始时这些空间的内容是相同的。</li>
<li><strong>行为</strong>：<code>fork()</code> 之后，父进程和子进程从 <code>fork()</code> 调用之后的代码开始独立执行。</li>
<li><strong>返回值</strong>：在父进程中返回子进程的 PID，在子进程中返回 0。</li>
</ul>
<h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork()"></a>vfork()</h3><ul>
<li><strong>用途</strong>：<code>vfork()</code> 用于创建一个子进程，这个子进程与父进程共享地址空间。</li>
<li><strong>内存</strong>：子进程和父进程共享相同的内存空间，直到子进程调用 <code>exec()</code> 系列函数或者退出。这使得 <code>vfork()</code> 比 <code>fork()</code> 更高效，因为它避免了复制父进程的地址空间。</li>
<li><strong>行为</strong>：<code>vfork()</code> 创建的子进程在父进程之前执行，并且子进程应该尽快调用 <code>exec()</code> 系列函数或者退出，以避免对父进程的潜在破坏。</li>
<li><strong>返回值</strong>：与 <code>fork()</code> 类似，父进程中返回子进程的 PID，在子进程中返回 0。</li>
</ul>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><ul>
<li><strong>用途</strong>：<code>clone()</code> 是一个更通用的进程创建机制，它提供了比 <code>fork()</code> 和 <code>vfork()</code> 更多的控制。</li>
<li><strong>内存</strong>：<code>clone()</code> 允许调用者指定是否与父进程共享地址空间。通过设置 <code>CLONE_VM</code> 标志，可以实现与 <code>fork()</code> 相似的行为；如果不设置，则可以实现与 <code>vfork()</code> 相似的行为。</li>
<li><strong>行为</strong>：<code>clone()</code> 允许调用者指定子进程的栈空间和栈内容，以及子进程的调度策略等。</li>
<li><strong>返回值</strong>：在父进程中返回子进程的 PID 或者错误码，在子进程中返回 0。</li>
</ul>
<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ul>
<li><strong>内存共享</strong>：<code>fork()</code> 创建独立的地址空间，<code>vfork()</code> 创建共享地址空间，而 <code>clone()</code> 可以通过标志控制是否共享。</li>
<li><strong>效率</strong>：<code>vfork()</code> 通常比 <code>fork()</code> 更高效，因为它避免了复制父进程的地址空间，但使用时需要小心，以避免对父进程造成影响。<code>clone()</code> 可以根据需要调整，以达到最优的性能。</li>
<li><strong>灵活性</strong>：<code>clone()</code> 提供了最大的灵活性，允许调用者精确控制子进程的创建过程。</li>
</ul>
<p>在实际应用中，选择哪种方式取决于具体的需求和性能考虑。例如，如果需要快速创建一个子进程并且子进程将立即执行一个新的程序，<code>vfork()</code> 或者带有 <code>CLONE_VM</code> 标志的 <code>clone()</code> 可能是更好的选择。如果需要创建一个与父进程完全独立的子进程，<code>fork()</code> 或者不共享地址空间的 <code>clone()</code> 更合适。</p>
<h2 id="介绍一下进程间通信（IPC）的方式"><a href="#介绍一下进程间通信（IPC）的方式" class="headerlink" title="介绍一下进程间通信（IPC）的方式"></a>介绍一下进程间通信（IPC）的方式</h2><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>僵尸进程（Zombie Process）是Linux系统中的一种特殊进程状态。当一个进程完成其执行并退出时，它会向其父进程发送退出信号，父进程应该通过调用<code>wait()</code>或<code>waitpid()</code>函数来获取子进程的退出状态，从而释放子进程占用的资源。如果父进程没有正确地回收子进程的资源，那么子进程虽然已经终止，但仍然会保留在系统中，这种状态的进程被称为僵尸进程。</p>
<p>僵尸进程的危害主要体现在它们会占用系统资源，尤其是进程ID。由于系统能够创建的进程数量是有限的，如果僵尸进程过多，可能会导致系统无法创建新的进程，从而影响系统的正常运行。</p>
<p>僵尸进程的产生通常是因为父进程没有及时回收子进程的资源。这可能是因为父进程在忙于其他任务，或者父进程本身已经退出，没有其他进程来回收子进程的资源。在某些情况下，如果父进程退出，init进程（通常是系统的第一个进程，PID为1）会接管并回收孤儿进程的资源。</p>
<p>处理僵尸进程的方法通常包括：</p>
<ol>
<li>确保父进程调用<code>wait()</code>或<code>waitpid()</code>来回收子进程的资源。</li>
<li>为父进程设置<code>SIGCHLD</code>信号的处理函数，在子进程退出时及时进行资源回收。</li>
<li>如果父进程不关心子进程的退出状态，可以使用<code>signal(SIGCHLD, SIG_IGN)</code>来忽略<code>SIGCHLD</code>信号，让init进程来回收子进程的资源。</li>
</ol>
<p>在Linux系统中，可以使用<code>ps</code>命令结合<code>grep</code>来查找僵尸进程，例如使用<code>ps aux | grep &#39;Z&#39;</code>命令。如果需要杀死僵尸进程，通常的做法是杀死其父进程，因为这样会使得僵尸进程变为孤儿进程，然后由init进程接管并回收资源。如果僵尸进程的父进程是init，那么僵尸进程将自动被回收。</p>
<p>总的来说，僵尸进程是Linux系统中的一种正常现象，通常不会对系统造成太大影响，但如果数量过多，就需要通过上述方法进行处理。</p>
<h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p>C++ 11/14引入了右值引用和移动语义，这两个概念是为了解决传统的左值和右值的问题。在C++中，左值和右值是表达式的属性，它们与赋值操作符的左右位置无关。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>所有表达式的结果不是左值就是右值。</li>
<li>左值(lvalue)是一个函数或者对象实例</li>
<li>失效值(xvalue)是生命期即将结束的对象</li>
<li>广义左值是左值和失效值的统称</li>
<li>右值(rvalue)包括失效值、临时对象和不关联任何对象的值（字面常量）</li>
<li>纯右值是非失效值的右值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[expression] --&gt; B[glvalue]</span><br><span class="line">    A --&gt; C[rvalue]</span><br><span class="line">    B --&gt; D[lvalue]</span><br><span class="line">    B --&gt; E[xvallue]</span><br><span class="line">    C --&gt; F[prvalue]</span><br><span class="line">    C --&gt; E</span><br></pre></td></tr></table></figure>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>右值引用是C++11引入的新特性，用于绑定到右值。右值引用的语法是<code>T&amp;&amp;</code>，其中<code>T</code>是类型。右值引用可以绑定到临时对象、右值和失效值，但不能绑定到左值。而左值引用<code>T&amp;</code>只能绑定到左值。</p>
<p>对一个对象使用右值引用，意味着显式标记这个对象是个右值，可以被转移来优化。同时相当于给他添加了一个临时的名字，生命周期得到了延长，不会在表达式结束时消失，而是和右值引用绑定在了一起。</p>
<p>const T&amp;&amp; 没有意义，因为右值引用的目的是为了转移资源，而const则是为了保护资源不被修改。</p>
<h4 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h4><ul>
<li><code>T&amp; &amp;</code> -&gt; <code>T&amp;</code></li>
<li><code>T&amp; &amp;&amp;</code> -&gt; <code>T&amp;</code></li>
<li><code>T&amp;&amp; &amp;</code> -&gt; <code>T&amp;</code></li>
<li><code>T&amp;&amp; &amp;&amp;</code> -&gt; <code>T&amp;&amp;</code><br>对引用类型TR(左/右引用)进行左引用操作，结果是T&amp;；对引用类型TR(左/右引用)进行右引用操作，结果不变。这条规则是实现转移语义和完美转发的基础。</li>
</ul>
<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><h2 id="自动类型推导"><a href="#自动类型推导" class="headerlink" title="自动类型推导"></a>自动类型推导</h2><p>C++11引入了<code>auto</code>关键字，用于自动推导变量的类型。<code>auto</code>关键字可以根据变量的初始化表达式推导出变量的类型，从而简化代码编写。<code>auto</code>关键字的使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> var = expr;</span><br></pre></td></tr></table></figure>
<p>‘decltype’关键字可以用于获取表达式的类型，通常与<code>auto</code>关键字一起使用，用于推导表达式的类型。<code>decltype</code>关键字的使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expr) var;</span><br></pre></td></tr></table></figure>
<p>decltype 和 sizeof 在技术和用法上非常相似，都是需要编译器在编译期计算类型，但是 sizeof 是在编译期计算类型的大小，而 decltype 是在编译期计算类型。</p>
<p>decltype(expr) 会返回表达式 expr 的类型，包括 const 和引用等限定符。</p>
<h3 id="decltype-auto"><a href="#decltype-auto" class="headerlink" title="decltype(auto)"></a>decltype(auto)</h3><h2 id="惊群效应"><a href="#惊群效应" class="headerlink" title="惊群效应"></a>惊群效应</h2><p>惊群效应（Thundering Herd Problem）是指在多进程或多线程环境中，当多个进程或线程等待同一个事件（如网络连接请求）时，事件发生后会唤醒所有等待的进程或线程，但通常只有一个能够获得事件并进行处理，其余的进程或线程在尝试获取事件失败后会重新进入等待状态。这个过程会导致不必要的上下文切换和系统资源浪费，从而影响系统性能。</p>
<p>在Linux系统中，惊群效应主要出现在网络服务的监听和接受连接的场景。例如，在使用<code>accept</code>函数处理TCP连接时，如果有多个进程在同一个监听socket上调用<code>accept</code>，那么当新的连接请求到达时，所有阻塞在<code>accept</code>上的进程都会被唤醒，但实际上只有一个进程能够成功建立连接，其他进程则需要重新等待。</p>
<p>再举个例子，linux内核中的等待队列，等待队列中的等待节点有两种状态，一种是互斥等待，一种是非互斥等待。如果某个事件一发生，会唤醒对应的等待队列中的所有非互斥等待节点，而如果是互斥等待节点的话，可以选择唤醒所有节点，也可以选择唤醒指定个节点。Pthread线程库里面也有一个很好的例子，pthread_cond_signal与pthread_cond_broadcast，signal只通知一个信号量，而broadcast会通知所有信号量。但是有时候就绪的事件只能满足一个用户，如果选择广播的话就会通知所有用户，然后最终只有一个用户可以得到满足，其他用户还是被阻塞导致不必要的性能浪费。</p>
<p>为了解决惊群效应，可以采取以下措施：</p>
<ol>
<li><p><strong>使用锁机制</strong>：在应用层实现互斥锁，确保同一时间只有一个进程或线程处理事件。例如，Nginx使用<code>accept_mutex</code>来控制对<code>accept</code>调用的访问，从而避免惊群效应。</p>
</li>
<li><p><strong>利用<code>EPOLLEXCLUSIVE</code></strong>：在较新的Linux内核版本中，<code>epoll</code>的<code>EPOLLEXCLUSIVE</code>标志可以用来减少惊群现象，它确保一次只有一个进程被唤醒来处理事件。</p>
</li>
<li><p><strong>使用<code>SO_REUSEPORT</code>套接字选项</strong>：这个选项允许多个进程或线程绑定到同一个端口，内核会负责在它们之间分配传入的连接请求，从而避免惊群效应。</p>
</li>
<li><p><strong>优化进程/线程数量</strong>：合理配置进程或线程的数量，避免过多的并发进程或线程导致频繁的惊群效应。</p>
</li>
<li><p><strong>使用线程池</strong>：通过线程池来管理线程，减少线程竞争和上下文切换，提高资源利用率。</p>
</li>
</ol>
<p>在Linux 2.6版本之后，内核已经解决了<code>accept</code>函数的惊群效应，但<code>epoll</code>的惊群效应仍然可能存在，特别是在多个进程或线程使用<code>epoll_wait</code>监听同一个socket时。Nginx等服务器软件通过内部机制来解决这个问题，以提高性能和资源利用率。</p>
<h2 id="IDT和TSS"><a href="#IDT和TSS" class="headerlink" title="IDT和TSS"></a>IDT和TSS</h2><p>中断描述符表（Interrupt Descriptor Table, IDT）和任务状态段（Task State Segment, TSS）是与x86架构相关的两个重要概念，它们在操作系统的中断处理和任务切换中起着核心作用。</p>
<ol>
<li><p><strong>中断描述符表（IDT）</strong>：</p>
<ul>
<li>IDT是一张由中断门、陷阱门和系统门组成的表，用于存储中断和异常的处理器入口点。</li>
<li>IDT中的每个条目都是一个描述符，包含了中断处理程序或异常处理程序的地址、段选择器以及访问权限等信息。</li>
<li>当CPU响应一个中断或异常时，会使用IDT中的信息来确定应该执行哪个处理程序，以及在哪个特权级下执行。</li>
<li>IDT的条目通常包括中断处理程序、异常处理程序、系统调用处理程序等。</li>
<li>在现代操作系统中，IDT是实现硬件中断、软件中断（如系统调用）和异常处理的关键数据结构。</li>
</ul>
</li>
<li><p><strong>任务状态段（TSS）</strong>：</p>
<ul>
<li>TSS是一种特殊的数据结构，用于存储处理器在执行任务切换时需要的信息。</li>
<li>TSS包含了当前任务的上下文信息，如寄存器值、堆栈指针、程序状态字（Program Status Word, PSW）等。</li>
<li>在多任务操作系统中，每个任务（线程或进程）都有自己的TSS，以便在任务切换时能够保存和恢复任务的状态。</li>
<li>TSS中还可以包含I/O权限位图，用于控制任务对I/O设备的访问权限。</li>
<li>TSS通过任务门（Task Gate）与IDT关联，任务门包含了指向TSS的指针，当执行任务切换指令（如<code>jmp</code>、<code>call</code>、<code>ret</code>等）时，CPU会通过任务门找到相应的TSS，并使用TSS中的信息来完成上下文切换。</li>
</ul>
</li>
</ol>
<p>在现代操作系统中，IDT和TSS是实现中断驱动编程和多任务处理的关键机制。IDT使得操作系统能够定义和处理各种中断和异常，而TSS则使得操作系统能够在任务之间高效地切换，从而实现多任务并发执行。随着操作系统的发展，一些新的机制（如x64架构中的长模式）可能不再使用TSS，而是采用了更高效的任务切换方法。</p>
<h2 id="何在共享内存上使用stl标准库？"><a href="#何在共享内存上使用stl标准库？" class="headerlink" title="何在共享内存上使用stl标准库？"></a>何在共享内存上使用stl标准库？</h2><p>提问者澄清说，他想要的是std::vector的元素都存储在共享内存中，即使是动态添加的新元素也应该存储在共享内存中。</p>
<p>提出了一个解决方案。在C++中，std::vector和其他容器可以使用自定义的分配器（allocator）来管理内存分配。分配器是一个模板参数，用于定义容器如何分配和释放内存。<br>回答者建议重写一个自定义的分配器，使其使用共享内存。这可以通过继承标准库中的std::allocator类并重写其内存分配和释放方法来实现。自定义分配器可以使用共享内存作为内存池，当std::vector需要分配或释放内存时，这个分配器会从共享内存池中分配或回收内存。<br>这样，当多个进程都使用这个自定义分配器创建std::vector时，它们的元素就会存储在共享内存中，从而实现跨进程的数据共享。</p>
<h2 id="System-V-ABI"><a href="#System-V-ABI" class="headerlink" title="System V ABI"></a>System V ABI</h2><p>System V ABI（Application Binary Interface）是一种用于x86架构的二进制接口标准，定义了操作系统和应用程序之间的接口规范，包括函数调用约定、寄存器使用、内存布局等方面。System V ABI是一种通用的ABI标准，适用于多种操作系统，如Linux、Solaris等。</p>
<h2 id="栈溢出的原因和防范措施"><a href="#栈溢出的原因和防范措施" class="headerlink" title="栈溢出的原因和防范措施"></a>栈溢出的原因和防范措施</h2><p>栈溢出（Stack Overflow）是指程序运行时，栈区内存发生溢出，导致数据覆盖到其他内存区域，从而破坏程序的正常执行。栈溢出通常是由以下原因导致的：<br>栈溢出主要可能是由以下原因导致的：</p>
<ul>
<li><strong>递归调用</strong>：递归调用层次过深，导致栈空间不足。</li>
<li><strong>局部变量过多</strong>：函数内部定义了大量的局部变量，占用了大量的栈空间。</li>
<li><strong>无限循环</strong>：循环内部没有终止条件，导致栈空间不断增长。</li>
<li><strong>缓冲区溢出</strong>：输入数据超出了缓冲区的大小，覆盖了栈中的其他数据。</li>
</ul>
<h2 id="STL-1"><a href="#STL-1" class="headerlink" title="STL"></a>STL</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>频繁的对vector进行 <code>push_back</code> 操作，会导致内存的频繁分配和释放，从而影响程序的性能。为了避免这种情况，可以使用<code>reserve()</code>函数来预分配vector的内存空间，从而减少内存分配和释放的次数。</p>
<ul>
<li><p><code>reserve()</code>函数可以在插入大量元素之前，预先分配vector的内存空间，避免频繁的内存分配和释放。例如，可以使用<code>reserve(n)</code>来预分配至少能容纳n个元素的内存空间，这样在后续的插入操作中，就不需要频繁地重新分配内存。<code>reserve</code> 改变的是 <code>capacity</code>，而不是 <code>size</code>。</p>
</li>
<li><p><code>resize()</code>函数用于改变vector的大小，如果新的大小大于当前大小，则在末尾插入默认构造的元素；如果新的大小小于当前大小，则删除多余的元素。<code>resize()</code>函数可以用于初始化vector的大小，或者调整vector的大小。<code>resize</code> 改变的是 <code>size</code>，而不是 <code>capacity</code>。</p>
</li>
<li><p><code>emplace_back()</code>函数是C++11引入的新函数，用于在vector的末尾直接构造元素，避免了临时对象的创建和拷贝。与<code>push_back()</code>函数不同，<code>emplace_back()</code>函数可以直接在vector的末尾构造元素，而不需要创建临时对象，从而提高了性能。</p>
</li>
</ul>
<p>为什么会有临时对象？因为<code>push_back()</code>函数接受的参数是一个对象，而在调用<code>push_back()</code>时，会先创建一个临时对象，然后再将这个临时对象拷贝到vector中。而<code>emplace_back()</code>函数直接在vector的末尾构造元素，避免了临时对象的创建和拷贝。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>std::map</code>是C++ STL中的关联容器，它提供了一种键值对的映射关系，可以快速查找和插入元素。<code>std::map</code>内部通常是基于红黑树实现的，因此查找和插入操作的时间复杂度为O(logN)。</p>
<h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3><p>迭代器失效指的是，当容器发生某些操作（如插入、删除、扩容等）后，与这些容器相关的迭代器、指针或引用可能不再正确地指向原来的元素，甚至可能导致未定义行为（比如访问非法内存）。</p>
<p>可以把迭代器想象成“地图上的指针”，指向一个容器中的某个位置。如果地图（容器）发生了重绘、裁剪或者拉伸，原来的指针可能会指向一个错误的位置或失效的区域。</p>
<h4 id="哪些操作会导致迭代器失效？"><a href="#哪些操作会导致迭代器失效？" class="headerlink" title="哪些操作会导致迭代器失效？"></a>哪些操作会导致迭代器失效？</h4><p>不同的容器在不同操作下表现各异，以下详细分析各种情况：</p>
<ol>
<li>std::vector 和 std::string<ul>
<li>插入（insert）或删除（erase）元素<ul>
<li>如果在容器中间插入或删除元素，所有指向被修改位置之后的迭代器都会失效。</li>
<li>原因： 因为插入/删除元素会导致后续元素移动。</li>
</ul>
</li>
<li>重新分配（reallocation）<ul>
<li>当容器需要扩容时（通常是插入新元素超出容量时），所有迭代器都会失效。</li>
<li>原因： 容器会申请新的内存块并将元素复制到新内存中，旧的内存块会被释放。</li>
</ul>
</li>
</ul>
</li>
<li>std::deque<ul>
<li>插入或删除操作可能导致指向整个容器的迭代器失效。<ul>
<li>在两端插入/删除元素： 只会使指向具体被修改位置的迭代器失效。</li>
<li>在中间插入/删除元素： 可能导致所有迭代器失效，因为底层存储可能需要重新分配。</li>
</ul>
</li>
</ul>
</li>
<li>std::list 和 std::forward_list<ul>
<li>插入/删除操作：<ul>
<li>插入或删除元素通常只会影响与被操作的元素相关的迭代器，其他迭代器不会受影响。</li>
<li>原因： 链表的内存是分散存储的，操作某个节点不会影响其他节点。</li>
</ul>
</li>
</ul>
</li>
<li>std::set、std::map、std::unordered_set、std::unordered_map<ul>
<li>插入元素：<ul>
<li>在这些容器中插入新元素通常不会使已有迭代器失效。</li>
</ul>
</li>
<li>删除元素：<ul>
<li>只会使指向被删除元素的迭代器失效。</li>
</ul>
</li>
<li>unordered_* 容器的重新哈希（rehashing）：<ul>
<li>当容器触发重新哈希操作（例如容量不足时），所有迭代器都会失效。</li>
</ul>
</li>
</ul>
</li>
<li>std::array 和 std::vector<bool><ul>
<li>std::array：<ul>
<li>由于 std::array 是固定大小的，迭代器永远不会因为插入或删除操作而失效。</li>
</ul>
</li>
<li>std::vector<bool>：<ul>
<li>由于 std::vector<bool> 使用了一种特殊的位压缩实现，操作时可能会使迭代器失效。<h4 id="如何避免迭代器失效？"><a href="#如何避免迭代器失效？" class="headerlink" title="如何避免迭代器失效？"></a>如何避免迭代器失效？</h4></li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>重新获取迭代器<ul>
<li>在可能导致迭代器失效的操作之后，重新获取需要的迭代器。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();</span><br><span class="line">vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>(), <span class="number">0</span>); <span class="comment">// 插入新元素，所有迭代器失效</span></span><br><span class="line">it = vec.<span class="built_in">begin</span>();          <span class="comment">// 重新获取迭代器</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>使用返回值<ul>
<li>插入或删除操作通常会返回一个有效的迭代器，指向操作后的适当位置。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>); <span class="comment">// 返回指向被删除元素之后元素的迭代器</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>选择合适的容器<ul>
<li>根据需求选择容器。例如，如果需要频繁在中间插入或删除元素，可以使用 std::list 或其他链表结构，而不是 std::vector。</li>
</ul>
</li>
<li>注意迭代器失效规则<ul>
<li>熟悉不同容器在不同操作下的迭代器失效规则，避免在操作后直接使用可能失效的迭代器。<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4>以下代码展示了迭代器失效的典型错误：</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="number">3</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">erase</span>(it); <span class="comment">// 删除元素 3 后，迭代器失效</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误原因： erase 操作会导致 it 失效，因此在下一个循环中使用 it 会引发未定义行为。</p>
<p>修正代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>();) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="number">3</span>) &#123;</span><br><span class="line">            it = vec.<span class="built_in">erase</span>(it); <span class="comment">// 获取新的有效迭代器</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++it; <span class="comment">// 只有在未删除时才递增迭代器</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p>RAII（Resource Acquisition Is Initialization）是一种资源获取即初始化的编程技术，用于管理资源的生命周期。RAII的核心思想是，通过在对象的构造函数中获取资源，然后在对象的析构函数中释放资源，从而确保资源在对象生命周期结束时被正确释放。</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>数据库的三个重要范式是关系型数据库设计的基础，它们用于确保数据库结构的合理性和数据的一致性。这三个范式分别是：</p>
<ol>
<li><p><strong>第一范式（1NF，First Normal Form）</strong>：</p>
<ul>
<li>要求数据库表的每一列都是不可分割的基本数据项，即每一列的值都是原子性的，不可再分解。</li>
<li>表中的每个字段值都必须是唯一的，不能有重复的列。</li>
<li>确保每个单元格中只包含单一值，而不是集合或数组。</li>
</ul>
</li>
<li><p><strong>第二范式（2NF，Second Normal Form）</strong>：</p>
<ul>
<li>在满足第一范式的基础上，要求表中的每个实例或行必须可以被唯一地区分，即表必须有一个主键。</li>
<li>非主键字段必须完全依赖于主键，没有部分依赖。这意味着表中不存在对主键的部分依赖，所有非主键字段都只能依赖于整个主键，而不是主键的一部分。</li>
</ul>
</li>
<li><p><strong>第三范式（3NF，Third Normal Form）</strong>：</p>
<ul>
<li>在满足第二范式的基础上，要求非主键字段之间不能相互依赖，即没有传递依赖。</li>
<li>也就是说，所有非主键字段只能依赖于主键，不能依赖于其他非主键字段。这样可以避免数据冗余和更新异常。</li>
</ul>
</li>
</ol>
<p>除了这三个基本范式，还有更高级别的范式，如BCNF（巴斯-科德范式）和第五范式（5NF），它们提供了更严格的数据依赖规则，以进一步优化数据库设计。</p>
<p>遵循这些范式可以帮助数据库设计师创建出结构良好、数据冗余最小化且易于维护的数据库。然而，在实际应用中，为了性能或其他考虑，有时可能会有意地违反某些范式规则。</p>
<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><h3 id="TCP-粘包"><a href="#TCP-粘包" class="headerlink" title="TCP 粘包"></a>TCP 粘包</h3><p>TCP 粘包（TCP Packet Sticking）是指发送方发送的多个小数据包被接收方合并成一个大数据包的现象。TCP 粘包通常发生在发送方连续发送多个小数据包时，由于网络传输的不确定性，接收方可能会将这些小数据包合并成一个大数据包，从而导致粘包现象。</p>
<p>TCP 粘包的原因主要有以下几点：</p>
<ol>
<li><strong>Nagle 算法</strong>：Nagle 算法是 TCP 协议中的一种流量控制算法，它会将多个小数据包合并成一个大数据包进行发送，以减少网络传输的开销。当发送方连续发送多个小数据包时，Nagle 算法可能会导致粘包现象。</li>
<li><strong>接收方缓冲区</strong>：接收方的 TCP 缓冲区可能会将多个数据包合并成一个大数据包进行处理，从而导致粘包现象。</li>
<li><strong>网络拥塞</strong>：网络拥塞可能会导致数据包的延迟和乱序，从而导致接收方将多个数据包合并成一个大数据包。</li>
</ol>
<p>为了解决 TCP 粘包问题，可以采取以下几种方法：</p>
<ol>
<li><strong>消息边界</strong>：在数据包中添加消息边界标记，接收方根据消息边界标记来划分数据包，从而避免粘包现象。</li>
<li><strong>固定长度</strong>：发送方将数据包固定为固定长度，接收方根据固定长度来划分数据包，从而避免粘包现象。</li>
<li><strong>消息长度</strong>：在数据包中添加消息长度字段，接收方根据消息长度来划分数据包，从而避免粘包现象。</li>
<li><strong>应用层协议</strong>：在应用层协议中定义消息格式和消息边界，从而避免 TCP 粘包问题。</li>
</ol>
<p>TCP 粘包是 TCP 协议中常见的问题，对于需要保证数据包的完整性和顺序的应用场景，需要采取相应的措施来避免粘包现象。</p>
<h1 id="内核驱动"><a href="#内核驱动" class="headerlink" title="内核驱动"></a>内核驱动</h1><h2 id="中断、软中断、硬中断"><a href="#中断、软中断、硬中断" class="headerlink" title="中断、软中断、硬中断"></a>中断、软中断、硬中断</h2><ul>
<li><p><strong>中断（Interrupt）</strong>：中断是计算机系统中的一种机制，用于处理硬件设备发出的异步事件。当硬件设备发生某种事件（如输入输出请求、时钟中断等）时，会向处理器发送中断信号，处理器会暂停当前任务，转而执行中断处理程序，处理完中断后再返回到原来的任务。</p>
</li>
<li><p><strong>硬中断（Hardware Interrupt）</strong>：硬中断是由硬件设备发出的中断信号，用于通知处理器发生了某种事件。硬中断通常由硬件设备的控制器（如中断控制器）发出，处理器在接收到硬中断信号后会暂停当前任务，转而执行硬中断处理程序。</p>
</li>
<li><p><strong>软中断（Software Interrupt）</strong>：软中断是由软件发出的中断信号，用于通知处理器执行某种特定的操作。软中断通常由操作系统内核发出，用于执行一些系统调用或内核服务。软中断通常不会打断当前任务的执行，而是在合适的时机执行。</p>
</li>
<li><p><strong>中断处理流程</strong>：中断处理流程通常包括以下几个步骤：</p>
<ol>
<li>硬件设备发出中断信号。</li>
<li>处理器接收中断信号，暂停当前任务，保存当前任务的上下文。</li>
<li>处理器执行中断处理程序，处理中断事件。</li>
<li>中断处理程序执行完毕后，恢复之前保存的任务上下文，继续执行原来的任务。</li>
</ol>
</li>
</ul>
<p>中断是计算机系统中的重要机制，用于处理硬件设备的异步事件。硬中断由硬件设备发出，软中断由软件发出，它们共同构成了计算机系统的中断处理机制。</p>
<h2 id="内核态、用户态"><a href="#内核态、用户态" class="headerlink" title="内核态、用户态"></a>内核态、用户态</h2><ul>
<li><p><strong>内核态（Kernel Mode）</strong>：内核态是操作系统的特权级别，也称为核心态或系统态。在内核态下，操作系统具有最高的权限，可以访问系统的所有资源和硬件设备，执行特权指令，管理进程和内存等。内核态下的代码运行在特权级别最高的 CPU 模式下，可以执行特权指令，访问所有内存区域，以及执行硬件操作。</p>
</li>
<li><p><strong>用户态（User Mode）</strong>：用户态是操作系统的非特权级别，也称为用户态或应用态。在用户态下，应用程序运行在受限的环境中，只能访问受限的资源和内存区域，不能直接访问硬件设备或执行特权指令。用户态下的代码运行在特权级别较低的 CPU 模式下，受到操作系统的保护，无法直接访问系统资源。</p>
</li>
</ul>
<p>操作系统通过内核态和用户态的划分，实现了对系统资源和硬件设备的保护，确保操作系统的稳定性和安全性。内核态和用户态之间的切换是通过系统调用（System Call）和中断（Interrupt）等机制实现的。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p><strong>内核线程（Kernel Thread）</strong>：内核线程是由操作系统内核创建和管理的线程，运行在内核态下，具有最高的权限。内核线程通常用于执行操作系统内核的任务，如调度、中断处理、文件系统等。内核线程不依赖于用户空间的进程，可以独立于用户进程而存在。</p>
</li>
<li><p><strong>普通线程（User Thread）</strong>：普通线程是由用户空间的进程创建和管理的线程，运行在用户态下，受到操作系统的保护。普通线程通常用于执行应用程序的任务，如计算、I/O 操作等。普通线程依赖于用户空间的进程，与进程共享资源和地址空间。</p>
</li>
</ul>
<p>内核线程和普通线程是操作系统中的两种线程模型，它们分别用于执行不同的任务。内核线程运行在内核态下，具有最高的权限，用于执行操作系统内核的任务；普通线程运行在用户态下，受到操作系统的保护，用于执行应用程序的任务。</p>
<ul>
<li><p><strong>tasklet</strong> 是一种轻量级的中断处理机制，用于处理一些短小的中断处理程序。tasklet是在中断上下文中执行的，它可以在中断处理程序中调度，但不会立即执行，而是在中断处理程序执行完毕后，由内核调度器来执行。tasklet通常用于处理一些短小的中断处理程序，如更新数据结构、唤醒等待队列等。</p>
</li>
<li><p><strong>timer</strong> 是一种定时器机制，用于在一定时间后执行某个操作。timer可以是一次性的，也可以是周期性的。timer通常用于执行一些定时任务，如定时检查系统状态、定时清理资源等。</p>
</li>
<li><p><strong>hrtimer</strong> 是一种高精度的定时器机制，用于实现微秒级别的定时操作。hrtimer提供了更高的精度和更灵活的定时功能，可以满足一些对时间精度要求较高的场景。</p>
</li>
<li><p><strong>irq</strong> 是中断请求的缩写，是一种异步事件机制，用于处理硬件设备发出的中断信号。irq通常由硬件设备的控制器（如中断控制器）发出，处理器在接收到irq信号后会暂停当前任务，转而执行irq处理程序。</p>
</li>
<li><p><strong>preeempt_disable()</strong> 函数用于禁止内核的抢占机制，即禁止内核在当前任务执行期间被其他任务抢占。preeempt_disable()函数通常用于临界区保护，确保在临界区内的代码不会被其他任务打断。</p>
</li>
<li><p><strong>local_irq_disable()</strong> 函数用于禁止中断，即禁止处理器响应中断信号。local_irq_disable()函数通常用于临界区保护，确保在临界区内的代码不会被中断打断。</p>
</li>
<li><p><strong>spin_lock()</strong> 函数用于获取自旋锁，即在获取锁之前一直自旋等待，直到获取到锁为止。spin_lock()函数通常用于临界区保护，确保在临界区内的代码不会被其他任务打断。</p>
</li>
<li><p><strong>schedule()</strong> 函数用于将当前任务放入调度队列，让其他任务有机会执行。schedule()函数通常用于让出 CPU 时间，让其他任务有机会执行，从而实现多任务调度。</p>
</li>
<li><p><strong>usleep()</strong> 函数用于让当前任务休眠一段时间，以实现延时操作。usleep()函数通常用于实现定时操作，让当前任务休眠一段时间后再继续执行。</p>
</li>
<li><p><strong>wait_event()</strong> 函数用于让当前任务等待某个条件的发生，直到条件满足后再继续执行。wait_event()函数通常用于实现同步机制，让当前任务等待其他任务的通知或事件。</p>
</li>
<li><p><strong>workqueue</strong> 是一种工作队列机制，用于在后台执行一些耗时的工作。workqueue通常用于执行一些需要长时间运行的任务，如数据处理、文件操作等。</p>
</li>
</ul>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul>
<li>中断、软中断、tasklet、timer、hrtimer执行环境下，或者“内核线程、普通线程内核态环境下调用了preeempt_disable()/local_irq_disable()/spin_lock()”后，能否调用 schedule() 函数(包括usleep()/wait_event等系列函数)？</li>
<li>workqueue、kernel thread、普通线程的内核态这些context下i没有调用preempt_disable()禁止抢占和local_irq_disable()禁止中断，能否调用schedule()函数？</li>
<li>内核中，schedule()的具体调用点？</li>
<li>除了主动调用，lazy_invocation在什么时候？</li>
<li>preempt_count</li>
<li>shcedule()真实反映到软硬件的操作？</li>
<li>内存管理中，node,zone,free_area,page,free_list[MIGRATE_TYPES]等是什么关系？</li>
</ul>
<h2 id="中断管理"><a href="#中断管理" class="headerlink" title="中断管理"></a>中断管理</h2><ol>
<li>硬件中断号和Linux内核的IRQ号它们是如何映射?</li>
<li>当发生硬件中断之后，ARM64处理器架构做那些工作?</li>
<li>为什么说中断上下文不能执行睡眠操作?</li>
<li>一个硬件中断之后，Linux内核如何响应并处理此中断?</li>
<li>同一类型的软中断是否允许多个CPU并行执行?</li>
<li>软中断上下文包括哪几种情况?</li>
<li>软中断上下文还是进程上下文 的优先级高?为什么?</li>
<li>是否允许同一个tasklet在多个CPU上并行执行?</li>
<li>中断现场保存在什么地方?</li>
<li>什么是中断现场？需要保存哪些内容？</li>
<li>工作队列是运行在中断上下文还是进程上下文?他的回调函数是否允许睡眠?</li>
<li>Linux软中断和工作队列的作用是什么？</li>
<li>Linux通过什么样的方式实现系统调用？</li>
<li>如果多个work挂入一个工作线程中执行，当某个work的回调函数执行了阻塞操作，那么剩下的work会怎么处理？</li>
<li>CMWQ机制如何动态管理工作线程池的线程？</li>
<li>Linux系统的ARM系统吧bootloader烧录进去之后，上电后串口没有任何输出反应，应该去检查软件还是硬件问题？</li>
</ol>
<h2 id="同步与并发"><a href="#同步与并发" class="headerlink" title="同步与并发"></a>同步与并发</h2><ol>
<li>为什么spinlock的临界区不能睡眠？</li>
<li>与spinlock相比，信号量的特点是什么？PV操作的原理是什么？</li>
<li>描述信号量是如何实现的？</li>
<li>什么时候用读者/写者信号量，由什么条件决定？</li>
<li>描述MSC锁的实现原理？</li>
<li>RCU相比读写锁有什么优势？</li>
<li>Linux内核已经实现信号量机制，为什么还要单独设置一个互斥锁？</li>
<li>请解释静态状态和宽限期？</li>
<li>PG_LOCKED常见使用方法？</li>
</ol>
<h2 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h2><p>伙伴系统是 Linux 内核中用于管理物理页面的一种内存分配算法。伙伴系统将物理内存划分为大小不等的块，每个块的大小是 2 的幂次方。当需要分配一块大小为 2^N 的物理页面时，伙伴系统会在大小为 2^N 的空闲块中查找可用的块，如果找到则分配给请求者，如果没有则向上合并块，直到找到合适的块为止。</p>
<h1 id="后端开发常识"><a href="#后端开发常识" class="headerlink" title="后端开发常识"></a>后端开发常识</h1><h2 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h2><h3 id="jwt的原理"><a href="#jwt的原理" class="headerlink" title="jwt的原理"></a>jwt的原理</h3><p>JWT（JSON Web Token）是一种开放标准（RFC 7519），它定义了一种紧凑且独⽴的方式，可以将各种信息作为 JSON 对象传输。这种信息可以被验证和信任，因为它是数字签名的。JWT 可以使用 HMAC 算法或者是 RSA 的公用/私用密钥对对 JWT 进⾏签名。</p>
<h3 id="jwt的组成"><a href="#jwt的组成" class="headerlink" title="jwt的组成"></a>jwt的组成</h3><p>JWT 由三部分组成，它们之间用点号（.）连接，这三部分分别是：</p>
<ul>
<li>Header（头部）</li>
<li>Payload（负载）</li>
<li>Signature（签名）</li>
</ul>
<h3 id="jwt的使用"><a href="#jwt的使用" class="headerlink" title="jwt的使用"></a>jwt的使用</h3><ol>
<li>客户端向服务端发送用户名和密码。</li>
<li>服务端验证用户名和密码。</li>
<li>服务端返回一个 JWT 给客户端。</li>
<li>客户端（如浏览器或移动应用）将 JWT 存储在本地（如 localStorage 或 sessionStorage），并在每次请求时将 JWT 附加在 HTTP 头部（通常是 Authorization 头部）。</li>
<li>服务端验证 JWT 并返回数据。</li>
</ol>
<h3 id="jwt的优缺点"><a href="#jwt的优缺点" class="headerlink" title="jwt的优缺点"></a>jwt的优缺点</h3><p>优点：</p>
<ul>
<li>JWT 是一个开放的标准，它定义了一种紧凑且独⽴的方式，可以将各种信息作为 JSON 对象传输。</li>
<li>JWT 是一种紧凑的方式，可以在 HTTP 和 HTML 之间传输。</li>
<li>JWT 是一种⾼度安全的方式，因为它是数字签名的。</li>
</ul>
<p>缺点：</p>
<ul>
<li>JWT 是一种无状态的认证方式，因此 JWT 本身不存储任何信息，这意味着每次请求都需要携带 JWT。</li>
<li>JWT 不能被撤销，因为 JWT 是一种无状态的认证方式，所以 JWT 本身不存储任何信息，这意味着 JWT 不能被撤销。</li>
</ul>
<h3 id="能不能主动使jwt失效"><a href="#能不能主动使jwt失效" class="headerlink" title="能不能主动使jwt失效"></a>能不能主动使jwt失效</h3><p>JWT 是一种无状态的认证方式，因此 JWT 本身不存储任何信息，这意味着 JWT 不能被撤销。但是，可以通过一些方法来使 JWT 失效，比如：</p>
<ol>
<li><p>设置较短的过期时间<br>在生成 JWT 时，可以设置一个较短的过期时间（exp 字段）。这样，即使 JWT 被泄露，它也会在较短时间内失效。</p>
</li>
<li><p>使用黑名单<br>在服务器端维护一个黑名单，存储已经失效的 JWT。当用户请求时，检查其 JWT 是否在黑名单中。如果在，则拒绝请求。</p>
</li>
<li><p>更改签名密钥<br>如果怀疑签名密钥泄露，可以更改签名密钥。这样，使用旧密钥签名的所有 JWT 都会失效。</p>
</li>
<li><p>使用版本控制<br>在 JWT 的 payload 中添加一个版本号字段（如 ver），并在服务器端维护一个当前有效版本号。当需要使所有旧的 JWT 失效时，只需增加服务器端的版本号。</p>
</li>
<li><p>结合数据库存储<br>在数据库中存储 JWT 的状态（如是否有效、过期时间等）。每次验证 JWT 时，查询数据库以确定其状态。</p>
</li>
</ol>
<h3 id="如何理解jwt的无状态"><a href="#如何理解jwt的无状态" class="headerlink" title="如何理解jwt的无状态"></a>如何理解jwt的无状态</h3><p>GitHub Copilot<br>JWT（JSON Web Token）的无状态特性是指 JWT 本身不依赖于服务器端的存储来保持其状态。具体来说，JWT 是一种自包含的令牌，它包含了所有必要的信息来验证其有效性和权限。服务器可以通过验证签名来确认 JWT 的有效性，而不需要存储任何会话数据。以下是对 JWT 无状态特性的详细解释：</p>
<ol>
<li><p>自包含的令牌<br>JWT 包含了所有必要的信息，包括用户身份、权限、过期时间等。这些信息被编码成一个 JSON 对象，并通过签名进行保护。服务器可以通过验证签名来确保令牌的完整性和真实性，而不需要查询任何外部存储。</p>
</li>
<li><p>无需服务器端存储<br>传统的会话管理通常依赖于服务器端存储会话数据，例如在数据库或内存中存储会话信息。每次请求时，服务器需要查找会话数据来验证用户身份和权限。相比之下，JWT 不需要在服务器端存储任何会话数据，因为所有信息都包含在令牌本身中。</p>
</li>
<li><p>简化的扩展性<br>由于 JWT 是无状态的，服务器不需要维护会话数据，这使得系统更容易扩展。多个服务器实例可以共享同一个公钥来验证 JWT，而不需要共享会话数据。这对于分布式系统和微服务架构特别有用。</p>
</li>
<li><p>安全性考虑<br>虽然 JWT 的无状态特性带来了很多便利，但也需要注意一些安全性问题：</p>
</li>
</ol>
<p>令牌泄露：如果 JWT 被泄露，攻击者可以在令牌有效期内使用它。因此，设置较短的过期时间和使用 HTTPS 传输令牌是必要的。<br>撤销令牌：由于 JWT 是无状态的，撤销令牌变得更加复杂。可以使用黑名单、版本控制等方法来实现令牌的撤销。</p>
<h2 id="session和cookie"><a href="#session和cookie" class="headerlink" title="session和cookie"></a>session和cookie</h2><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>Session 是一种方法，用来存储有关用户的信息，而这些信息对于应用程序的每个用户都是唯一的。Session 是一种服务器端的方法，用来跟踪用户的状态。Session 是一种方法，用来存储有关用户的信息，而这些信息对于应用程序的每个用户都是唯一的。Session 是一种服务器端的方法，用来跟踪用户的状态。</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>Cookie 是一种方法，用来存储有关用户的信息，而这些信息对于应用程序的每个用户都是唯一的。Cookie 是一种客户端的方法，用来跟踪用户的状态。</p>
<h3 id="session和cookie的区别"><a href="#session和cookie的区别" class="headerlink" title="session和cookie的区别"></a>session和cookie的区别</h3><ul>
<li>Session 是一种服务器端的方法，用来跟踪用户的状态，而 Cookie 是一种客户端的方法，用来跟踪用户的状态。</li>
<li>Session 是一种方法，用来存储有关用户的信息，而这些信息对于应用程序的每个用户都是唯一的，而 Cookie 是一种方法，用来存储有关用户的信息，而这些信息对于应用程序的每个用户都是唯一的。</li>
<li>Session 是一种服务器端的方法，用来跟踪用户的状态，而 Cookie 是一种客户端的方法，用来跟踪用户的状态。</li>
</ul>
<h3 id="seesion和jwt的区别"><a href="#seesion和jwt的区别" class="headerlink" title="seesion和jwt的区别"></a>seesion和jwt的区别</h3><ul>
<li>Session 是一种服务器端的方法，用来跟踪用户的状态，而 JWT 是一种客户端的方法，用来跟踪用户的状态。 <h2 id="什么是-CSRF-攻击？如何防范-CSRF-攻击？"><a href="#什么是-CSRF-攻击？如何防范-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？如何防范 CSRF 攻击？"></a>什么是 CSRF 攻击？如何防范 CSRF 攻击？</h2><h3 id="CSRF-攻击"><a href="#CSRF-攻击" class="headerlink" title="CSRF 攻击"></a>CSRF 攻击</h3>CSRF（Cross-Site Request Forgery）跨站请求伪造，是一种常见的 Web 攻击，它利用用户已经登录的身份，在用户不知情的情况下，以用户的名义完成非法操作。CSRF 攻击通常通过伪装成受信任用户的请求，向受信任的应用程序发送恶意请求。</li>
</ul>
<h3 id="CSRF-攻击的原理"><a href="#CSRF-攻击的原理" class="headerlink" title="CSRF 攻击的原理"></a>CSRF 攻击的原理</h3><p>CSRF 攻击的原理是攻击者引诱用户点击链接或者打开第三方网站，利用用户在受信任网站的身份，完成非法操作。</p>
<h3 id="CSRF-攻击的防范"><a href="#CSRF-攻击的防范" class="headerlink" title="CSRF 攻击的防范"></a>CSRF 攻击的防范</h3><ul>
<li>验证码：在关键操作前，要求用户输入验证码。</li>
<li>Referer Check：检查请求来源是否合法。</li>
<li>Token Check：在请求中添加 Token，并验证 Token 的合法性。</li>
<li>避免使用 GET 请求提交数据。</li>
</ul>
<h2 id="什么是-XSS-攻击？如何防范-XSS-攻击？"><a href="#什么是-XSS-攻击？如何防范-XSS-攻击？" class="headerlink" title="什么是 XSS 攻击？如何防范 XSS 攻击？"></a>什么是 XSS 攻击？如何防范 XSS 攻击？</h2><h3 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h3><p>XSS（Cross-Site Scripting）跨站脚本攻击，是一种常见的 Web 攻击，它允许攻击者将恶意脚本注入到网页中，其他用户在浏览时会执行这些恶意脚本。</p>
<h3 id="XSS-攻击的原理"><a href="#XSS-攻击的原理" class="headerlink" title="XSS 攻击的原理"></a>XSS 攻击的原理</h3><p>XSS 攻击的原理是攻击者在网页中注入恶意脚本，当用户浏览网页时，这些恶意脚本会被执行，从而达到攻击的目的。</p>
<h3 id="XSS-攻击的防范"><a href="#XSS-攻击的防范" class="headerlink" title="XSS 攻击的防范"></a>XSS 攻击的防范</h3><ul>
<li>输入检查：对用户输入的数据进行检查，过滤掉不合法的数据。</li>
<li>输出检查：对用户输出的数据进行检查，过滤掉不合法的数据。</li>
<li>转义字符：对用户输入的数据进行转义，将特殊字符转换为 HTML 实体。</li>
<li>CSP（Content Security Policy）：设置 Content-Security-Policy 头，限制页面加载的资源。</li>
</ul>
<h2 id="什么是-SQL-注入？如何防范-SQL-注入？"><a href="#什么是-SQL-注入？如何防范-SQL-注入？" class="headerlink" title="什么是 SQL 注入？如何防范 SQL 注入？"></a>什么是 SQL 注入？如何防范 SQL 注入？</h2><h3 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h3><p>SQL 注入是一种常见的 Web 攻击，它允许攻击者通过在应用程序中插入恶意 SQL 语句，从而执行恶意操作。</p>
<h3 id="SQL-注入的原理"><a href="#SQL-注入的原理" class="headerlink" title="SQL 注入的原理"></a>SQL 注入的原理</h3><p>SQL 注入的原理是攻击者在应用程序中插入恶意 SQL 语句，当应用程序执行这些恶意 SQL 语句时，就会执行恶意操作。</p>
<h3 id="SQL-注入的防范"><a href="#SQL-注入的防范" class="headerlink" title="SQL 注入的防范"></a>SQL 注入的防范</h3><ul>
<li>参数化查询：使用参数化查询，将用户输入的数据作为参数传递给 SQL 语句。</li>
<li>输入检查：对用户输入的数据进行检查，过滤掉不合法的数据。</li>
<li>输出检查：对用户输出的数据进行检查，过滤掉不合法的数据。</li>
<li>ORM（Object-Relational Mapping）：使用 ORM 框架，避免直接操作 SQL 语句。</li>
</ul>
<h2 id="在-C-中，如果没有borrow-check，有什么移动语义的最佳实践？"><a href="#在-C-中，如果没有borrow-check，有什么移动语义的最佳实践？" class="headerlink" title="在 C++中，如果没有borrow check，有什么移动语义的最佳实践？"></a>在 C++中，如果没有borrow check，有什么移动语义的最佳实践？</h2><p>在 C++ 中，虽然没有像 Rust 那样的借用检查（borrow check），但我们可以通过一些最佳实践来有效地使用移动语义，以确保资源的高效管理和避免不必要的拷贝。以下是一些移动语义的最佳实践：</p>
<ol>
<li><strong>使用 std::move</strong><br>当你确定不再需要某个对象的值时，可以使用 std::move 将其转换为右值引用，从而启用移动语义。<br>例如，在将对象传递给函数时，如果函数可以通过移动构造函数或移动赋值运算符来处理对象，可以使用 std::move</li>
<li><strong>实现移动构造函数和移动赋值运算符</strong><br>为自定义类实现<strong>移动构造函数和移动赋值运算符</strong>，以支持移动语义。<br>在移动构造函数和移动赋值运算符中，确保正确地转移资源，并将源对象置于有效但未指定的状态。</li>
<li>避免不必要的拷贝<br>在函数返回值时，尽量返回局部对象的右值引用，以启用移动语义。<br>使用返回值优化（RVO）和移动语义来避免不必要的拷贝</li>
</ol>
<h2 id="并发编程中的池化技术：内存池、进程池、线程池、连接池、缓冲池、协程池"><a href="#并发编程中的池化技术：内存池、进程池、线程池、连接池、缓冲池、协程池" class="headerlink" title="并发编程中的池化技术：内存池、进程池、线程池、连接池、缓冲池、协程池"></a>并发编程中的池化技术：内存池、进程池、线程池、连接池、缓冲池、协程池</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>设计线程池的时候，需要考虑以下几个方面：</p>
<ol>
<li><strong>线程池的大小</strong>：线程池的大小应该根据系统的负载情况和硬件资源来动态调整，避免过多或过少的线程。</li>
<li><strong>任务队列</strong>：线程池应该有一个任务队列，用于存储待执行的任务，线程从任务队列中获取任务并执行。</li>
<li><strong>线程同步</strong>：线程池中的线程需要进行同步，避免竞争条件和死锁。</li>
<li><strong>任务调度</strong>：线程池需要有一个任务调度器，用于调度任务的执行顺序和优先级。</li>
<li><strong>异常处理</strong>：线程池需要处理任务执行过程中的异常，避免线程崩溃导致整个线程池崩溃。</li>
<li><strong>资源管理</strong>：线程池需要管理线程的生命周期，包括线程的创建、销毁和复用。</li>
</ol>
<h3 id="进程池、协程池、线程池"><a href="#进程池、协程池、线程池" class="headerlink" title="进程池、协程池、线程池"></a>进程池、协程池、线程池</h3><p>以下是协程池、线程池、进程池的定义、核心关联、区别及常用场景的全面对比分析：</p>
<p>定义与核心原理</p>
<p>线程池  </p>
<p>  预先创建一组线程并复用，通过队列管理任务分配。使用 concurrent.futures.ThreadPoolExecutor 实现。线程共享进程内存，但受全局解释器锁（GIL）限制，无法并行执行CPU计算。<br>进程池  </p>
<p>  管理多个独立进程，每个进程拥有独立内存和Python解释器。通过 concurrent.futures.ProcessPoolExecutor 实现。可绕过GIL限制，实现多核并行，但进程间通信（IPC）开销大。<br>协程池  </p>
<p>  在单线程内调度多个协程任务，通过事件循环（如 asyncio）实现非阻塞切换。协程是用户态轻量级线程，由程序控制切换时机，无需内核介入。常用 asyncio.gather 或第三方库（如 gevent）管理任务池。</p>
<p>核心关联</p>
<p>池化思想：三者均通过复用资源（线程/进程/协程）减少频繁创建销毁的开销，提升性能并保护硬件安全。</p>
<p>任务调度：均采用任务队列分配工作，支持异步提交（如 submit()）和结果收集（如 Future 对象）。</p>
<p>混合使用：可组合应用（如进程池内嵌套线程池或协程池），兼顾CPU密集与I/O密集任务。</p>
<p>多维对比</p>
<p>维度         线程池 进程池 协程池</p>
<p>资源开销 中等（MB级/线程） 高（GB级/进程） 极低（KB级/协程）<br>并发能力 百级（受制于GIL切换） 十级（受限于进程数） 万级（单线程内高效切换）<br>数据共享 直接共享进程内存 需IPC（管道、队列等） 直接共享线程内存<br>适用场景 I/O密集型（网络请求、文件读写） CPU密集型（计算、加密） 超高并发I/O（API调用、爬虫）<br>编程复杂度 低（同步编程） 中（需处理IPC） 高（需异步编程模型）<br>典型模块 ThreadPoolExecutor ProcessPoolExecutor asyncio/gevent</p>
<p>应用场景</p>
<p>线程池<br>典型场景：  </p>
<p>批量HTTP请求（如网页抓取）  </p>
<p>数据库查询（等待I/O时释放GIL）  </p>
<p>文件批量处理（读写磁盘时切换任务）  </p>
<p>优势：编程简单，I/O阻塞时自动切换任务。</p>
<p>进程池<br>典型场景：  </p>
<p>科学计算（如矩阵运算、数值模拟）  </p>
<p>图像/视频处理（像素级计算）  </p>
<p>加密解密（消耗大量CPU周期）  </p>
<p>优势：绕过GIL，真正并行利用多核CPU。</p>
<p>协程池<br>典型场景：  </p>
<p>微服务网关（处理万级API并发）  </p>
<p>实时数据流处理（如WebSocket消息广播）  </p>
<p>高并发爬虫（同时管理数千连接）  </p>
<p>优势：单线程内万级并发，内存占用极小。</p>
<p>混合使用建议</p>
<p>CPU密集型 + I/O密集型：  </p>
<p>  进程池处理计算任务，每个进程内使用协程池管理高并发I/O（如数据处理流水线）。<br>安全隔离需求：  </p>
<p>  进程池隔离崩溃风险（如第三方库不稳定），线程池处理内部轻量任务。</p>
<p>总结<br>选型优先级：  </p>
<p>  I/O密集型 → 协程池 &gt; 线程池｜CPU密集型 → 进程池<br>关键权衡：  </p>
<p>  资源开销（协程最优）、开发成本（线程最简）、计算效率（进程最佳）。实际项目中可组合使用，例如 ProcessPoolExecutor + asyncio 最大化利用多核与高并发。</p>
<h2 id="clang-和-g"><a href="#clang-和-g" class="headerlink" title="clang++ 和 g++"></a>clang++ 和 g++</h2><h3 id="clang"><a href="#clang" class="headerlink" title="clang++"></a>clang++</h3><h2 id="ACE-libev-muduo"><a href="#ACE-libev-muduo" class="headerlink" title="ACE, libev, muduo"></a>ACE, libev, muduo</h2><h2 id="4cpp"><a href="#4cpp" class="headerlink" title="4cpp"></a>4cpp</h2><h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><h2 id="压力测试工具"><a href="#压力测试工具" class="headerlink" title="压力测试工具"></a>压力测试工具</h2><p>webbench，loadrunner，locust</p>
<h2 id="分布式服务器"><a href="#分布式服务器" class="headerlink" title="分布式服务器"></a>分布式服务器</h2><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><h2 id="DOC"><a href="#DOC" class="headerlink" title="DOC"></a>DOC</h2><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h2 id="裸指针是什么"><a href="#裸指针是什么" class="headerlink" title="裸指针是什么"></a>裸指针是什么</h2><p>裸指针是一种没有任何安全性约束的指针，它可以直接访问内存中的数据，但是使用裸指针需要特别小心，因为裸指针容易导致内存安全问题，如空指针、悬垂指针、野指针等。</p>
<h2 id="glibc-和-musl的区别"><a href="#glibc-和-musl的区别" class="headerlink" title="glibc 和 musl的区别"></a>glibc 和 musl的区别</h2><p>glibc 是 Linux 系统上的标准 C 库，它是 GNU 项目的一部分，提供了 C 语言的标准库函数。glibc 是 Linux 系统上最常用的 C 库，它提供了丰富的功能和良好的性能。</p>
<p>musl 是一个轻量级的标准 C 库，它专注于简单、高效和可移植。musl 是一个独立的 C 库，它不依赖于 Linux 系统，可以在其他系统上使用。</p>
<h3 id="动态链接与静态链接"><a href="#动态链接与静态链接" class="headerlink" title="动态链接与静态链接"></a>动态链接与静态链接</h3><p>glibc 是一个动态链接库，它在运行时加载到内存中，程序在运行时调用 glibc 中的函数。musl 是一个静态链接库，它在编译时链接到程序中，程序在运行时不需要加载 musl。</p>
<h3 id="动态链接和静态链接各自的优劣势："><a href="#动态链接和静态链接各自的优劣势：" class="headerlink" title="动态链接和静态链接各自的优劣势："></a>动态链接和静态链接各自的优劣势：</h3><ul>
<li><p>动态链接：优势是节省内存，多个程序可以共享同一个库，减少了程序的体积。劣势是启动速度慢，程序运行时需要加载库，可能会导致性能问题。</p>
</li>
<li><p>静态链接：优势是启动速度快，程序运行时不需要加载库，减少了性能问题。劣势是占用内存，每个程序都需要加载库，增加了程序的体积。</p>
</li>
</ul>
<h3 id="socket-网络编程"><a href="#socket-网络编程" class="headerlink" title="socket 网络编程"></a>socket 网络编程</h3><ul>
<li>说一下你对 socket 网络编程的理解？</li>
<li><p>socket 网络编程是一种基于 TCP/IP 协议的网络编程模型，它通过 socket 接口提供了一种通信机制，使得不同主机之间可以进行数据通信。socket 网络编程可以实现客户端和服务器之间的通信，包括数据的发送和接收。</p>
</li>
<li><p>介绍一下 socket 网络编程的基本流程？</p>
</li>
<li><p>socket 网络编程的基本流程包括以下几个步骤：</p>
<ol>
<li>创建 socket：使用 socket() 函数创建一个套接字。</li>
<li>绑定地址：使用 bind() 函数将套接字绑定到一个地址。</li>
<li>监听连接：使用 listen() 函数监听连接请求。</li>
<li>接受连接：使用 accept() 函数接受连接请求。</li>
<li>发送数据：使用 send() 函数发送数据。</li>
<li>接收数据：使用 recv() 函数接收数据。</li>
<li>关闭连接：使用 close() 函数关闭连接。</li>
</ol>
</li>
<li><p>socket 网络编程中的阻塞和非阻塞模式有什么区别？</p>
</li>
<li>阻塞模式：在阻塞模式下，当调用 send() 或 recv() 函数时，如果没有数据可读或可写，程序会阻塞等待，直到有数据可读或可写。</li>
<li>非阻塞模式：在非阻塞模式下，当调用 send() 或 recv() 函数时，如果没有数据可读或可写，程序会立即返回，不会阻塞等待。程序可以继续执行其他任务，然后再次调用 send() 或 recv() 函数。</li>
</ul>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>valgrind是一个用于检测内存泄漏、内存错误、线程错误的工具，它可以检测程序运行时的内存使用情况，帮助开发人员发现潜在的内存问题。valgrind包括多个工具，如memcheck、helgrind、drd等，每个工具都有不同的功能和用途。</p>
<ul>
<li><p>ioctl<br> ioctl是Linux系统中的一个系统调用，用于对设备进行控制。ioctl的功能非常强大，可以用于对设备进行各种操作，如设置参数、发送命令、读取状态等。ioctl的使用方法是通过文件描述符和命令号来调用ioctl系统调用，从而实现对设备的控制。</p>
</li>
<li><p>iocp 并发模型</p>
</li>
<li><p>设计线程池</p>
</li>
</ul>
<ul>
<li><p>C++如何不使用多态实现多态效果？</p>
<ul>
<li>静态多态：函数重载、模板</li>
<li>回调函数：通过回调函数实现多态效果，将函数指针作为参数传递给函数，实现不同的行为。</li>
</ul>
</li>
<li><p>拷贝构造函数如果传递的不是引用，会导致无限递归调用拷贝构造函数，最终导致栈溢出。</p>
</li>
<li><p>析构函数定义为虚函数的作用，不定义为虚函数会有什么问题？</p>
<ul>
<li>析构函数定义为虚函数，可以实现多态，当基类指针指向派生类对象时，delete基类指针时，会调用派生类的析构函数。如果定义为非虚函数，delete基类指针时，只会调用基类的析构函数，不会调用派生类的析构函数，导致内存泄漏。</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://val213.github.io">Val</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://val213.github.io/2024/09/15/%E5%B0%B1%E4%B8%9A/%E3%80%90%E5%B0%B1%E4%B8%9A%E3%80%91C++%E5%85%AB%E8%82%A1%E6%96%87/">https://val213.github.io/2024/09/15/%E5%B0%B1%E4%B8%9A/%E3%80%90%E5%B0%B1%E4%B8%9A%E3%80%91C++%E5%85%AB%E8%82%A1%E6%96%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/27/DragonOS/%E3%80%90DragonOS%E3%80%91chown%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="【DragonOS】chown系统调用"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">【DragonOS】chown系统调用</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/09/DragonOS/%E3%80%90DragonOS%E3%80%91PCI%E6%80%BB%E7%BA%BF%E5%AD%90%E7%B3%BB%E7%BB%9F/" title="【DragonOS】PCI总线子系统"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">【DragonOS】PCI总线子系统</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/11/16/%E5%BC%80%E5%8F%91/%E3%80%90C++%E3%80%91%E9%AB%98%E9%80%9F%E4%B8%8A%E6%89%8B/" title="C++ 11&#x2F;14&#x2F;17&#x2F;20"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-16</div><div class="title">C++ 11&#x2F;14&#x2F;17&#x2F;20</div></div></a></div><div><a href="/2024/11/19/%E5%BC%80%E5%8F%91/%E9%AB%98%E6%80%A7%E8%83%BD%20Linux%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" title="高性能 Linux 服务器编程"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-19</div><div class="title">高性能 Linux 服务器编程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://github.com/val213/image/blob/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230630230143.jpg?raw=true" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Val</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">149</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">111</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/val213"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/val213" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:val213666@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">记录跬步 e/acc</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%85%AB%E8%82%A1%E6%96%87"><span class="toc-number">1.</span> <span class="toc-text">C++八股文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.1.</span> <span class="toc-text">C++智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%83%85%E5%86%B5"><span class="toc-number">1.2.</span> <span class="toc-text">C++ 中内存分配情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%92%8C-Java-%E5%8C%BA%E5%88%AB%EF%BC%88%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%EF%BC%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%AD%89%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">C++ 和 Java 区别（语言特性，垃圾回收，应用场景等）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-const-%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">说一下 const 修饰指针如何区分？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.5.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.</span> <span class="toc-text">堆和栈区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.6.1.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.6.2.</span> <span class="toc-text">堆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-delete-%EF%BC%8Cmalloc-free-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.</span> <span class="toc-text">new &#x2F; delete ，malloc &#x2F; free 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile-%E5%92%8C-extern-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.8.</span> <span class="toc-text">volatile 和 extern 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-%E4%B8%89%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="toc-number">1.8.1.</span> <span class="toc-text">volatile 三个特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extern"><span class="toc-number">1.8.2.</span> <span class="toc-text">extern</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#define-%E5%92%8C-const-%E5%8C%BA%E5%88%AB%EF%BC%88%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E3%80%81%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%AD%89%EF%BC%89"><span class="toc-number">1.8.3.</span> <span class="toc-text">define 和 const 区别（编译阶段、安全性、内存占用等）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%EF%BC%88%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%8C%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%89%EF%BC%8C%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.9.</span> <span class="toc-text">虚函数相关（虚函数表，虚函数指针），虚函数的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%AD%98%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">1.9.1.</span> <span class="toc-text">虚函数指针和虚函数表存放在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E-virtual-%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-number">1.9.2.</span> <span class="toc-text">非 virtual 的多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9D%A5%E8%AF%B4%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E5%BB%BA%E7%AB%8B%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E8%BF%87%E7%A8%8B%E5%85%B6%E5%AE%9E%E4%B8%80%E5%85%B1%E6%98%AF%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">1.9.3.</span> <span class="toc-text">对于派生类来说，编译器建立虚函数表的过程其实一共是三个步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%80%E8%88%AC%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.9.4.</span> <span class="toc-text">析构函数一般写成虚函数的原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#char-a-char-a-char-a-char-char-a-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.10.</span> <span class="toc-text">char a,char a[],char a,char [],char  a 之间的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80-%E7%A8%8B%E5%BA%8F%E5%88%86%E6%AE%B5"><span class="toc-number">1.11.</span> <span class="toc-text">C++内存布局&#x2F;程序分段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90"><span class="toc-number">1.11.1.</span> <span class="toc-text">具体分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static"><span class="toc-number">1.12.</span> <span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E5%AF%B9%E4%BA%8E%E5%8F%98%E9%87%8F"><span class="toc-number">1.12.1.</span> <span class="toc-text">static对于变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.12.1.2.</span> <span class="toc-text">全局变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-%E5%AF%B9%E4%BA%8E%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.2.</span> <span class="toc-text">static 对于函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E5%AF%B9%E4%BA%8E%E7%B1%BB"><span class="toc-number">1.12.3.</span> <span class="toc-text">static对于类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.12.3.1.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.3.2.</span> <span class="toc-text">成员函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-number">1.13.</span> <span class="toc-text">const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-number">1.13.0.1.</span> <span class="toc-text">const 与指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.14.</span> <span class="toc-text">static 初始化时机和线程安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">1.15.</span> <span class="toc-text">C++ 局部静态变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.16.</span> <span class="toc-text">指针和引用的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E7%B1%BB"><span class="toc-number">1.17.</span> <span class="toc-text">变量存储类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.18.</span> <span class="toc-text">静态链接和动态链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.18.1.</span> <span class="toc-text">静态链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">1.18.1.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">1.18.1.2.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.18.1.3.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.18.2.</span> <span class="toc-text">动态链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-1"><span class="toc-number">1.18.2.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-1"><span class="toc-number">1.18.2.2.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-1"><span class="toc-number">1.18.2.3.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%98%E6%98%AF%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%9F%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB%EF%BC%9A%E3%80%8AStatic-Linking-Considered-Harmful%E3%80%8B"><span class="toc-number">1.18.3.</span> <span class="toc-text">静态链接还是动态链接？文章导读：《Static Linking Considered Harmful》</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%85%A8%E9%9D%A2%E6%89%B9%E5%88%A4%E4%BA%86%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E8%AE%BA%E8%BF%B0%E4%BA%86%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E8%AF%B8%E5%A4%9A%E4%BC%98%E8%B6%8A%E6%80%A7%EF%BC%8C%E6%A0%B8%E5%BF%83%E8%A7%82%E7%82%B9%E6%98%AF%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%9C%A8%E5%A4%9A%E6%96%B9%E9%9D%A2%E4%BC%98%E4%BA%8E%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%8C%E5%B9%B6%E5%BB%BA%E8%AE%AE%E5%9C%A8%E5%BC%80%E5%8F%91%E5%92%8C%E9%83%A8%E7%BD%B2%E4%B8%AD%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E3%80%82"><span class="toc-number">1.19.</span> <span class="toc-text">这篇文章全面批判了静态链接的使用，论述了动态链接的诸多优越性，核心观点是动态链接在多方面优于静态链接，并建议在开发和部署中尽量避免静态链接。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E8%AE%BA%E7%82%B9"><span class="toc-number">1.19.0.1.</span> <span class="toc-text">主要论点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E7%BB%B4%E6%8A%A4%E6%80%A7"><span class="toc-number">1.19.0.1.1.</span> <span class="toc-text">1. 安全性与维护性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%80%A7%E8%83%BD%E5%92%8C%E8%B5%84%E6%BA%90%E5%88%A9%E7%94%A8"><span class="toc-number">1.19.0.1.2.</span> <span class="toc-text">2. 性能和资源利用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%8A%9F%E8%83%BD%E6%80%A7"><span class="toc-number">1.19.0.1.3.</span> <span class="toc-text">3. 功能性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%83%BD%E5%8A%9B"><span class="toc-number">1.19.0.1.4.</span> <span class="toc-text">4. 跨平台能力</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">1.19.0.2.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E8%80%85%E7%9A%84%E6%BE%84%E6%B8%85%E4%B8%8E%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.19.0.3.</span> <span class="toc-text">作者的澄清与建议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.19.0.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E5%92%8C%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-number">1.20.</span> <span class="toc-text">静态联编和动态联编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%EF%BC%88Static-Binding%EF%BC%89"><span class="toc-number">1.20.1.</span> <span class="toc-text">静态联编（Static Binding）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-2"><span class="toc-number">1.20.1.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-2"><span class="toc-number">1.20.1.2.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-2"><span class="toc-number">1.20.1.3.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96%EF%BC%88Dynamic-Binding%EF%BC%89"><span class="toc-number">1.20.2.</span> <span class="toc-text">动态联编（Dynamic Binding）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-3"><span class="toc-number">1.20.2.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-3"><span class="toc-number">1.20.2.2.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-3"><span class="toc-number">1.20.2.3.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E5%92%8C%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-number">1.20.3.</span> <span class="toc-text">对比静态联编和动态联编</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.21.</span> <span class="toc-text">内联函数和宏定义的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%92%8C-Concept"><span class="toc-number">1.22.</span> <span class="toc-text">模板和 Concept</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E3%80%81%E7%B1%BB%E6%A8%A1%E6%9D%BF%E3%80%81%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96"><span class="toc-number">1.22.1.</span> <span class="toc-text">函数模板、类模板、模板特化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-4"><span class="toc-number">1.22.1.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-4"><span class="toc-number">1.22.1.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-Concepts"><span class="toc-number">1.22.2.</span> <span class="toc-text">C++ Concepts</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Concepts%EF%BC%9F"><span class="toc-number">1.22.2.1.</span> <span class="toc-text">为什么需要Concepts？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-Rust-%E7%9A%84-trait-imlp-%E5%AF%B9%E6%AF%94"><span class="toc-number">1.22.3.</span> <span class="toc-text">和 Rust 的 trait&#x2F;imlp 对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%AF%B9%E6%AF%94"><span class="toc-number">1.22.3.1.</span> <span class="toc-text">1. 基本功能与核心对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%B7%E4%BD%93%E5%AF%B9%E6%AF%94"><span class="toc-number">1.22.3.2.</span> <span class="toc-text">2. 具体对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E6%B3%9B%E5%9E%8B%E8%A1%A8%E8%BE%BE%E8%83%BD%E5%8A%9B"><span class="toc-number">1.22.3.2.1.</span> <span class="toc-text">A. 泛型表达能力</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#C-%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.22.3.2.1.1.</span> <span class="toc-text">C++ 模板</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Rust-trait"><span class="toc-number">1.22.3.2.1.2.</span> <span class="toc-text">Rust trait</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F%E6%9C%BA%E5%88%B6"><span class="toc-number">1.22.3.2.2.</span> <span class="toc-text">B. 类型约束机制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#C-Concepts-1"><span class="toc-number">1.22.3.2.2.1.</span> <span class="toc-text">C++ Concepts</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Rust-trait-1"><span class="toc-number">1.22.3.2.2.2.</span> <span class="toc-text">Rust trait</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E5%A4%9A%E6%80%81%E6%94%AF%E6%8C%81"><span class="toc-number">1.22.3.2.3.</span> <span class="toc-text">C. 多态支持</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#C-%E6%A8%A1%E6%9D%BF-amp-Concepts"><span class="toc-number">1.22.3.2.3.1.</span> <span class="toc-text">C++ 模板 &amp; Concepts</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Rust-trait-2"><span class="toc-number">1.22.3.2.3.2.</span> <span class="toc-text">Rust trait</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#D-%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="toc-number">1.22.3.2.4.</span> <span class="toc-text">D. 错误提示与调试</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#C-%E6%A8%A1%E6%9D%BF-1"><span class="toc-number">1.22.3.2.4.1.</span> <span class="toc-text">C++ 模板</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#C-Concepts-2"><span class="toc-number">1.22.3.2.4.2.</span> <span class="toc-text">C++ Concepts</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Rust-trait-3"><span class="toc-number">1.22.3.2.4.3.</span> <span class="toc-text">Rust trait</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94"><span class="toc-number">1.22.3.3.</span> <span class="toc-text">3. 总结与优缺点对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%9C%BA%E6%99%AF"><span class="toc-number">1.22.3.3.1.</span> <span class="toc-text">选择场景</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%87%BA%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">1.23.</span> <span class="toc-text">C++ 出现的内存问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81%E5%92%8C%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%A4%9A%E6%80%81"><span class="toc-number">1.24.</span> <span class="toc-text">编译期多态和运行期多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.25.</span> <span class="toc-text">C++ 异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL"><span class="toc-number">1.26.</span> <span class="toc-text">STL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-fork-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">1.27.</span> <span class="toc-text">介绍一下 fork 的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-copy-on-write%EF%BC%88COW%EF%BC%89%E6%8A%80%E6%9C%AF"><span class="toc-number">1.28.</span> <span class="toc-text">介绍一下 copy-on-write（COW）技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.28.1.</span> <span class="toc-text">写时复制的工作原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">1.28.2.</span> <span class="toc-text">写时复制的优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">1.28.3.</span> <span class="toc-text">写时复制的应用场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">1.28.4.</span> <span class="toc-text">注意事项：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fork%E3%80%81vfork-%E5%92%8C-clone-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.29.</span> <span class="toc-text">fork、vfork 和 clone 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">1.29.1.</span> <span class="toc-text">fork()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vfork"><span class="toc-number">1.29.2.</span> <span class="toc-text">vfork()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clone"><span class="toc-number">1.29.3.</span> <span class="toc-text">clone()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="toc-number">1.29.4.</span> <span class="toc-text">区别总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.30.</span> <span class="toc-text">介绍一下进程间通信（IPC）的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.31.</span> <span class="toc-text">僵尸进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-number">1.32.</span> <span class="toc-text">左值和右值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.32.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.32.2.</span> <span class="toc-text">右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0"><span class="toc-number">1.32.2.1.</span> <span class="toc-text">引用折叠</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">1.32.3.</span> <span class="toc-text">移动语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">1.32.4.</span> <span class="toc-text">完美转发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.33.</span> <span class="toc-text">自动类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype-auto"><span class="toc-number">1.33.1.</span> <span class="toc-text">decltype(auto)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94"><span class="toc-number">1.34.</span> <span class="toc-text">惊群效应</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDT%E5%92%8CTSS"><span class="toc-number">1.35.</span> <span class="toc-text">IDT和TSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E5%9C%A8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%8A%E4%BD%BF%E7%94%A8stl%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%9F"><span class="toc-number">1.36.</span> <span class="toc-text">何在共享内存上使用stl标准库？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-V-ABI"><span class="toc-number">1.37.</span> <span class="toc-text">System V ABI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E9%98%B2%E8%8C%83%E6%8E%AA%E6%96%BD"><span class="toc-number">1.38.</span> <span class="toc-text">栈溢出的原因和防范措施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL-1"><span class="toc-number">1.39.</span> <span class="toc-text">STL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vector"><span class="toc-number">1.39.1.</span> <span class="toc-text">vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">1.39.2.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-number">1.39.3.</span> <span class="toc-text">迭代器失效</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E5%AF%BC%E8%87%B4%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">1.39.3.1.</span> <span class="toc-text">哪些操作会导致迭代器失效？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">1.39.3.2.</span> <span class="toc-text">如何避免迭代器失效？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.39.3.3.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RAII"><span class="toc-number">1.40.</span> <span class="toc-text">RAII</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.</span> <span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%BD%91"><span class="toc-number">3.</span> <span class="toc-text">计网</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F"><span class="toc-number">3.1.</span> <span class="toc-text">TCP&#x2F;IP协议族</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E7%B2%98%E5%8C%85"><span class="toc-number">3.1.1.</span> <span class="toc-text">TCP 粘包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8"><span class="toc-number">4.</span> <span class="toc-text">内核驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E3%80%81%E8%BD%AF%E4%B8%AD%E6%96%AD%E3%80%81%E7%A1%AC%E4%B8%AD%E6%96%AD"><span class="toc-number">4.1.</span> <span class="toc-text">中断、软中断、硬中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E3%80%81%E7%94%A8%E6%88%B7%E6%80%81"><span class="toc-number">4.2.</span> <span class="toc-text">内核态、用户态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">4.3.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.</span> <span class="toc-text">其他问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86"><span class="toc-number">4.5.</span> <span class="toc-text">中断管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">4.6.</span> <span class="toc-text">同步与并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.7.</span> <span class="toc-text">伙伴系统</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E8%AF%86"><span class="toc-number">5.</span> <span class="toc-text">后端开发常识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jwt"><span class="toc-number">5.1.</span> <span class="toc-text">jwt</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jwt%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.1.</span> <span class="toc-text">jwt的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jwt%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">5.1.2.</span> <span class="toc-text">jwt的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jwt%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.3.</span> <span class="toc-text">jwt的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jwt%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.1.4.</span> <span class="toc-text">jwt的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E4%B8%8D%E8%83%BD%E4%B8%BB%E5%8A%A8%E4%BD%BFjwt%E5%A4%B1%E6%95%88"><span class="toc-number">5.1.5.</span> <span class="toc-text">能不能主动使jwt失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3jwt%E7%9A%84%E6%97%A0%E7%8A%B6%E6%80%81"><span class="toc-number">5.1.6.</span> <span class="toc-text">如何理解jwt的无状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#session%E5%92%8Ccookie"><span class="toc-number">5.2.</span> <span class="toc-text">session和cookie</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#session"><span class="toc-number">5.2.1.</span> <span class="toc-text">session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie"><span class="toc-number">5.2.2.</span> <span class="toc-text">cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session%E5%92%8Ccookie%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.3.</span> <span class="toc-text">session和cookie的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#seesion%E5%92%8Cjwt%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.4.</span> <span class="toc-text">seesion和jwt的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">什么是 CSRF 攻击？如何防范 CSRF 攻击？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-%E6%94%BB%E5%87%BB"><span class="toc-number">5.3.1.</span> <span class="toc-text">CSRF 攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-%E6%94%BB%E5%87%BB%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.2.</span> <span class="toc-text">CSRF 攻击的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-%E6%94%BB%E5%87%BB%E7%9A%84%E9%98%B2%E8%8C%83"><span class="toc-number">5.3.3.</span> <span class="toc-text">CSRF 攻击的防范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">什么是 XSS 攻击？如何防范 XSS 攻击？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E6%94%BB%E5%87%BB"><span class="toc-number">5.4.1.</span> <span class="toc-text">XSS 攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E6%94%BB%E5%87%BB%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">5.4.2.</span> <span class="toc-text">XSS 攻击的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E6%94%BB%E5%87%BB%E7%9A%84%E9%98%B2%E8%8C%83"><span class="toc-number">5.4.3.</span> <span class="toc-text">XSS 攻击的防范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-SQL-%E6%B3%A8%E5%85%A5%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-SQL-%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">什么是 SQL 注入？如何防范 SQL 注入？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%B3%A8%E5%85%A5"><span class="toc-number">5.5.1.</span> <span class="toc-text">SQL 注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">5.5.2.</span> <span class="toc-text">SQL 注入的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%B3%A8%E5%85%A5%E7%9A%84%E9%98%B2%E8%8C%83"><span class="toc-number">5.5.3.</span> <span class="toc-text">SQL 注入的防范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-C-%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89borrow-check%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9F"><span class="toc-number">5.6.</span> <span class="toc-text">在 C++中，如果没有borrow check，有什么移动语义的最佳实践？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%EF%BC%9A%E5%86%85%E5%AD%98%E6%B1%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E6%B1%A0%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%81%E8%BF%9E%E6%8E%A5%E6%B1%A0%E3%80%81%E7%BC%93%E5%86%B2%E6%B1%A0%E3%80%81%E5%8D%8F%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.7.</span> <span class="toc-text">并发编程中的池化技术：内存池、进程池、线程池、连接池、缓冲池、协程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.7.1.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0%E3%80%81%E5%8D%8F%E7%A8%8B%E6%B1%A0%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.7.2.</span> <span class="toc-text">进程池、协程池、线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clang-%E5%92%8C-g"><span class="toc-number">5.8.</span> <span class="toc-text">clang++ 和 g++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#clang"><span class="toc-number">5.8.1.</span> <span class="toc-text">clang++</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACE-libev-muduo"><span class="toc-number">5.9.</span> <span class="toc-text">ACE, libev, muduo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4cpp"><span class="toc-number">5.10.</span> <span class="toc-text">4cpp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cmake"><span class="toc-number">5.11.</span> <span class="toc-text">cmake</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">5.12.</span> <span class="toc-text">压力测试工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">5.13.</span> <span class="toc-text">分布式服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC"><span class="toc-number">5.14.</span> <span class="toc-text">RPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOC"><span class="toc-number">5.15.</span> <span class="toc-text">DOC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">5.16.</span> <span class="toc-text">微服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%B8%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.17.</span> <span class="toc-text">裸指针是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#glibc-%E5%92%8C-musl%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.18.</span> <span class="toc-text">glibc 和 musl的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">5.18.1.</span> <span class="toc-text">动态链接与静态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E5%8A%A3%E5%8A%BF%EF%BC%9A"><span class="toc-number">5.18.2.</span> <span class="toc-text">动态链接和静态链接各自的优劣势：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">5.18.3.</span> <span class="toc-text">socket 网络编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">5.18.4.</span> <span class="toc-text">内存泄漏</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/02/%E5%B0%B1%E4%B8%9A/%E3%80%90%E7%A7%8B%E6%8B%9B%E3%80%91%E5%A4%A7%E7%BA%B2/" title="No title"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2025/07/02/%E5%B0%B1%E4%B8%9A/%E3%80%90%E7%A7%8B%E6%8B%9B%E3%80%91%E5%A4%A7%E7%BA%B2/" title="No title">No title</a><time datetime="2025-07-02T01:28:57.400Z" title="Created 2025-07-02 09:28:57">2025-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/20/%E5%B0%B1%E4%B8%9A/%E7%A7%8B%E6%8B%9B%E7%AE%80%E5%8E%86/" title="RESUME for 2025 Fall"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RESUME for 2025 Fall"/></a><div class="content"><a class="title" href="/2025/04/20/%E5%B0%B1%E4%B8%9A/%E7%A7%8B%E6%8B%9B%E7%AE%80%E5%8E%86/" title="RESUME for 2025 Fall">RESUME for 2025 Fall</a><time datetime="2025-04-20T02:58:03.039Z" title="Created 2025-04-20 10:58:03">2025-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/15/%E5%A4%A7%E4%B8%89%E8%AF%BE%E7%A8%8B/%E3%80%90%E5%A4%A7%E4%B8%89%E4%B8%8B%E3%80%91%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E8%B7%B5/" title="No title"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2025/04/15/%E5%A4%A7%E4%B8%89%E8%AF%BE%E7%A8%8B/%E3%80%90%E5%A4%A7%E4%B8%89%E4%B8%8B%E3%80%91%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E8%B7%B5/" title="No title">No title</a><time datetime="2025-04-14T16:26:17.661Z" title="Created 2025-04-15 00:26:17">2025-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/18/%E5%BC%80%E5%8F%91/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" title="No title"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2025/01/18/%E5%BC%80%E5%8F%91/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" title="No title">No title</a><time datetime="2025-01-18T07:41:13.254Z" title="Created 2025-01-18 15:41:13">2025-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/18/SentryOps/%E5%89%8D%E7%BD%AE%E5%AD%A6%E4%B9%A0/" title="No title"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2025/01/18/SentryOps/%E5%89%8D%E7%BD%AE%E5%AD%A6%E4%B9%A0/" title="No title">No title</a><time datetime="2025-01-18T05:54:22.315Z" title="Created 2025-01-18 13:54:22">2025-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By Val</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">纯粹的心，感受意义不明</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>