<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【CMU 15-445】数据库系统 | Val-Blog</title><meta name="author" content="Val,10425999@qq.com, val213666@gmail.com"><meta name="copyright" content="Val"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="课程：【CMU 15-445】数据库系统课本：Database System Concepts, 7th Edition, by Silberschatz, Korth, and Sudarshan Chapter 1 A database-management system (DBMS) consists of a collection of interrelated data and a co">
<meta property="og:type" content="article">
<meta property="og:title" content="【CMU 15-445】数据库系统">
<meta property="og:url" content="https://val213.github.io/2024/08/24/%E3%80%90CMU%2015-445%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Val-Blog">
<meta property="og:description" content="课程：【CMU 15-445】数据库系统课本：Database System Concepts, 7th Edition, by Silberschatz, Korth, and Sudarshan Chapter 1 A database-management system (DBMS) consists of a collection of interrelated data and a co">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2024-08-24T09:47:58.168Z">
<meta property="article:modified_time" content="2024-09-24T03:52:00.061Z">
<meta property="article:author" content="Val">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://val213.github.io/2024/08/24/%E3%80%90CMU%2015-445%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: Val","link":"Link: ","source":"Source: Val-Blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【CMU 15-445】数据库系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-24 11:52:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://github.com/val213/image/blob/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230630230143.jpg?raw=true" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">119</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">96</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">16</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Val-Blog"><span class="site-name">Val-Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【CMU 15-445】数据库系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-08-24T09:47:58.168Z" title="Created 2024-08-24 17:47:58">2024-08-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-09-24T03:52:00.061Z" title="Updated 2024-09-24 11:52:00">2024-09-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/">知识分享</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【CMU 15-445】数据库系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>课程：【CMU 15-445】数据库系统<br>课本：Database System Concepts, 7th Edition, by Silberschatz, Korth, and Sudarshan</p>
<h1 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h1><ul>
<li>A database-management system (DBMS) consists of a collection of interrelated data and a collection of programs to access those data. The data describe one particular enterprise</li>
</ul>
<blockquote>
<p>ACID 是数据库管理系统（DBMS）中事务处理的四个关键属性的首字母缩写，分别代表原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。这些属性确保了数据库事务的可靠性和数据的完整性。<br><strong>原子性（Atomicity）：</strong><br>原子性确保事务中的所有操作要么全部完成，要么全部不完成。换句话说，事务是不可分割的最小工作单元。如果事务中的任何一个操作失败，整个事务将回滚到事务开始前的状态。<br>例如，在银行转账操作中，资金从一个账户扣除并添加到另一个账户，这两个操作要么都成功，要么都不执行。<br><strong>一致性（Consistency）：</strong><br>一致性确保事务在完成时，数据库从一个一致状态转换到另一个一致状态。事务的执行不能违反数据库的完整性约束。<br>例如，如果数据库有一个约束规定账户余额不能为负数，那么在事务完成后，这个约束仍然必须成立。<br><strong>隔离性（Isolation）：</strong><br>隔离性确保并发执行的事务彼此之间不互相干扰。每个事务的中间状态对其他事务是不可见的，事务之间的操作是隔离的。<br>例如，在一个事务完成之前，其他事务不能看到它的未提交数据。<br><strong>持久性（Durability）：</strong><br>持久性确保一旦事务提交，其结果将永久保存在数据库中，即使系统发生故障（如电源故障或崩溃），事务的结果也不会丢失。<br>例如，一旦银行转账操作成功提交，即使系统崩溃，转账结果也会被保留。</p>
<h2 id="view-of-Data"><a href="#view-of-Data" class="headerlink" title="view of Data"></a>view of Data</h2><h3 id="Data-Modles"><a href="#Data-Modles" class="headerlink" title="Data Modles"></a>Data Modles</h3><p>A collection of tools for describing <strong>data</strong>, <strong>data relationships</strong>, <strong>data semantics</strong>, and consistency <strong>constraints</strong>.</p>
<h4 id="Relational-Model-关系模型"><a href="#Relational-Model-关系模型" class="headerlink" title="Relational Model 关系模型"></a>Relational Model 关系模型</h4><p>本文的大部分内容都集中在关系模型上，因为它是大多数数据库应用程序的基础。</p>
</blockquote>
<p>关系模型使用一组表来表示数据和这些数据之间的关系。每个表有多个列，每个列有一个惟一的名称。表也被称为关系。关系模型是基于记录的模型的一个例子。基于记录的模型之所以如此命名，是因为数据库是由几种类型的固定格式记录构成的。每个表包含特定类型的记录。每个记录类型定义了固定数量的字段或属性。表的列对应于记录类型的属性。关系数据模型是使用最广泛的数据模型，目前绝大多数数据库系统都是基于关系模型的。</p>
<p>第2章和第7章详细介绍了关系模型</p>
<h4 id="Entity-Relationship-Model-实体关系（E-R）模型"><a href="#Entity-Relationship-Model-实体关系（E-R）模型" class="headerlink" title="Entity-Relationship Model 实体关系（E-R）模型"></a>Entity-Relationship Model 实体关系（E-R）模型</h4><p>实体-关系(E-R)数据模型使用一组称为实体的基本对象，以及这些对象之间的关系。实体是现实世界中有别于其他对象的“事物”或“对象”。实体-关系模型在数据库设计中应用广泛。第六章对此进行了详细的探讨。</p>
<h4 id="Semi-structured-Data-Model-半结构化数据模型"><a href="#Semi-structured-Data-Model-半结构化数据模型" class="headerlink" title="Semi-structured Data Model 半结构化数据模型"></a>Semi-structured Data Model 半结构化数据模型</h4><p>半结构化数据模型允许对数据进行规范，其中相同类型的单个数据项可能具有不同的属性集。这与前面提到的数据模型相反，在数据模型中，特定类型的每个数据项必须具有相同的一组属性。JSON和可扩展标记语言(XML)是广泛使用的半结构化数据表示。第8章将详细探讨半结构化数据模型。</p>
<h4 id="Object-Based-Data-Model-基于对象的数据模型"><a href="#Object-Based-Data-Model-基于对象的数据模型" class="headerlink" title="Object-Based Data Model 基于对象的数据模型"></a>Object-Based Data Model 基于对象的数据模型</h4><p>面向对象编程(特别是在Java、c++或c#中)已经成为占主导地位的软件开发方法。这最初导致了一种独特的面向对象数据模型的开发，但是今天对象的概念已经很好地集成到关系数据库中。存在将对象存储在关系表中的标准。数据库系统允许将过程存储在数据库系统中，并由数据库系统执行。这可以看作是用封装、方法和对象标识的概念扩展关系模型。第8章总结了基于对象的数据模型。</p>
<h3 id="Relational-Model"><a href="#Relational-Model" class="headerlink" title="Relational Model"></a>Relational Model</h3><p>在关系模型中，数据以表的形式表示。每个表有多个列，每个列有一个惟一的名称。表格的每一行代表一条信息。图1.1给出了一个示例关系数据库，其中包含两个表:一个表显示大学教师的详细信息，另一个表显示大学各个院系的详细信息。</p>
<p>例如，第一个表是教员表，它显示了一个ID为22222、名叫Einstein的教员，他是物理系的一员，年薪为95,000美元。例如，第二张表格“部门”显示生物系位于沃森大楼，预算为9万美元。当然，现实世界中的大学会有更多的院系和教师。我们在课文中用小表格来说明概念。可以在网上找到相同模式的更大示例。<br><img src="image-422.png" alt="alt text"></p>
<h3 id="Data-Abstraction"><a href="#Data-Abstraction" class="headerlink" title="Data Abstraction"></a>Data Abstraction</h3><p>图1.2显示了三个抽象层次之间的关系。<br><img src="image-423.png" alt="alt text"><br>数据库系统允许应用程序开发人员使用数据模型的抽象来存储和检索数据，并将抽象操作转换为低级实现上的操作。</p>
<p>对编程语言中数据类型概念的类比可以澄清抽象级别之间的区别。许多高级编程语言都支持结构化类型的概念。例如C中的结构体，C++中的类，Java中的类。结构化类型允许程序员定义新的数据类型，这些数据类型由多个字段组成。</p>
<p>在物理层，教员、院系或学生的记录可以被描述为一个连续的字节块。编译器对程序员隐藏了这一层次的细节。类似地，数据库系统对数据库程序员隐藏了许多最底层的存储细节。另一方面，数据库管理员可能知道数据的物理组织的某些细节。例如，有许多可能的方法将表存储在文件中。一种方法是将表存储为文件中的记录序列，使用特殊字符(例如逗号)来分隔记录的不同属性，并且可以使用另一个特殊字符(例如换行字符)来分隔记录。如果所有属性都有固定的长度，那么属性的长度可以单独存储，并且可以从文件中省略分隔符。可变长度属性可以通过存储长度，然后存储数据来处理。数据库使用一种称为索引的数据结构来支持对记录的有效检索;这些也构成了物理层的一部分。</p>
<p>在逻辑级别上，每个这样的记录由类型定义描述，如前面的代码段所示。这些记录类型的相互关系也在逻辑级别上定义;教员记录的部门名称值必须出现在部门表中的要求就是这种相互关系的一个例子。使用编程语言的程序员在这个抽象层次上工作。类似地，数据库管理员通常在这个抽象级别上工作。</p>
<p>最后，在视图层，计算机用户看到一组隐藏数据类型细节的应用程序。在视图级别，定义了数据库的几个视图，数据库用户可以看到其中的一些或全部视图。除了隐藏数据库逻辑级别的详细信息外，视图还提供了一种安全机制，以防止用户访问数据库的某些部分。例如，大学注册办公室的职员只能看到数据库中有学生信息的那部分;他们无法获得有关教师工资的信息。</p>
<h3 id="Instances-and-Schemas-实例和模式"><a href="#Instances-and-Schemas-实例和模式" class="headerlink" title="Instances and Schemas 实例和模式"></a>Instances and Schemas 实例和模式</h3><p>数据库随着信息的插入和删除而变化。在特定时刻存储在数据库中的信息集合称为数据库的实例。数据库的总体设计称为数据库模式。数据库模式和实例的概念可以类比为用编程语言编写的程序来理解。数据库模式对应于程序中的变量声明(以及相关的类型定义)。每个变量在给定的时刻都有一个特定的值。程序中变量的值在某个时间点对应于数据库模式的实例。</p>
<p>数据库系统有几个模式，根据抽象级别进行分区。物理模式在物理层描述数据库设计，而逻辑模式在逻辑层描述数据库设计。数据库在视图级别也可能有多个模式(有时称为子模式)，它们描述数据库的不同视图。</p>
<h2 id="Database-Languages"><a href="#Database-Languages" class="headerlink" title="Database Languages"></a>Database Languages</h2><p>数据库系统提供数据定义语言DDL (data-definition language)来指定数据库模式，提供数据操作语言DML (data-manipulation language)来表达数据库查询和更新。实际上，数据定义语言和数据操作语言并不是两种独立的语言;相反，它们只是构成单一数据库语言的一部分，比如SQL语言。几乎所有的关系数据库系统都使用SQL语言，我们将在第3章、第4章和第5章详细介绍。</p>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p>我们通过一组由称为数据定义语言(DDL)的特殊语言表示的定义来指定数据库模式。DDL还用于指定数据的其他属性。</p>
<p>我们通过一组语句指定数据库系统使用的存储结构和访问方法，这些语句使用一种称为数据存储和定义语言的特殊DDL类型。这些语句定义了数据库模式的实现细节，这些细节通常对用户是隐藏的。</p>
<p>存储在数据库中的数据值必须满足一定的一致性约束。</p>
<p>例如，假设大学要求某个部门的账户余额永远不能为负。DDL提供了指定此类约束的工具。数据库系统在每次更新数据库时检查这些约束。通常，约束可以是属于数据库的任意谓词。但是，任意谓词的测试成本可能很高。因此，数据库系统只实现那些可以用最小开销测试的完整性约束:</p>
<ul>
<li>Domain constraints: 指定每个属性的允许值的范围。<br>每个属性（例如，整数类型、字符类型、日期/时间类型）都必须与一个可能值的域相关联。将属性声明为特定域可作为对其可采用的值的约束。域约束是完整性约束的最基本形式。每当有新数据项输入数据库时​​，系统都可以轻松地测试它们。</li>
<li>Referential integrity: 指定两个关系之间的参照完整性。<br>在某些情况下，我们希望确保出现在给定属性集的一个关系中的值也出现在另一个关系中的某组属性中（参照完整性）。例如，每门课程列出的部门必须是大学中实际存在的部门。更准确地说，课程记录中的部门名称值必须出现在部门关系中某些记录的部门名称属性中。数据库修改可能导致违反参照完整性。当违反参照完整性约束时，正常程序是拒绝导致违规的操作。</li>
<li>Authorization: 指定哪些用户有权访问数据。<br>我们可能希望根据用户对数据库中各种数据值的访问权限类型来区分用户。这些区别以授权的形式表达，最常见的是：读取授权，允许读取数据，但不允许修改数据；插入授权，允许插入新数据，但不允许修改现有数据；更新授权，允许修改数据，但不允许删除数据；删除授权，允许删除数据。我们可以为用户分配所有、不分配或这些类型的授权的组合。</li>
</ul>
<p>DDL 语句的处理，就像任何其他编程语言的语句一样，会产生一些输出。DDL 的输出放在数据字典中，其中包含元数据，即有关数据的数据。数据字典被视为一种特殊类型的表，只能由数据库系统本身（而不是普通用户）访问和更新。数据库系统在读取或修改实际数据之前会查阅数据字典。</p>
<h3 id="The-SQL-Data-Definition-Language"><a href="#The-SQL-Data-Definition-Language" class="headerlink" title="The SQL Data-Definition Language"></a>The SQL Data-Definition Language</h3><p>最常见的sql文件中的语句。略。</p>
<h3 id="Data-Manipulation-Language"><a href="#Data-Manipulation-Language" class="headerlink" title="Data-Manipulation Language"></a>Data-Manipulation Language</h3><p>数据操作语言(DML)是一种使用户能够访问或操作由适当数据模型组织的数据的语言。访问的类型有:</p>
<ul>
<li>检索存储在数据库中的信息。</li>
<li>将新信息插入数据库。</li>
<li>删除数据库中的信息。</li>
<li>修改存储在数据库中的信息。<br>基本上有两种类型的数据操作语言:</li>
<li>Declarative DMLs （过程性 DML） 要求用户指定需要什么数据以及如何获得这些数据。</li>
<li>Declarative DMLs （声明性 DML，也称为非过程性dml）要求用户指定需要哪些数据，而不指定如何获取这些数据。<h3 id="Database-Access-from-Application-Programs"><a href="#Database-Access-from-Application-Programs" class="headerlink" title="Database Access from Application Programs"></a>Database Access from Application Programs</h3>数据库系统提供了一种接口，使应用程序可以访问数据库。这种接口允许应用程序员指定数据库操作，而不必关心数据存储和检索的细节。</li>
</ul>
<p>非过程查询语言（例如 SQL）不如通用图灵机强大；也就是说，有些计算可以使用通用编程语言进行，但使用 SQL 则无法完成。SQL 也不支持用户输入、显示输出或网络通信等操作。此类计算和操作必须用宿主语言（例如 C/C++、Java 或 Python）编写，并嵌入 SQL 查询以访问数据库中的数据。</p>
<p>应用程序是用于以这种方式与数据库交互的程序。大学系统中的示例是允许学生注册课程、生成班级名册、计算学生 GPA、生成工资支票和执行其他任务的程序。</p>
<p>要访问数据库，需要将DML语句从主机发送到数据库，在那里它们将被执行。这通常是通过使用应用程序编程接口来实现的，该接口可用于向数据库发送DML和DDL语句并检索结果。开放数据库连接(Open Database Connectivity, ODBC)标准定义了与C和其他几种语言一起使用的应用程序编程接口。Java数据库连接(JDBC)标准为Java语言定义了相应的接口。</p>
<h2 id="Database-Design"><a href="#Database-Design" class="headerlink" title="Database Design"></a>Database Design</h2><p>高级数据模型为数据库设计人员提供了一个概念框架，用于指定数据库用户的数据需求以及如何构建数据库以满足这些需求。数据库设计的初始阶段是充分描述潜在数据库用户的数据需求。数据库设计人员需要与领域专家和用户进行广泛的互动才能完成这项任务。此阶段的结果是用户需求的规范。接下来，设计人员选择一个数据模型，并通过应用所选数据模型的概念，将这些需求转化为数据库的概念模式。在此概念设计阶段开发的模式提供了企业的详细概述。设计人员审查该模式以确认所有数据需求确实得到满足并且彼此不冲突。设计人员还可以检查设计以删除任何冗余功能。此时的重点是描述数据及其关系，而不是指定物理存储细节。</p>
<p>就关系模型而言，概念设计过程涉及到我们希望在数据库中捕获哪些属性以及如何将这些属性分组以形成各种表的决策。“What”部分基本上是一个业务决策，我们将在本文中进一步讨论它。“How”部分主要是一个计算机科学问题。解决这个问题主要有两种方法。第一种是使用实体-关系模型(第6章);另一种是采用一组算法(统称为规范化)，将所有属性集合作为输入并生成一组表(第7章)。</p>
<p>一个完全开发的概念模式表明了企业的功能需求。在功能需求规范中，用户描述将对数据执行的操作（或事务）类型。示例操作包括修改或更新数据、搜索和检索特定数据以及删除数据。在概念设计的这个阶段，设计人员可以检查模式以确保它满足功能要求。从抽象数据模型转移到数据库实现的过程分为两个最终设计阶段。在逻辑设计阶段，设计人员将高级概念模式映射到将要使用的数据库系统的实现数据模型上。设计人员在随后的物理设计阶段使用生成的系统特定数据库模式，在此阶段指定数据库的物理特性。这些特性包括文件组织形式和内部存储结构；它们将在第 13 章中讨论。</p>
<h2 id="Database-Engine"><a href="#Database-Engine" class="headerlink" title="Database Engine"></a>Database Engine</h2><p>数据库系统被划分为处理整个系统各项职责的模块。数据库系统的功能组件大致可分为<strong>存储管理器、查询处理器组件和事务管理组件</strong>。</p>
<p><strong>The storage manager</strong> 存储管理器非常重要，因为数据库通常需要大量的存储空间。企业数据库的大小通常从数百 GB 到数 TB 不等。1 GB 大约等于 10 亿字节，即 1000 兆字节（更准确地说是 1024 兆字节），而 TB 大约等于 1 万亿字节或 100 万兆字节（更准确地说是 1024 GB）。最大的企业拥有的数据库达到数 PB 级（1 PB 等于 1024 TB）。由于计算机的主内存无法存储这么多信息，并且主内存的内容在系统崩溃时会丢失，因此信息存储在磁盘上。数据会根据需要在磁盘存储和主内存之间移动。由于数据进出磁盘的移动速度相对于中央处理器的速度较慢，因此数据库系统必须对数据进行结构化，以尽量减少在磁盘和主内存之间移动数据的需要。固态磁盘 (SSD) 越来越多地用于数据库存储。SSD 比传统磁盘更快，但成本也更高。</p>
<p><strong>The query processor</strong> 查询处理器很重要，因为它帮助数据库系统简化和方便对数据的访问。查询处理器允许数据库用户获得良好的性能，同时能够在视图级别上工作，而不必负担理解系统实现的物理层细节。数据库系统的工作是在逻辑层将用非过程性语言编写的更新和查询转换为物理层的高效操作序列。</p>
<p><strong>The transaction manager</strong> 事务管理器很重要，因为它允许应用程序开发人员将一系列数据库访问视为一个单元，要么全部发生，要么根本不发生。这允许应用程序开发人员在更高层次上思考应用程序，而无需关心管理并发访问数据和系统故障的影响的较低层次的细节。</p>
<p>虽然数据库引擎传统上是集中式计算机系统，但如今并行处理是高效处理大量数据的关键。现代数据库引擎非常重视并行数据存储和并行查询处理。</p>
<h3 id="Storage-Manager"><a href="#Storage-Manager" class="headerlink" title="Storage Manager"></a>Storage Manager</h3><p>存储管理器子系统提供数据库中存储的低级数据与提交给系统的应用程序和查询之间的接口。</p>
<ul>
<li><p>Authorization and integrity manager 授权和完整性管理器，用于测试是否满足完整性约束并检查用户访问数据的权限。</p>
</li>
<li><p>Transaction manager 事务管理器，它确保数据库在系统故障时保持一致(正确)状态，并发事务执行无冲突地进行。</p>
</li>
<li><p>File manager 文件管理器，它管理磁盘存储空间的分配和用于表示存储在磁盘上的信息的数据结构。</p>
</li>
<li><p>Buffer manager 缓冲区管理器，负责从磁盘存储中提取数据到主存，并决定在主存中缓存哪些数据。缓冲区管理器是数据库系统的关键部分，因为它使数据库能够处理比主内存大得多的数据大小。</p>
</li>
</ul>
<p>存储管理器在物理系统实现过程中实现了几种数据结构：</p>
<ul>
<li>Data files 数据文件，用于存储数据库本身。</li>
<li>Data dictionary 数据字典，用于存储有关数据库结构（特别是数据库模式）的元数据。</li>
<li>Indices 索引，用于快速访问数据项。与本教科书中的索引一样，数据库索引提供指向包含特定值的数据项的指针。<br>例如，我们可以使用索引查找具有特定 ID 的讲师记录，或具有特定名称的所有讲师记录。<br>我们在第 12 章和第 13 章中讨论了存储介质、文件结构和缓冲区管理。第 14 章讨论了有效访问数据的方法<h3 id="Query-Processor"><a href="#Query-Processor" class="headerlink" title="Query Processor"></a>Query Processor</h3>查询处理器子系统编译并执行 DDL 和 DML 语句。<br>查询处理器组件包括：</li>
<li>DDL interpreter DDL 解释器，解释 DDL 语句并将定义记录在<br>数据字典中。</li>
<li>DML compiler DML 编译器，将查询语言中的 DML 语句转换为由查询评估引擎<br>理解的低级指令组成的评估计划。查询通常可以转换为许多备选评估计划中的任何一个，这些计划都给出相同的结果。DML 编译器还执行<strong>查询优化</strong>；也就是说，它从备选方案中选择成本最低的评估计划。</li>
<li>Query evaluation engine 查询评估引擎，执行由 DML 编译器生成的低级指令</li>
</ul>
<p>Query evaluation 将在第15章中介绍，而查询优化器从可能的求值策略中选择的方法将在第16章中讨论</p>
<h3 id="Transaction-Manager"><a href="#Transaction-Manager" class="headerlink" title="Transaction Manager"></a>Transaction Manager</h3><p>事务管理确保数据库在系统发生故障时仍保持一致（正确）状态。事务管理器确保并发事务执行不会发生冲突。</p>
<p>事务是数据库应用程序中执行单个逻辑功能的操作的集合。每个事务都是原子性和一致性的单位。因此，我们要求事务不违反任何数据库一致性约束。也就是说，如果事务开始时数据库是一致的，则事务成功终止时数据库也必须是一致的。但是，在执行事务期间，可能需要暂时允许不一致，因为 A 的借记或 B 的贷记必须先于另一个完成。这种暂时的不一致虽然是必要的，但如果发生故障，可能会导致困难。</p>
<p>确保原子性和持久性属性是数据库系统本身的责任 - 具体来说，是<strong>恢复管理器</strong>的责任。在没有故障的情况下，所有事务都会成功完成，并且很容易实现原子性。但是，由于各种类型的故障，事务可能并不总是成功完成其执行。如果我们要确保原子性属性，则失败的事务必须对数据库的状态没有影响。因此，必须将数据库恢复到相关事务开始执行之前的状态。因此，数据库系统必须执行故障恢复，即它必须检测系统故障并将数据库恢复到故障发生之前的状态。</p>
<p>最后，当多个事务同时更新数据库时，即使每个单独的事务都是正确的，数据的一致性也可能不再得到保持。并发控制管理器负责控制并发事务之间的交互，以确保数据库的一致性。</p>
<p>事务管理器由并发控制管理器和恢复管理器组成(concurrency-control manager and the recovery manager)。</p>
<p>第 17 章介绍了事务处理的基本概念。第 18 章介绍了并发事务的管理。第 19 章详细介绍了故障恢复。</p>
<p>事务的概念已广泛应用于数据库系统和应用程序中。虽然事务最初是在金融应用程序中使用，但现在该概念已用于电信的实时应用程序，以及产品设计或管理工作流等长期活动的管理。</p>
<h2 id="Database-and-Application-Architecture"><a href="#Database-and-Application-Architecture" class="headerlink" title="Database and Application Architecture"></a>Database and Application Architecture</h2><p><img src="image-424.png" alt="alt text"><br>图 1.3 所示的集中式架构适用于共享内存服务器架构，这种架构具有多个 CPU 并利用并行处理，但所有 CPU 都访问一个公共共享内存。为了扩展到更大的数据量和更高的处理速度，并行数据库被设计为在由多台机器组成的集群上运行。此外，分布式数据库允许跨多个地理上分离的机器进行数据存储和查询处理。</p>
<p>在第20章中，我们将介绍现代计算机系统的一般结构，重点是并行系统体系结构。第21章和第22章描述了如何实现查询处理来利用并行和分布式处理。第23章介绍了在并行或分布式数据库中处理事务时出现的一些问题，并描述了如何处理每个问题。这些问题包括如何存储数据、如何确保在多个站点执行的事务的原子性、如何执行并发控制以及如何在出现故障时提供高可用性。</p>
<p>我们现在考虑使用数据库作为后端的应用程序的体系结构。数据库应用程序可以划分为两个或三个部分，如图1.4所示。早期的数据库应用程序使用两层体系结构，其中应用程序驻留在客户机机器上，并通过查询语言语句调用服务器机器上的数据库系统功能。</p>
<p>相比之下，现代数据库应用程序使用三层体系结构，其中客户机仅充当前端，不包含任何直接的数据库调用;Web浏览器和移动应用程序是当今最常用的应用程序客户机。前端与应用服务器通信。反过来，应用服务器与数据库系统通信以访问数据。应用程序的业务逻辑(说明在什么条件下执行什么操作)嵌入到应用程序服务器中，而不是分布在多个客户机上。三层应用程序比两层应用程序提供更好的安全性和性能。<br><img src="image-425.png" alt="alt text"></p>
<h2 id="Database-Users-and-Administrators"><a href="#Database-Users-and-Administrators" class="headerlink" title="Database Users and Administrators"></a>Database Users and Administrators</h2><p>数据库系统的主要目标是从数据库中检索信息并将新信息存储在数据库中。使用数据库的人可以分为数据库用户或数据库管理员。</p>
<h3 id="Database-Users-and-User-Interfaces"><a href="#Database-Users-and-User-Interfaces" class="headerlink" title="Database Users and User Interfaces"></a>Database Users and User Interfaces</h3><p>有四种不同类型的数据库系统用户，根据他们期望与系统交互的方式进行区分。针对不同类型的用户，设计了不同类型的用户界面。</p>
<ul>
<li>Native 用户是通过使用预定义的用户界面(如web或移动应用程序)与系统交互的简单用户。Native 用户的典型用户界面是 web 表单界面，用户可以在其中填写表单的适当字段。Native 用户还可以查看从数据库生成的已读报告。</li>
<li>应用程序程序员是编写应用程序的计算机专业人员。应用程序程序员可以从许多工具中选择开发用户界面。</li>
<li>资深用户无需编写程序即可与系统交互。相反，他们使用数据库查询语言或使用数据分析软件等工具来形成请求。提交查询以探索数据库中的数据的分析师属于这一类<h3 id="Database-Administrator"><a href="#Database-Administrator" class="headerlink" title="Database Administrator"></a>Database Administrator</h3>使用 DBMS 的主要原因之一是可以集中控制数据和访问这些数据的程序。对系统具有这种集中控制权的人称为数据库管理员 (DBA)。DBA 的功能包括：</li>
<li>Schema definition. 模式定义。DBA 通过执行 DDL 中的一组数据定义语句来创建原始数据库模式。</li>
<li>存储结构和访问方法定义。DBA 可以指定一些与数据的物理组织和要创建的索引有关的参数。</li>
<li>Schema and physical-organization modification. 模式和物理组织修改。DBA 对模式和物理组织进行更改以反映组织不断变化的需求，或更改物理组织以提高性能。</li>
<li>Granting of authorization for data access. 授予数据访问授权。通过授予不同类型的授权，数据库管理员可以规定不同用户可以访问数据库的哪些部分。授权信息保存在一个特殊的系统结构中，每当用户尝试访问系统中的数据时，数据库系统都会查阅该结构。</li>
<li>Routine maintenance. 日常维护。数据库管理员的日常维护活动示例包括：    <ul>
<li>定期将数据库备份到远程服务器，以防止在发生洪水等灾难时丢失数据。</li>
<li>确保有足够的可用磁盘空间用于正常操作，并根据需要升级磁盘空间。</li>
<li>监控数据库上运行的作业，并确保性能不会因某些用户提交的非常昂贵的任务而降低。<h2 id="History-of-Database-Systems"><a href="#History-of-Database-Systems" class="headerlink" title="History of Database Systems"></a>History of Database Systems</h2>20 世纪 70 年代末和 80 年代：尽管关系模型在学术上很有趣，但由于其性能缺陷，最初并未在实践中使用；关系数据库无法与现有的网络和层次化数据库的性能相匹配。随着 System R 的出现，这种情况发生了改变，这是 IBM 研究部门的一个开创性项目，开发了构建高效关系数据库系统的技术。功能齐全的 System R 原型促成了 IBM 的第一款关系数据库产品 SQL/DS 的诞生。与此同时，加州大学伯克利分校正在开发 Ingres 系统。它促成了同名的商业产品。同样在这个时候，Oracle 的第一个版本也发布了。最初的商业关系数据库系统（如 IBM DB2、Oracle、Ingres 和 DEC Rdb）在推进高效处理声明式查询的技术方面发挥了重要作用。到 20 世纪 80 年代初，关系数据库甚至在性能方面也与网络和分层数据库系统相媲美。关系数据库非常易于使用，最终取代了网络和分层数据库。</li>
</ul>
</li>
</ul>
<p>2000 年代：在此期间，存储在数据库系统中的数据类型发展迅速。半结构化数据变得越来越重要。XML 成为数据交换标准。JSON 是一种更紧凑的数据交换格式，非常适合存储来自 JavaScript 或其他编程语言的对象，随后变得越来越重要。随着主要商业系统增加了对 XML 和 JSON 格式的支持，越来越多的此类数据存储在关系数据库系统中。空间数据（即包含地理信息的数据）在导航系统和高级应用程序中得到广泛使用。数据库系统增加了对此类数据的支持。开源数据库系统（尤其是 PostgreSQL 和 MySQL）的使用率不断提高。数据库系统添加了“自动管理”功能，以便自动重新配置以适应不断变化的工作负载。这有助于减少管理数据库的人工工作量。</p>
<p>社交网络平台发展迅速，需要管理有关人们与其发布数据之间联系的数据，而这些数据并不适合表格行列格式。这导致了图形数据库的发展。<br>在本世纪后期，数据分析和数据挖掘在企业中的使用变得无处不在。数据库系统是专门为服务于这个市场而开发的。这些系统具有适合分析处理的物理数据组织，例如“列存储”，其中表格按列存储，而不是主要商业数据库系统的传统行式存储。<br>庞大的数据量，以及用于分析的大部分数据是文本或半结构化数据的事实，导致了 map-reduce 等编程框架的开发，以方便应用程序程序员使用并行性来分析数据。随着时间的推移，对这些功能的支持迁移到了传统数据库系统中。即使在 2010 年代后期，数据库研究界仍在争论一个数据库系统同时服务于传统事务处理应用程序和较新的数据分析应用程序与为这些角色维护单独的系统之间的相对优缺点。</p>
<p>各种新的数据密集型应用程序和快速开发的需求，尤其是初创公司的需求，导致了提供轻量级数据管理形式的“NoSQL”系统的出现。这个名字源于这些系统缺乏对无处不在的数据库查询语言 SQL 的支持，尽管这个名字现在通常被视为“不仅仅是 SQL”。由于缺乏基于关系模型的高级查询语言，程序员可以更灵活地处理新类型的数据。由于传统数据库系统不支持严格的数据一致性，因此应用程序使用分布式数据存储时可以更加灵活。NoSQL 的“最终一致性”模型允许数据的分布式副本不一致，只要它们最终会在没有进一步更新的情况下收敛即可。</p>
<h1 id="Chapter-2-Introduction-to-the-Relational-Model"><a href="#Chapter-2-Introduction-to-the-Relational-Model" class="headerlink" title="Chapter 2: Introduction to the Relational Model"></a>Chapter 2: Introduction to the Relational Model</h1><h2 id="Structure-of-Relational-Databases"><a href="#Structure-of-Relational-Databases" class="headerlink" title="Structure of Relational Databases"></a>Structure of Relational Databases</h2><p>关系数据库由一组表组成，每个表都有一个唯一的名称。</p>
<p>因此，在关系模型中，术语关系用于指代表，而术语元组用于指代行。类似地，术语属性指的是表中的一列。</p>
<p>我们使用术语“关系实例”来指代关系的特定实例，也就是说，它包含一组特定的行。图2.1所示的教员实例有12个元组，对应12个教员。</p>
<p>我们要求，对于所有关系r, r的所有属性的域都是原子的。</p>
<p>如果域的元素被认为是不可分割的单元，那么域就是原子的。</p>
<p>例如，假设表教练有一个属性电话号码，该属性可以存储与教练对应的一组电话号码。那么电话号码的域就不是原子的，因为域的元素是电话号码的集合，并且它有子部分，即集合中的单个电话号码。</p>
<p>重要的问题不是域本身是什么，而是我们如何在数据库中使用域元素。现在假设电话号码属性存储单个电话号码。即使这样，如果我们将电话号码属性的值拆分为国家代码、地区代码和本地号码，我们也会将其视为非原子值。如果我们将每个电话号码视为单个不可分割的单元，那么属性电话号码将具有一个原子域。</p>
<p>null值是一个特殊值，表示该值未知或不存在。例如，假设和前面一样，我们在教员关系中包含了属性电话号码。可能是教师根本没有电话号码，或者电话号码没有列出。然后，我们必须使用空值来表示该值未知或不存在。稍后我们将看到，当我们访问或更新数据库时，空值会导致许多困难，因此应该尽可能消除空值。我们首先假定空值不存在，在第3.6节中，我们将描述空值对不同操作的影响。</p>
<p>我们将看到，相对严格的关系结构在数据存储和处理方面带来了几个重要的实际优势。这种严格的结构适合定义良好且相对静态的应用程序，但不太适合不仅数据而且这些数据的类型和结构都随时间变化的应用程序。现代企业需要在结构化数据的效率和预定结构受限的情况之间找到良好的平衡。</p>
<h2 id="Database-Schema"><a href="#Database-Schema" class="headerlink" title="Database Schema"></a>Database Schema</h2><p>当我们谈论数据库时，我们必须区分数据库模式和数据库实例，前者是数据库的逻辑设计，后者是数据库中数据在给定时刻的快照。</p>
<p>关系（relation）的概念对应于变量的编程语言概念，而关系模式（relation schema）的概念对应于类型定义的编程语言概念。给定变量的值可能随时间变化;类似地，关系实例的内容可能随着关系的更新而改变。相反，关系的模式通常不会改变。</p>
<h2 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h2><p>我们必须有一种方法来指定如何区分给定关系中的元组。</p>
<p>这是用它们的属性来表示的。也就是说，元组的属性值的值必须能够唯一地标识该元组。换句话说，关系中的两个元组不允许对所有属性具有完全相同的值超键是一个或多个属性的集合，这些属性使我们能够在关系中唯一地标识一个元组。例如，关系指示器的ID属性足以区分一个指示器元组和另一个指示器元组。因此，ID是一个超级键。另一方面，instructor的name属性不是超级键，因为多个讲师可能具有相同的名称。</p>
<p>形式上，设R表示关系R模式中的属性集。如果我们说R的子集K是R的超键，我们将考虑限制在关系R的实例上，其中没有两个不同的元组在K的所有属性上具有相同的值。</p>
<p>也就是说，如果t1和t2在r中并且t1≠t2，那么t1。K≠t2。</p>
<p>A <strong>superkey</strong> may contain extraneous attributes. For example, the combination of ID and name is a superkey for the relation instructor. If K is a superkey, then so is any superset of K. We are often interested in superkeys for which no proper subset is a superkey. Such minimal superkeys are called candidate keys. 如果K是一个超键，那么K的任何超集也是一个超键。我们经常感兴趣的是那些没有合适子集是超键的超键。这样的最小超键称为候选键。</p>
<p>可能有几个不同的属性集可以作为候选键。</p>
<p>假设名称和部门名称的组合足以区分教员关系的成员。然后，{ID}和{name, dept name}都是候选键。虽然属性ID和name一起可以区分讲师元组，但它们的组合{ID, name}并不能形成候选键，因为属性ID本身就是一个候选键。</p>
<p>We shall use the term <strong>primary key</strong> to denote a candidate key that is chosen by the database designer as the principal means of dentifying tuples within a relation. A key (whether <strong>primary</strong>, <strong>candidate</strong>, or <strong>super</strong>) is a property of the entire relation, rather than of the individual tuples. Any two individual tuples in the relation are prohibited from having the same value on the key attributes at the same time. The designation of a key represents a constraint in the real-world enterprise being modeled. Thus, <strong>primary keys are also referred to as primary key constraints</strong>.</p>
<p>接下来，我们考虑对关系内容的另一种类型的约束，称为外键约束（foreign-key constraint）。考虑讲师关系的属性dept name。如果讲师中的元组的dept name值与部门关系中的部门不对应，则没有意义。因此，在任何数据库实例中，给定教员关系中的任意元组(例如ta)，在部门关系中必须存在某个元组(例如tb)，使得ta的dept name属性的值与tb的主键dept name的值相同。</p>
<p>A <strong>foreign-key constraint</strong> from attribute(s) A of relation r1 to the primary-key B of relation r2 states that on any database instance, the value of A for each tuple in r1 must also be the value of B for some tuple in r2. Attribute set A is called a <strong>foreign key</strong> from r1, referencing r2. The relation r1 is also called the <strong>referencing relation</strong> of the foreign-key constraint, and r2 is called the <strong>referenced relation</strong>.</p>
<p>注意，在外键约束中，被引用的属性必须是被引用关系的主键。更一般的情况是，引用完整性约束（referential integrity constraint）放宽了引用属性构成引用关系主键的要求。</p>
<p><strong>引用完整性约束（Referential Integrity Constraint）</strong> 的基本概念：引用完整性约束确保数据库中的关系（表）之间的数据一致性。具体来说，它要求在一个关系（表）中的某些属性（列）中的值必须在另一个关系（表）中的某些属性（列）中存在。</p>
<ul>
<li>引用关系（Referencing Relation）：<ul>
<li>这是包含外键（Foreign Key）的关系（表）。外键是一个或多个属性（列），它们引用另一个关系（表）的主键（Primary Key）。</li>
</ul>
</li>
<li>被引用关系（Referenced Relation）：<ul>
<li>这是被外键引用的关系（表）。被引用的属性通常是主键或具有唯一约束的属性。</li>
</ul>
</li>
</ul>
<p>引用完整性约束的要求</p>
<ul>
<li>外键约束：在引用关系中的外键属性的值必须在被引用关系的主键属性中存在。</li>
<li>数据一致性：这确保了引用关系中的每个外键值都能在被引用关系中找到对应的主键值。</li>
</ul>
<p>事实上，外键约束是引用完整性约束的一种特殊情况，其中引用的属性构成引用关系的主键。目前的数据库系统通常支持外键约束，但是它们不支持引用的属性不是主键的引用完整性约束。</p>
<h2 id="Schema-Diagrams"><a href="#Schema-Diagrams" class="headerlink" title="Schema Diagrams"></a>Schema Diagrams</h2><p>数据库模式以及主键和外键约束可以通过模式图来描述。图2.9显示了我们大学组织的架构图。每个关系显示为一个框，关系名称以蓝色显示在顶部，框内列出了属性。</p>
<p>主键属性用下划线显示。外键约束以箭头的形式显示，从引用关系的外键属性指向被引用关系的主键。我们使用双头箭头(而不是单头箭头)来指示不是外键约束的引用完整性约束。</p>
<p><img src="image-430.png" alt="alt text"></p>
<p>我们将在第6章详细讨论模式的另一种图解表示，称为实体-关系图;虽然在外观上有一些相似之处，但这两种符号有很大的不同，不应相互混淆。</p>
<h2 id="Relational-Query-Languages"><a href="#Relational-Query-Languages" class="headerlink" title="Relational Query Languages"></a>Relational Query Languages</h2><p>查询语言是用户从数据库请求信息时使用的语言。</p>
<p>这些语言通常在比标准编程语言更高的级别上。查询语言可以分为<strong>命令式、函数式和声明式</strong>。</p>
<p>在<strong>命令式查询语言</strong>中，用户指示系统对数据库执行特定的操作序列以计算期望的结果;这种语言通常有状态变量的概念，在计算过程中更新状态变量。</p>
<p>在<strong>函数查询语言</strong>中，计算被表示为对可能对数据库中的数据或对其他函数的结果进行操作的函数的求值;函数没有副作用，也不会更新程序状态在声明性查询语言中，用户描述所需的信息，而不给出获取该信息的特定步骤序列或函数调用;所需的信息通常使用某种形式的数学逻辑来描述。如何获取所需的信息是数据库系统的工作。</p>
<p>有许多“纯”查询语言。</p>
<ul>
<li><p>我们在2.6节中描述的关系代数是一种函数式查询语言关系代数构成了SQL查询语言的理论基础。</p>
</li>
<li><p>我们在第27章描述的元组关系演算和域关系演算是声明性的。</p>
</li>
</ul>
<p>这些查询语言简洁而正式，缺乏商业语言的“语法糖”，但它们演示了从数据库中提取数据的基本技术。</p>
<p>在实践中使用的查询语言，如SQL查询语言，包括命令式、函数式和声明式方法的元素。在第三章到第五章中，我们会学习使用非常广泛的查询语言SQL。</p>
<h2 id="The-Relational-Algebra-关系代数"><a href="#The-Relational-Algebra-关系代数" class="headerlink" title="The Relational Algebra 关系代数"></a>The Relational Algebra 关系代数</h2><p><img src="image-431.png" alt="alt text"><br><img src="image-432.png" alt="alt text"><br><img src="image-433.png" alt="alt text"></p>
<h3 id="The-Select-Operation"><a href="#The-Select-Operation" class="headerlink" title="The Select Operation"></a>The Select Operation</h3><p>select操作返回一个关系，该关系包含从输入关系中选择的元组。这些元组由选择条件指定。如果选择条件为空，则输出关系将包含与输入关系相同的元组。如果输入关系为空，则输出关系也为空。</p>
<h3 id="The-Project-Operation"><a href="#The-Project-Operation" class="headerlink" title="The Project Operation"></a>The Project Operation</h3><p>project操作返回一个关系，该关系包含从输入关系中选择的属性的元组。这些属性由属性列表指定。如果输入关系中有多个元组具有相同的属性值，则输出关系中只包含一个这样的元组。如果属性列表为空，则输出关系将包含一个元组，该元组的属性值为空。如果输入关系为空，则输出关系也为空。</p>
<h3 id="Composition-of-Relational-Operations"><a href="#Composition-of-Relational-Operations" class="headerlink" title="Composition of Relational Operations"></a>Composition of Relational Operations</h3><p>关系代数操作可以组合在一起。例如，可以将选择操作和投影操作组合在一起，以便选择一个关系的属性的子集，并且只包含满足某些条件的元组。这种组合称为查询计划。查询计划是一个关系代数表达式，它描述了如何从输入关系生成输出关系。查询计划可以包含一个或多个关系代数操作，这些操作以某种顺序应用于输入关系。例如，可以选择一个关系的属性的子集，然后选择满足某些条件的元组。这种组合称为查询计划。查询计划是一个关系代数表达式，它描述了如何从输入关系生成输出关系。查询计划可以包含一个或多个关系代数操作，这些操作以某种顺序应用于输入关系。</p>
<h3 id="The-Cartesian-Product-Operation"><a href="#The-Cartesian-Product-Operation" class="headerlink" title="The Cartesian-Product Operation"></a>The Cartesian-Product Operation</h3><p>笛卡尔积操作返回一个关系，该关系包含两个输入关系的所有可能的元组的组合。笛卡尔积操作是关系代数中最基本的操作之一。如果两个输入关系都为空，则输出关系也为空。</p>
<h3 id="The-Join-Operation"><a href="#The-Join-Operation" class="headerlink" title="The Join Operation"></a>The Join Operation</h3><p>join操作返回一个关系，该关系包含两个输入关系的元组的连接。连接是两个元组的笛卡尔积的子集，这两个元组满足某些连接条件。连接条件是两个关系的属性之间的等式。如果两个关系的属性之间没有等式，则连接条件为空，输出关系将包含两个输入关系的笛卡尔积。如果两个输入关系都为空，则输出关系也为空。</p>
<h3 id="Set-Operations"><a href="#Set-Operations" class="headerlink" title="Set Operations"></a>Set Operations</h3><p>关系代数支持集合操作，例如并集、交集和差集。并集操作返回两个关系的并集，交集操作返回两个关系的交集，差集操作返回两个关系的差集</p>
<h3 id="The-Assignment-Operation"><a href="#The-Assignment-Operation" class="headerlink" title="The Assignment Operation"></a>The Assignment Operation</h3><p>assignment操作将一个关系的结果分配给一个关系变量。关系变量是一个关系的名称，它可以用于表示关系的结果。关系变量可以用作关系代数表达式的输入。例如，可以将一个关系的结果分配给一个关系变量，然后使用该关系变量作为另一个关系的输入。关系变量可以用作关系代数表达式的输入。例如，可以将一个关系的结果分配给一个关系变量，然后使用该关系变量作为另一个关系的输入。</p>
<h3 id="The-Rename-Operation"><a href="#The-Rename-Operation" class="headerlink" title="The Rename Operation"></a>The Rename Operation</h3><p>rename操作返回一个关系，该关系与输入关系相同，但是属性的名称可能不同。重命名操作用于更改属性的名称。如果输入关系为空，则输出关系也为空。</p>
<h3 id="Equivalent-Queries"><a href="#Equivalent-Queries" class="headerlink" title="Equivalent Queries"></a>Equivalent Queries</h3><p>在关系代数中，可以使用等价关系代数表达式来表示相同的查询。等价关系代数表达式是指两个关系代数表达式，它们返回相同的结果。例如，可以使用选择操作和投影操作来表示一个查询，也可以使用连接操作来表示该查询。在关系代数中，可以使用等价关系代数表达式来表示相同的查询。等价关系代数表达式是指两个关系代数表达式，它们返回相同的结果。例如，可以使用选择操作和投影操作来表示一个查询，也可以使用连接操作来表示该查询。</p>
<h2 id="chapter-27-Other-Data-Models"><a href="#chapter-27-Other-Data-Models" class="headerlink" title="chapter 27 Other Data Models"></a>chapter 27 Other Data Models</h2><h3 id="Document-Data-Model"><a href="#Document-Data-Model" class="headerlink" title="Document Data Model"></a>Document Data Model</h3><p>The document data model is a collection of record documents containing a hierarchy of named field/value<br>pairs. A field’s value can be either a scalar type, an array of values, or a pointer to another document.<br>Modern implementations use JSON. Older systems use XML or custom object representations.<br>The document model avoid ”relation-object impedance mismatch” by tightly coupling objects and database.<br>While there are certainly use cases for this model, it still runs into many of the problems discussed in the<br>flat file strawman example discussed earlier.</p>
<h3 id="Vector-Data-Model"><a href="#Vector-Data-Model" class="headerlink" title="Vector Data Model"></a>Vector Data Model</h3><p>The vector data model represents one-dimensional arrays used for nearest-neighbor search (exact or approximate). Vector databases are generally used for semantic search on embeddings generated by MLtrained transformer models (think ChatGPT), and native integration with modern ML tools and APIs (e.g.,<br>LangChain, OpenAI). At their core, these systems use specialized indexes to perform NN searches quickly.<br>Recently, many relational DBMSs have shipped vector index features or extensions (pgvector) that allow<br>NN search within the relational model</p>
<h1 id="Chapter-3-Introduction-to-SQL"><a href="#Chapter-3-Introduction-to-SQL" class="headerlink" title="Chapter 3: Introduction to SQL"></a>Chapter 3: Introduction to SQL</h1><h2 id="3-1-Overview-of-the-SQL-Query-Language"><a href="#3-1-Overview-of-the-SQL-Query-Language" class="headerlink" title="3.1 Overview of the SQL Query Language"></a>3.1 Overview of the SQL Query Language</h2><p>The SQL language has several parts:</p>
<ul>
<li>Data-definition language (DDL). The SQL DDL provides commands for defining relation schemas, deleting relations, and modifying relation schemas.</li>
<li>Data-manipulation language (DML). The SQL DML provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database.</li>
<li>Integrity. The SQL DDL includes commands for specifying integrity constraints that the data stored in the database must satisfy. Updates that violate integrity constraints are disallowed. SQL DDL包括用于指定存储在数据库中的数据必须满足的完整性约束的命令。不允许违反完整性约束的更新。</li>
<li>View definition. The SQL DDL includes commands for defining views. SQL DDL包括用于定义视图的命令。</li>
<li>Transaction control. SQL includes commands for specifying the beginning and end points of transactions. SQL包括用于指定事务开始点和结束点的命令。</li>
<li>Embedded SQL and dynamic SQL. Embedded and dynamic SQL define how SQL statements can be embedded within general-purpose programming languages, such as C, C++, and Java. 嵌入式和动态SQL定义了如何将SQL语句嵌入到通用编程语言(如C、c++和Java)中</li>
<li>Authorization. The SQL DDL includes commands for specifying access rights to relations and views. SQL DDL包括用于指定对关系和视图的访问权限的命令。<h2 id="3-2-SQL-Data-Definition"><a href="#3-2-SQL-Data-Definition" class="headerlink" title="3.2 SQL Data Definition"></a>3.2 SQL Data Definition</h2>The set of relations in a database are specified using a data-definition language (DDL).<br>The SQL DDL allows specification of not only a set of relations, but also information about each relation, including:</li>
<li>The schema for each relation.</li>
<li>The types of values associated with each attribute.</li>
<li>The integrity constraints.</li>
<li>The set of indices to be maintained for each relation.</li>
<li>The security and authorization information for each relation.</li>
<li>The physical storage structure of each relation on disk.</li>
</ul>
<p>我们在这里讨论基本模式定义和基本类型;我们把对其他SQL DDL特性的讨论推迟到第4章和第5章。</p>
<h3 id="Basic-Types"><a href="#Basic-Types" class="headerlink" title="Basic Types"></a>Basic Types</h3><p><img src="image-434.png" alt="alt text"></p>
<h3 id="Basic-Schema-Definition"><a href="#Basic-Schema-Definition" class="headerlink" title="Basic Schema Definition"></a>Basic Schema Definition</h3><p>SQL支持许多不同的完整性约束。在本节中，我们只讨论其中的几个:</p>
<ul>
<li>主键约束</li>
<li>外键约束</li>
<li>not null 约束<br>create、drop、delete、alter<h2 id="3-3-Basic-Structure-of-SQL-Queries"><a href="#3-3-Basic-Structure-of-SQL-Queries" class="headerlink" title="3.3 Basic Structure of SQL Queries"></a>3.3 Basic Structure of SQL Queries</h2>SQL查询的基本结构由三个子句组成:select、from和where。</li>
</ul>
<p>查询将from子句中列出的关系作为输入，按照where和select子句中指定的方式对它们进行操作，然后生成一个关系作为结果。我们将通过示例介绍SQL语法，并在后面描述SQL查询的一般结构。</p>
<p>我们使用alter table命令向现有关系添加属性。关系中的所有元组都被指定为null作为新属性的值。alter table命令的形式是</p>
<h3 id="Queries-on-a-Single-Relation"><a href="#Queries-on-a-Single-Relation" class="headerlink" title="Queries on a Single Relation"></a>Queries on a Single Relation</h3><h3 id="Queries-on-Multiple-Relations"><a href="#Queries-on-Multiple-Relations" class="headerlink" title="Queries on Multiple Relations"></a>Queries on Multiple Relations</h3><p>查询通常需要访问来自多个关系的信息。<br>例如，假设我们想要回答“检索所有教员的姓名，以及他们的部门名称和部门大楼名称”这个查询。查看关系指导器的模式，我们意识到可以从属性dept name获得部门名称，但是部门构建名称出现在关系部门的属性构建中。要回答查询，教员关系中的每个元组必须与部门关系中dept name值与教员元组的dept name值匹配的元组相匹配。</p>
<p>在SQL中，为了回答上述查询，我们在from子句中列出需要访问的关系，并在where子句中指定匹配条件。上面的查询可以用SQL编写为<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, instructor.dept name, building</span><br><span class="line"><span class="keyword">from</span> instructor, department</span><br><span class="line"><span class="keyword">where</span> instructor.dept name<span class="operator">=</span> department.dept name;</span><br></pre></td></tr></table></figure></p>
<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><h4 id="natural-join"><a href="#natural-join" class="headerlink" title="natural join"></a>natural join</h4><p>没有公共属性的时候退化为笛卡尔积</p>
<h5 id="danger-of-nartual-join"><a href="#danger-of-nartual-join" class="headerlink" title="danger of nartual join"></a>danger of nartual join</h5><h2 id="3-4-Additional-Basic-Operations"><a href="#3-4-Additional-Basic-Operations" class="headerlink" title="3.4 Additional Basic Operations"></a>3.4 Additional Basic Operations</h2><h3 id="the-rename-operation"><a href="#the-rename-operation" class="headerlink" title="the rename operation"></a>the rename operation</h3><p>使用 as 闭包</p>
<h3 id="String-Operations"><a href="#String-Operations" class="headerlink" title="String Operations"></a>String Operations</h3><h3 id="Attribute-Specification-in-the-Select-Clause"><a href="#Attribute-Specification-in-the-Select-Clause" class="headerlink" title="Attribute Specification in the Select Clause"></a>Attribute Specification in the Select Clause</h3><h3 id="Ordering-the-Display-of-Tuples"><a href="#Ordering-the-Display-of-Tuples" class="headerlink" title="Ordering the Display of Tuples"></a>Ordering the Display of Tuples</h3><h3 id="Set-Operations-1"><a href="#Set-Operations-1" class="headerlink" title="Set Operations"></a>Set Operations</h3><h2 id="3-6-Null-Values"><a href="#3-6-Null-Values" class="headerlink" title="3.6 Null Values"></a>3.6 Null Values</h2><p>由于where子句中的谓词可以涉及布尔操作，如and、or，而不是对比较的结果，因此布尔操作的定义被扩展为处理 unknown。</p>
<h2 id="3-7-Aggregate-Functions"><a href="#3-7-Aggregate-Functions" class="headerlink" title="3.7 Aggregate Functions"></a>3.7 Aggregate Functions</h2><p>聚合函数是接受值的集合(一组或多组)作为输入并返回单个值的函数。SQL提供了五个标准的内置聚合函数:</p>
<ul>
<li>Average: avg</li>
<li>Minimum: min</li>
<li>Maximum: max</li>
<li>Total: sum</li>
<li>Count: count<br>sum和avg的输入必须是数字的集合，但其他操作符也可以操作非数字数据类型的集合，比如字符串。<h3 id="Basic-Aggregation"><a href="#Basic-Aggregation" class="headerlink" title="Basic Aggregation"></a>Basic Aggregation</h3><h3 id="Aggregation-with-Grouping"><a href="#Aggregation-with-Grouping" class="headerlink" title="Aggregation with Grouping"></a>Aggregation with Grouping</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept name, <span class="built_in">avg</span> (salary) <span class="keyword">as</span> avg salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当SQL查询使用分组时，重要的是要确保出现在select语句中而不被聚合的属性是那些出现在group by子句中的属性。换句话说，group by子句中没有出现的任何属性都可能只作为聚合函数的参数出现在select子句中，否则该查询将被视为错误。例如，下面的查询是错误的，因为ID没有出现在group by子句中，但是它出现在select子句中而没有被聚合:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* erroneous query */</span></span><br><span class="line"><span class="keyword">select</span> dept name, ID, <span class="built_in">avg</span> (salary)</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept name;</span><br></pre></td></tr></table></figure><br>在前面的查询中，特定组(由dept name定义)中的每个教练可以有不同的ID，并且由于每个组只输出一个元组，因此没有唯一的方法来选择输出哪个ID值。因此，SQL不允许这样的情况。</p>
<h3 id="The-Having-Clause"><a href="#The-Having-Clause" class="headerlink" title="The Having Clause"></a>The Having Clause</h3><p>有时，声明一个<strong>适用于组而不是元组的条件</strong>是有用的。例如，我们可能只对教师平均工资超过4.2万美元的院系感兴趣。此条件不适用于单个元组；相反，它适用于group by子句构造的每个组。为了表达这样的查询，我们使用SQL的having子句。SQL在组形成后在having子句中应用谓词，<strong>因此可以在having子句中使用聚合函数</strong>。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept name, <span class="built_in">avg</span> (salary) <span class="keyword">as</span> avg salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept name</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span> (salary) <span class="operator">&gt;</span> <span class="number">42000</span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>SQL关键字执行顺序<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span>slect A1, agg_fun <span class="keyword">as</span> X</span><br><span class="line"><span class="operator">&gt;</span><span class="keyword">from</span> a,b</span><br><span class="line"><span class="operator">&gt;</span><span class="keyword">where</span> P1</span><br><span class="line"><span class="operator">&gt;</span>gruop <span class="keyword">by</span> A1</span><br><span class="line"><span class="operator">&gt;</span><span class="keyword">Having</span> P2</span><br></pre></td></tr></table></figure><br><img src="image-446.png" alt="alt text"></p>
<h3 id="Aggregation-with-Null-and-Boolean-Values"><a href="#Aggregation-with-Null-and-Boolean-Values" class="headerlink" title="Aggregation with Null and Boolean Values"></a>Aggregation with Null and Boolean Values</h3><h2 id="3-8-Nested-Subqueries"><a href="#3-8-Nested-Subqueries" class="headerlink" title="3.8 Nested Subqueries"></a>3.8 Nested Subqueries</h2><h3 id="Set-Membership"><a href="#Set-Membership" class="headerlink" title="Set Membership"></a>Set Membership</h3><p>SQL allows testing tuples for membership <strong>in</strong> a relation. The in connective tests for set membership, where the set is a collection of values produced by a select clause. The <strong>not in</strong> connective tests for the absence of set membership.</p>
<h3 id="Set-Comparison"><a href="#Set-Comparison" class="headerlink" title="Set Comparison"></a>Set Comparison</h3><h3 id="Test-for-Empty-Relations"><a href="#Test-for-Empty-Relations" class="headerlink" title="Test for Empty Relations"></a>Test for Empty Relations</h3><p>SQL包含一个特性，用于测试子查询的结果中是否有任何元组。如果参数子查询非空，exists构造返回值true。使用exists结构，我们可以用另一种方式编写查询“查找2017年秋季学期和2018年春季学期教授的所有课程”:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course id</span><br><span class="line"><span class="keyword">from</span> section <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> semester<span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span><span class="operator">=</span> <span class="number">2017</span> <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">from</span> section <span class="keyword">as</span> T</span><br><span class="line">        <span class="keyword">where</span> semester<span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span><span class="operator">=</span> <span class="number">2018</span> <span class="keyword">and</span> </span><br><span class="line">        S.course id<span class="operator">=</span> T.course_id);</span><br></pre></td></tr></table></figure><br>上面的查询还说明了SQL的一个特性，即可以在where子句中的子查询中使用来自外部查询(上面查询中的S)的关联名称。</p>
</blockquote>
<p>使用来自外部查询的关联名称的子查询称为相关子查询。</p>
<h3 id="Test-for-the-Absence-of-Duplicate-Tuples"><a href="#Test-for-the-Absence-of-Duplicate-Tuples" class="headerlink" title="Test for the Absence of Duplicate Tuples"></a>Test for the Absence of Duplicate Tuples</h3><p>todo!()</p>
<h3 id="Subqueries-in-the-From-Clause"><a href="#Subqueries-in-the-From-Clause" class="headerlink" title="Subqueries in the From Clause"></a>Subqueries in the From Clause</h3><p>todo!()</p>
<h3 id="The-With-Clause"><a href="#The-With-Clause" class="headerlink" title="The With Clause"></a>The With Clause</h3><p>with子句提供了一种定义临时关系的方法，该临时关系的定义仅对出现with子句的查询可用。<br>考虑以下查询，该查询查找预算最大的部门。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> max budget (<span class="keyword">value</span>) <span class="keyword">as</span></span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">max</span>(budget)</span><br><span class="line"><span class="keyword">from</span> department)</span><br><span class="line"><span class="keyword">select</span> budget</span><br><span class="line"><span class="keyword">from</span> department, max budget</span><br><span class="line"><span class="keyword">where</span> department.budget <span class="operator">=</span> max budget.value;</span><br></pre></td></tr></table></figure><br>当然，我们可以创建一个不使用with子句的等效查询，但这样做会更复杂，也更难以理解。您可以编写等效的查询作为练习。</p>
<h3 id="Scalar-Subqueries"><a href="#Scalar-Subqueries" class="headerlink" title="Scalar Subqueries"></a>Scalar Subqueries</h3><p>只要允许表达式返回值，SQL就允许子查询，只要子查询<strong>只返回一个包含单个属性的元组</strong>；这样的子查询称为<strong>标量子查询</strong>。例如，可以在 select 子句中使用子查询，如下面的示例所示，该子查询列出了所有部门以及每个部门的教师数量:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept name,</span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> department.dept name <span class="operator">=</span> instructor.dept name)</span><br><span class="line"><span class="keyword">as</span> num instructors</span><br><span class="line"><span class="keyword">from</span> department;</span><br></pre></td></tr></table></figure><br><img src="image-450.png" alt="alt text"><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span> (<span class="keyword">distinct</span> ID)</span><br><span class="line"><span class="keyword">from</span> takes</span><br><span class="line"><span class="keyword">where</span> (course_id,sec_id,semester,<span class="keyword">year</span>) <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> course_id, sec_id, semester, <span class="keyword">year</span> <span class="keyword">from</span> teaches</span><br><span class="line"><span class="keyword">where</span> teaches<span class="number">.1</span>D<span class="operator">=</span> <span class="number">10101</span>);</span><br></pre></td></tr></table></figure><br>用with子句重写<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> T <span class="keyword">as</span></span><br><span class="line">(<span class="keyword">select</span> course id, sec id, semester, <span class="keyword">year</span></span><br><span class="line"><span class="keyword">from</span> teaches</span><br><span class="line"><span class="keyword">where</span> teaches.ID<span class="operator">=</span> <span class="number">10101</span>)</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span> (<span class="keyword">distinct</span> ID)</span><br><span class="line"><span class="keyword">from</span> takes</span><br><span class="line"><span class="keyword">where</span> (course_id, sec_id, semester, <span class="keyword">year</span>) <span class="keyword">in</span> T;</span><br></pre></td></tr></table></figure></p>
<h3 id="Scalar-Without-a-From-Clause"><a href="#Scalar-Without-a-From-Clause" class="headerlink" title="Scalar Without a From Clause"></a>Scalar Without a From Clause</h3><p>某些查询需要计算，但不需要引用任何关系。类似地，某些查询可能具有包含from子句的子查询，而顶级查询不需要from子句。</p>
<p>作为一个例子，假设我们希望找到每个教师教授的平均节数(无论学年或学期)，每个教师计算一次由多个教师教授的节数。我们需要计算教学中的元组数量来找到教学的总节数，并计算教师中的元组数量来找到教师的数量。然后一个简单的除法就得到了我们想要的结果。可以这样写:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">/</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> instructor) <span class="keyword">as</span> avg class size</span><br><span class="line"><span class="keyword">from</span> teaches;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-9-Modification-of-the-Database"><a href="#3-9-Modification-of-the-Database" class="headerlink" title="3.9 Modification of the Database"></a>3.9 Modification of the Database</h2><h3 id="Deletion"><a href="#Deletion" class="headerlink" title="Deletion"></a>Deletion</h3><p>注意，虽然一次只能从一个关系中删除元组，但是可以在delete的where子句中嵌套的select-from-where中引用任意数量的关系。删除请求可以包含一个嵌套的选择，该选择引用要从中删除元组的关系。例如，假设我们想要删除所有工资低于大学平均水平的教师的记录。我们可以这样写:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span> (salary) <span class="keyword">from</span> instructor);</span><br></pre></td></tr></table></figure><br>delete语句首先测试关系教员中的每个元组，以检查其工资是否低于大学教员的平均工资。然后，删除所有通过测试的元组(即代表工资低于平均水平的教员)。<strong>在执行任何删除之前执行所有测试是很重要的——如果在测试其他元组之前删除了一些元组，则平均薪水可能会发生变化，并且删除的最终结果将取决于处理元组的顺序！</strong></p>
<h3 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h3><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><h2 id="HW1"><a href="#HW1" class="headerlink" title="HW1"></a>HW1</h2><ul>
<li>列出文件处理系统和DBMS之间的四个重要区别。<br>数据库管理系统和文件处理系统之间的一些主要区别是:</li>
</ul>
<ol>
<li>两个系统都包含数据集合和访问该数据的一组程序。数据库管理系统协调对数据的物理访问和逻辑访问，而文件处理系统只协调物理访问。</li>
<li>数据库管理系统通过确保物理数据对所有被授权访问它的程序可用来减少数据重复的数量，而一个程序在文件处理系统中写入的数据可能无法被另一个程序读取。</li>
<li>数据库管理系统被设计为允许灵活访问数据(即查询)，而文件处理系统被设计为允许预先确定访问数据(即编译程序)。</li>
<li>数据库管理系统旨在协调多个用户同时访问相同的数据。文件处理系统通常被设计成允许一个或多个程序同时访问不同的数据文件。在文件处理系统中，只有当两个程序都对文件具有只读访问权限时，两个程序才能并发地访问该文件</li>
</ol>
<ul>
<li><p>请列出至少两个原因，说明为什么数据库系统支持使用声明性查询语言(如SQL)进行数据操作，而不是仅仅提供C或c++函数库来执行数据操作。<br>a.声明式语言对于程序员来说更容易学习和使用(对于非程序员来说更是如此)。<br>b.程序员不必担心如何编写查询来确保查询的高效执行;选择一种有效的执行技术留给数据库系统。声明性规范使数据库系统更容易做出正确的执行技术选择。</p>
</li>
<li><p>数据库管理员的五个主要功能是什么?</p>
</li>
</ul>
<ol>
<li>备份数据</li>
<li>在某些情况下，创建模式定义</li>
<li>定义存储结构和访问方法</li>
<li>在必要时修改模式和/或物理组织</li>
<li>授予数据访问授权</li>
<li>指定完整性约束</li>
</ol>
<h1 id="chapter-4：Intermediate-SQL"><a href="#chapter-4：Intermediate-SQL" class="headerlink" title="chapter 4：Intermediate SQL"></a>chapter 4：Intermediate SQL</h1><h2 id="4-1-Join-Expressions"><a href="#4-1-Join-Expressions" class="headerlink" title="4.1 Join Expressions"></a>4.1 Join Expressions</h2><h3 id="join-condition"><a href="#join-condition" class="headerlink" title="join condition"></a>join condition</h3><p>考虑下面的查询，它有一个包含on条件的连接表达式。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">join</span> takes <span class="keyword">on</span> student.ID<span class="operator">=</span> takes.ID;</span><br></pre></td></tr></table></figure><br>上面的 on 条件指定，如果 student 的元组与 takes 的元组 ID 值相等，则这两个元组匹配。本例中的连接表达式与 student 自然连接 takes 的连接表达式几乎相同，因为自然连接操作也要求 student 元组和 takes 元组匹配。唯一的区别是，在连接结果中，结果的 ID 属性列出了两次，一次是 student，一次是 takes，尽管它们的 ID 值必须相同。</p>
<p>In fact, the above query is equivalent to the following query (in other words, they generate exactly the same results):<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student, takes</span><br><span class="line"><span class="keyword">where</span> student.ID<span class="operator">=</span> takes.ID;</span><br></pre></td></tr></table></figure></p>
<p><strong>on条件可以表示任何SQL谓词(predicate)</strong>，因此使用on条件的连接表达式可以表示比自然连接更丰富的连接条件类。但是，正如前面的示例所示，<strong>使用带on条件的连接表达式的查询可以被不带on条件的等效表达式替换</strong>，并将on子句中的谓词移动到where子句中。因此，on条件似乎是SQL的一个冗余特性。</p>
<p>然而，引入on条件有两个很好的理由。首先，我们将很快看到，对于一种称为外连接的连接，on条件的行为方式与where条件不同。其次，<strong>如果在on子句中指定连接条件，而其余条件出现在where子句中，那么SQL查询通常更容易被人读懂。</strong></p>
<h3 id="outer-joins"><a href="#outer-joins" class="headerlink" title="outer joins"></a>outer joins</h3><p>假设我们希望显示所有学生的列表，显示他们的ID、姓名、专业名称、学分以及他们修过的课程。下面的SQL查询可以检索所需的信息:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">natural</span> <span class="keyword">join</span> takes;</span><br></pre></td></tr></table></figure><br>不幸的是，上面的查询并没有像预期的那样工作。假设有一个学生没有上过课。那么，该特定学生的student关系中的元组将不满足与takes关系中的任何元组进行自然连接的条件，并且该学生的数据将不会出现在结果中。因此，我们不会看到没有参加考试的学生的任何信息</p>
<p>更一般地说，<strong>连接的关系中的一个或两个关系中的一些元组可能会以这种方式“丢失”</strong>。外部连接操作的工作方式类似于我们已经研究过的连接操作，但是通过<strong>在结果中创建包含空值的元组来保留那些在连接中丢失的元组</strong>。外部连接操作有三种类型:左外连接、右外连接和完全外连接。</p>
<ul>
<li>左外连接仅在左外连接操作之前(在其左边)命名的关系中保留元组。</li>
<li>右外连接仅在以右外连接操作的右侧命名的关系中保留元组。</li>
<li>完整的外部连接保留两个关系中的元组。<h3 id="left-outer-join"><a href="#left-outer-join" class="headerlink" title="left outer join"></a>left outer join</h3><img src="image-456.png" alt="alt text"><h3 id="right-outer-join"><a href="#right-outer-join" class="headerlink" title="right outer join"></a>right outer join</h3><img src="image-457.png" alt="alt text"><h3 id="full-outer-join"><a href="#full-outer-join" class="headerlink" title="full outer join"></a>full outer join</h3>完全外连接是左外连接和右外连接类型的组合。</li>
</ul>
<p>操作计算出内连接的结果后，它会将左侧关系中与右侧关系中不匹配的元组扩展为空值，并将它们添加到结果中。同样，它会将右侧关系中与左侧关系中不匹配的元组扩展为空值，并将它们添加到结果中。</p>
<p>作为使用完整外部连接的一个示例，请考虑以下查询:“显示Comp. Sci.数据库中所有学生的列表。”以及他们在2009年春季修过的课程部分(如果有的话);从2009年春季开始的所有课程部分必须显示，即使没有学生来自 the Comp.Sci。系里已经有了课程部分。”这个查询可以写成:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> dept name<span class="operator">=</span> ’Comp. Sci’)</span><br><span class="line"><span class="keyword">natural</span> <span class="keyword">full</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">(<span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> takes</span><br><span class="line"><span class="keyword">where</span> semester <span class="operator">=</span> ’Spring’ <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2009</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="inner-join"><a href="#inner-join" class="headerlink" title="inner join"></a>inner join</h3><p>我们前面研究的不保留不匹配元组的连接操作称为内部连接操作，以区别于外部连接操作。</p>
<h3 id="Join-Types-and-Conditions"><a href="#Join-Types-and-Conditions" class="headerlink" title="Join Types and Conditions"></a>Join Types and Conditions</h3><p>为了区分普通连接和外部连接，<strong>普通连接在SQL中称为内连接</strong>。因此，join clause 可以指定内部连接而不是外部连接，以指定要使用普通连接。<strong>关键字 inner 是可选的</strong>。<strong>当不使用外部前缀的连接子句时，默认的连接类型是内部连接</strong>。</p>
<p>类似地，<strong>natural join is equivalent to natural inner join</strong>。</p>
<p>图4.6显示了我们讨论过的各种连接类型的完整列表。<br><img src="image-455.png" alt="alt text"><br>从图中可以看出，任何形式的连接(内连接、左外连接、右外连接或全外连接)都可以与任何连接条件(自然连接、使用连接或on连接)组合。</p>
<h2 id="4-2-Views"><a href="#4-2-Views" class="headerlink" title="4.2 Views"></a>4.2 Views</h2><p>到目前为止，在我们的示例中，我们一直在逻辑模型级别进行操作。也就是说，我们假设给定的集合中的关系是存储在数据库中的实际关系。</p>
<p>除了安全问题之外，我们可能希望创建一个个性化的关系集合，它比逻辑模型更符合特定用户的直觉。</p>
<p>可以计算并存储查询的结果，然后将存储的关系提供给用户。但是，如果我们这样做了，并且关系讲师、课程或部分中的基础数据发生了变化，那么存储的查询结果将不再与对关系重新执行查询的结果相匹配。一般来说，计算和存储诸如上述示例中的查询结果是一个坏主意(尽管有一些例外，我们将在后面研究)。</p>
<p>相反，SQL允许查询定义“虚拟关系”，并且关系在概念上包含查询的结果。虚拟关系不是预先计算和存储的，而是在使用虚拟关系时通过执行查询来计算的。</p>
<p>任何这样的关系，如果不是逻辑模型的一部分，但作为虚拟关系对用户可见，则称为视图。在任何给定的一组实际关系之上支持大量视图是可能的。</p>
<h3 id="View-Definition"><a href="#View-Definition" class="headerlink" title="View Definition"></a>View Definition</h3><p>我们使用create view命令在SQL中定义视图。要定义视图，我们必须给视图一个名称，并且必须说明计算视图的查询。create view命令的格式是:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v <span class="keyword">as</span> <span class="operator">&lt;</span>query expression<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="Using-Views-in-SQL-Queries"><a href="#Using-Views-in-SQL-Queries" class="headerlink" title="Using Views in SQL Queries"></a>Using Views in SQL Queries</h3><p>一个视图可以在定义另一个视图的表达式中使用。</p>
<h3 id="Materialized-Views"><a href="#Materialized-Views" class="headerlink" title="Materialized Views"></a>Materialized Views</h3><p>某些数据库系统允许存储视图关系，但它们确保，如果视图定义中使用的实际关系发生变化，则视图保持最新状态。这样的视图称为物化视图。</p>
<p>例如，考虑视图部门的总工资。如果实现了上述视图，其结果将存储在数据库中。但是，如果向讲师关系添加或删除了讲师元组，则定义视图的查询结果将发生变化，因此必须更新物化视图的内容。类似地，如果更新了教员的工资，则必须更新与该教员所在部门相对应的部门总工资中的元组。</p>
<p>当定义视图的任何关系更新时，可以立即进行视图维护。但是，有些数据库系统在访问视图时执行视图维护是惰性的。有些系统只是周期性地更新物化视图;在这种情况下，物化视图的内容在使用时可能是陈旧的，也就是说，不是最新的，如果应用程序需要最新的数据，就不应该使用它。一些数据库系统允许数据库管理员控制对每个物化视图使用上述方法中的哪一个。</p>
<h3 id="Update-of-a-View"><a href="#Update-of-a-View" class="headerlink" title="Update of a View"></a>Update of a View</h3><p>虽然视图是查询的有用工具，但是如果用视图表示更新、插入或删除，则会出现严重的问题。困难在于，用视图表示的对数据库的修改必须转换为对数据库逻辑模型中实际关系的修改。</p>
<p>由于诸如此类的问题，通常不允许修改视图关系，除非在有限的情况下。不同的数据库系统指定不同的条件来允许视图关系的更新;详细信息请参见数据库系统手册。通过视图修改数据库的一般问题一直是大量研究的主题，书目注释提供了一些这方面研究的指针。</p>
<p>一般来说，如果定义视图的查询满足以下条件，则SQL视图是可更新的(即可以在视图上应用插入、更新或删除操作):</p>
<ul>
<li>select子句只包含关系的属性名，不包含任何表达式、聚合或不同的规范。</li>
<li>任何未在select子句中列出的属性都可以设置为null;也就是说，它没有非空约束，也不是主键的一部分。</li>
<li>查询中没有group by或having子句</li>
</ul>
<blockquote>
<p>即使有了可更新性的条件，以下问题仍然存在。<br>假设用户试图将元组(‘ 25566 ‘，’ Brown ‘， ‘ Biology ‘， 100000)插入到历史教师视图中。这个元组可以插入到讲师关系中，但它不会出现在历史讲师视图中，因为它不满足视图强加的选择。<br>默认情况下，SQL将允许进行上述更新。但是，可以在视图定义的末尾使用with check选项子句来定义视图;然后，如果插入到视图中的元组不满足视图的where子句条件，则数据库系统将拒绝插入。同样，如果新值不满足where子句条件，则拒绝更新。<br>SQL:1999对于在视图上执行插入、更新和删除操作有更复杂的规则集，这允许通过更大的视图类进行更新;然而，这些规则太复杂了，无法在这里讨论。</p>
<h2 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h2><p>事务由一系列查询和/或更新语句组成。SQL标准指定在执行SQL语句时隐式地开始事务。下列SQL语句之一必须结束事务:</p>
</blockquote>
<ul>
<li>Commit work<br>提交当前事务;也就是说，它使事务执行的更新在数据库中成为永久性的。事务提交后，将自动启动一个新事务。</li>
<li>Rollback work<br>导致当前事务回滚;也就是说，它撤销事务中SQL语句执行的所有更新。因此，数据库状态将恢复到执行事务的第一条语句之前的状态。<h2 id="Integrity-Constraints"><a href="#Integrity-Constraints" class="headerlink" title="Integrity Constraints"></a>Integrity Constraints</h2>完整性约束确保授权用户对数据库所做的更改不会导致数据一致性的丢失。因此，完整性约束可以防止对数据库的意外损坏。</li>
</ul>
<p>通常，完整性约束可以是属于数据库的任意谓词。但是，任意谓词的测试成本可能很高。因此，大多数数据库系统允许指定可以用最小开销测试的完整性约束。</p>
<p>完整性约束通常被标识为数据库模式设计过程的一部分，并作为用于创建关系的create table命令的一部分声明。但是，也可以使用alter table table-name add constraint命令将完整性约束添加到现有关系中，其中的约束可以是关系上的任何约束。当执行这样的命令时，系统首先确保关系满足指定的约束。如果是，则将约束添加到关系中;如果不是，则拒绝该命令。</p>
<h3 id="Constraints-on-a-Single-Relation"><a href="#Constraints-on-a-Single-Relation" class="headerlink" title="Constraints on a Single Relation"></a>Constraints on a Single Relation</h3><h3 id="Not-Null-Constraint"><a href="#Not-Null-Constraint" class="headerlink" title="Not Null Constraint"></a>Not Null Constraint</h3><h3 id="Unique-Constraint"><a href="#Unique-Constraint" class="headerlink" title="Unique Constraint"></a>Unique Constraint</h3><h3 id="The-check-Clause"><a href="#The-check-Clause" class="headerlink" title="The check Clause"></a>The check Clause</h3><h3 id="Referential-Integrity"><a href="#Referential-Integrity" class="headerlink" title="Referential Integrity"></a>Referential Integrity</h3><ul>
<li>级联 cascade<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    group_id <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">foreign</span> key (group_id) <span class="keyword">references</span> t_group(id) <span class="keyword">on</span> <span class="keyword">delete</span> cascade <span class="keyword">on</span> <span class="keyword">update</span> cascade</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
那么<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t_group <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>; <span class="operator">/</span><span class="operator">/</span> 从表中有相关引用，导致 t_user 中 groupid 为<span class="number">2</span>的记录，被删除</span><br><span class="line"><span class="keyword">update</span> t_group <span class="keyword">set</span> id<span class="operator">=</span><span class="number">2</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="operator">/</span><span class="operator">/</span> 从表中有相关引用，导致 t_user 中 groupid 为<span class="number">1</span>的记录，被级联修改为<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li>置空 set null<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    group_id <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">foreign</span> key (group_id) <span class="keyword">references</span> t_group(id) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">set</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">set</span> <span class="keyword">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
那么<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t_group <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>; <span class="operator">/</span><span class="operator">/</span> 从表中有相关引用，导致 t_user 中 groupid 为<span class="number">2</span>的记录，groupid 被设置为<span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">update</span> t_group <span class="keyword">set</span> id<span class="operator">=</span><span class="number">2</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="operator">/</span><span class="operator">/</span> 从表中有相关引用，导致 t_user 中 groupid 为<span class="number">1</span>的记录，groupid 被设置为<span class="keyword">NULL</span></span><br></pre></td></tr></table></figure></li>
<li>禁止 no action<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    group_id <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">foreign</span> key (group_id) <span class="keyword">references</span> t_group(id) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">no</span> action <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">no</span> action</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
那么<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t_group <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="operator">/</span><span class="operator">/</span> 错误，从表中有相关引用，因此主表中无法删除</span><br><span class="line"><span class="keyword">update</span> t_group <span class="keyword">set</span> id<span class="operator">=</span><span class="number">2</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="operator">/</span><span class="operator">/</span> 错误，从表中有相关引用，因此主表中无法更新</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="integrity-constraints-Violations-During-Transactions"><a href="#integrity-constraints-Violations-During-Transactions" class="headerlink" title="integrity constraints Violations During Transactions"></a>integrity constraints Violations During Transactions</h3><p>事务可能由几个步骤组成，并且在一个步骤之后可能会暂时违反完整性约束，但是后面的步骤可能会删除该违反。</p>
<p>为了处理这种情况，SQL标准允许将最初延迟的子句添加到约束规范中;然后在事务结束时检查约束，而不是在中间步骤中检查约束。约束也可以指定为可延迟的，这意味着默认情况下立即检查约束，但在需要时可以延迟。对于声明为可延迟的约束，执行作为事务一部分延迟的语句set constraints constraint-list会导致对指定约束的检查延迟到该事务的末尾。</p>
<p>但是，您应该意识到默认行为是立即检查约束，并且许多数据库实现不支持延迟约束检查。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">### Build <span class="keyword">in</span></span><br><span class="line">?</span><br><span class="line">## <span class="keyword">SQL</span> Data Types <span class="keyword">and</span> Schemas</span><br><span class="line"></span><br><span class="line">### <span class="type">Date</span> <span class="keyword">and</span> <span class="type">Time</span> Types <span class="keyword">in</span> <span class="keyword">SQL</span></span><br><span class="line">### <span class="keyword">Default</span> <span class="keyword">Values</span></span><br><span class="line"><span class="keyword">SQL</span>允许为属性指定默认值，如下面的<span class="keyword">create</span> <span class="keyword">table</span>语句所示:</span><br><span class="line">```<span class="keyword">sql</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student</span><br><span class="line">(ID <span class="type">varchar</span> (<span class="number">5</span>),</span><br><span class="line">name <span class="type">varchar</span> (<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">dept name <span class="type">varchar</span> (<span class="number">20</span>),</span><br><span class="line">tot cred <span class="type">numeric</span> (<span class="number">3</span>,<span class="number">0</span>) <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line"><span class="keyword">primary</span> key (ID));</span><br></pre></td></tr></table></figure><br>将tottcred属性的默认值声明为0。因此，当将元组插入到student关系中时，如果没有为tottcred属性提供值，则将其值设置为0。下面的插入语句说明了插入如何省略tottcred属性的值。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span> (<span class="string">&#x27;12345&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;Biology&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="Index-Creation"><a href="#Index-Creation" class="headerlink" title="Index Creation"></a>Index Creation</h3><p>许多查询只引用文件中一小部分记录。例如，像“查找物理系的所有教师”或“查找ID为22201的学生的学分值”这样的查询只引用学生记录的一小部分。对于系统来说，读取每条记录并检查ID字段是否为ID“32556”，或者检查building字段是否为值“Physics”是低效的。</p>
<p>关系属性上的索引是一种数据结构，它允许数据库系统在关系中有效地找到具有该属性指定值的元组，而无需扫描关系的所有元组。</p>
<p>例如，如果我们在student关系的属性ID上创建索引，数据库系统可以直接找到具有任意指定ID值的记录，例如22201或44553，而无需读取student关系的所有元组。索引还可以在属性列表上创建，例如属性名称和学生的部门名称。</p>
<p>稍后，我们将在第11章中学习索引是如何实际实现的，包括一种特别广泛使用的索引，称为B+树索引。</p>
<p>尽管SQL语言没有正式定义任何用于创建索引的语法，但是许多数据库支持使用下面所示的语法创建索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index studentID index <span class="keyword">on</span> student(ID);</span><br></pre></td></tr></table></figure>
<p>上面的语句在关系student的属性ID上创建了一个名为studentID的索引。</p>
<p>当用户提交可以从使用索引中获益的SQL查询时，SQL查询处理器将自动使用该索引。例如，给定一个选择ID为22201的学生元组的SQL查询，SQL查询处理器将使用上面定义的索引studententid索引来查找所需的元组，而无需读取整个关系。</p>
<h3 id="Large-Object-Types"><a href="#Large-Object-Types" class="headerlink" title="Large-Object Types"></a>Large-Object Types</h3><p>当前一代的许多数据库应用程序需要存储的属性可能很大(数千字节)，例如照片，也可能非常大(许多兆字节甚至千兆字节)，例如高分辨率医学图像或视频剪辑。因此SQL为字符数据(clob)和二进制数据(blob)提供了大对象数据类型。这些数据类型中的字母“lob”代表“大型对象”。clob和blob数据类型的值可以存储在数据库中，也可以存储在数据库外部的文件中。在后一种情况下，数据库中存储的值是指向外部文件的指针。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">book review <span class="type">clob</span>(<span class="number">10</span>KB)</span><br><span class="line">image <span class="type">blob</span>(<span class="number">10</span>MB)</span><br><span class="line">movie <span class="type">blob</span>(<span class="number">2</span>GB)</span><br></pre></td></tr></table></figure><br>对于包含大型对象(多个兆字节到千兆字节)的结果元组，将整个大型对象检索到内存中是低效或不切实际的。相反，应用程序通常使用SQL查询来检索大型对象的“定位器”，然后使用定位器从编写应用程序本身的宿主语言操作该对象。例如，JDBC应用程序接口(见5.1.1节)允许获取一个定位符，而不是整个大对象;然后，可以使用定位器来获取小块的大对象，而不是一次性全部获取，这很像使用read函数调用从操作系统文件读取数据。</p>
<h3 id="User-Defined-Types"><a href="#User-Defined-Types" class="headerlink" title="User-Defined Types"></a>User-Defined Types</h3><p>SQL支持两种形式的用户定义数据类型。我们在这里讨论的第一种形式被称为不同类型。另一种形式，称为结构化数据类型，允许创建复杂的数据类型，包括嵌套的记录结构、数组和多重集。本章不涉及结构化数据类型。</p>
<p>同样，将直接以美元表示的货币价值与以英镑表示的货币价值进行比较也几乎肯定是一个编程错误。一个好的类型系统应该能够检测到这样的赋值或比较。为了支持这种检查，SQL提供了不同类型的概念。</p>
<p>create type子句可用于定义新类型。例如，下列语句:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> type Dollars <span class="keyword">as</span> <span class="type">numeric</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">final</span>;</span><br><span class="line"><span class="keyword">create</span> type Pounds <span class="keyword">as</span> <span class="type">numeric</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">final</span>;</span><br></pre></td></tr></table></figure><br>(关键字finalis在这种情况下并没有真正的意义，但SQL:1999标准要求它，原因我们在这里不讨论;有些实现允许省略final关键字。)然后可以使用新创建的类型，例如，作为关系的属性类型。例如，我们可以将部门表声明为:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department</span><br><span class="line">(dept name <span class="type">varchar</span> (<span class="number">20</span>),</span><br><span class="line">building <span class="type">varchar</span> (<span class="number">15</span>),</span><br><span class="line">budget Dollars);</span><br></pre></td></tr></table></figure><br>尝试将类型为dollar的值赋给类型为Pounds的变量会导致编译时错误，尽管两者是相同的数字类型。这样的赋值很可能是由于程序员的错误，程序员忘记了货币的差异。为不同的货币声明不同的类型有助于捕获此类错误。</p>
<p>SQL provides drop type and alter type clauses to drop or modify types that<br>have been created earlier.</p>
<h4 id="Domain-Types"><a href="#Domain-Types" class="headerlink" title="Domain Types"></a>Domain Types</h4><p>甚至在将用户定义类型添加到SQL之前(在SQL:1999中)，SQL就有一个类似但略有不同的域概念(在SQL-92中引入)，它可以向底层类型添加完整性约束。例如，我们可以像下面这样定义域ddollar。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> domain DDollars <span class="keyword">as</span> <span class="type">numeric</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>域ddollar可以用作属性类型，就像我们使用类型dollar一样。然而，类型和领域之间存在两个显著差异:</p>
<ol>
<li><p>Domain 可以在其上指定约束，例如非null，并且可以为域类型的变量定义默认值，而 User-Defined Types 不能在其上指定约束或默认值。User-Defined Types 不仅用于指定属性类型，而且还用于可能无法强制执行约束的SQL过程扩展。</p>
</li>
<li><p>Domain 不是强类型的。<strong>因此，只要底层类型兼容，一种域类型的值就可以分配给另一种域类型的值。</strong></p>
</li>
</ol>
<p>当应用于域时，check子句允许模式设计器指定一个谓词，声明来自该域的任何属性都必须满足该谓词。</p>
<h3 id="Create-Table-Extensions"><a href="#Create-Table-Extensions" class="headerlink" title="Create Table Extensions"></a>Create Table Extensions</h3><p>应用程序通常需要创建与现有表具有相同模式的表。SQL提供了一个类似创建表的扩展来支持这个任务。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> temp instructor <span class="keyword">like</span> instructor;</span><br></pre></td></tr></table></figure></p>
<p>当编写一个复杂的查询时，将查询结果存储为一个新表通常是有用的;这个表通常是临时的。需要两条语句，一条用于创建表(包含适当的列)，第二条用于将查询结果插入到表中。SQL:2003提供了一种更简单的技术来创建包含查询结果的表。例如，下面的语句创建了一个包含查询结果的表t1。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">as</span></span><br><span class="line">(<span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept name<span class="operator">=</span> ’Music’)</span><br><span class="line"><span class="keyword">with</span> data;</span><br></pre></td></tr></table></figure><br>根据SQL:2003标准的定义，如果省略with data子句，则创建表，但不填充数据。然而，即使省略了with data子句，也有许多实现在默认情况下用数据填充表。</p>
<p>上面的 <code>create table ... as</code> 语句与 <code>create view</code> 语句非常相似，两者都是通过查询定义的。主要区别在于表的内容是在创建表时设置的，而视图的内容总是反映当前查询结果。</p>
<h2 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h2><h3 id="Granting-and-Revoking-of-Privileges"><a href="#Granting-and-Revoking-of-Privileges" class="headerlink" title="Granting and Revoking of Privileges"></a>Granting and Revoking of Privileges</h3><p>SQL标准包括<strong>选择、插入、更新和删除</strong>特权。特权all privileges可以用作所有允许的特权的缩写形式。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="operator">&lt;</span>privilege list<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>relation name<span class="operator">&gt;</span> <span class="keyword">to</span> <span class="operator">&lt;</span><span class="keyword">user</span> list<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><br>要撤销授权，可以使用revoke语句。它的形式几乎与grant相同:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="operator">&lt;</span>privilege list<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>relation name<span class="operator">&gt;</span> <span class="keyword">from</span> <span class="operator">&lt;</span><span class="keyword">user</span> list<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="roles"><a href="#roles" class="headerlink" title="roles"></a>roles</h3><p>在数据库中创建了一组角色。可以将授权授予角色，其方式与授予单个用户的方式完全相同。每个数据库用户被授予一组角色(可能是空的)，她被授权执行这些角色。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> role <span class="operator">&lt;</span>role name<span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="operator">&lt;</span>privilege list<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>relation name<span class="operator">&gt;</span> <span class="keyword">to</span> <span class="operator">&lt;</span>role name<span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="operator">&lt;</span>role name<span class="operator">&gt;</span> <span class="keyword">to</span> <span class="operator">&lt;</span><span class="keyword">user</span> list<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><br>请注意，可以有一个角色链;例如，教学助理的角色可以授予所有教师。反过来，讲师的角色被授予所有院长。</p>
<p>因此，除了直接授予院长的特权外，院长角色继承了授予讲师和助教角色的所有特权。</p>
<h3 id="Authorization-on-Views"><a href="#Authorization-on-Views" class="headerlink" title="Authorization on Views"></a>Authorization on Views</h3><h3 id="Authorizations-on-Schema"><a href="#Authorizations-on-Schema" class="headerlink" title="Authorizations on Schema"></a>Authorizations on Schema</h3><h3 id="Transfer-of-Privileges"><a href="#Transfer-of-Privileges" class="headerlink" title="Transfer of Privileges"></a>Transfer of Privileges</h3><h3 id="Revoking-of-Privileges"><a href="#Revoking-of-Privileges" class="headerlink" title="Revoking of Privileges"></a>Revoking of Privileges</h3><h1 id="chapter-6-Formal-Relational-Query-Languages"><a href="#chapter-6-Formal-Relational-Query-Languages" class="headerlink" title="chapter 6: Formal Relational Query Languages"></a>chapter 6: Formal Relational Query Languages</h1><h2 id="The-Relational-Algebra"><a href="#The-Relational-Algebra" class="headerlink" title="The Relational Algebra"></a>The Relational Algebra</h2><h3 id="Formal-Definition-of-the-Relational-Algebra"><a href="#Formal-Definition-of-the-Relational-Algebra" class="headerlink" title="Formal Definition of the Relational Algebra"></a>Formal Definition of the Relational Algebra</h3><h3 id="Additional-Relational-Algebra-Operations"><a href="#Additional-Relational-Algebra-Operations" class="headerlink" title="Additional Relational-Algebra Operations"></a>Additional Relational-Algebra Operations</h3><h3 id="Extended-Relational-Algebra-Operations"><a href="#Extended-Relational-Algebra-Operations" class="headerlink" title="Extended Relational-Algebra Operations"></a>Extended Relational-Algebra Operations</h3><h4 id="Generalized-Projection"><a href="#Generalized-Projection" class="headerlink" title="Generalized Projection"></a>Generalized Projection</h4><h4 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h4><h5 id="MULTISET-RELATIONAL-ALGEBRA"><a href="#MULTISET-RELATIONAL-ALGEBRA" class="headerlink" title="MULTISET RELATIONAL ALGEBRA"></a>MULTISET RELATIONAL ALGEBRA</h5><p>与关系代数不同，SQL允许在输入关系和查询结果中复制多个元组。SQL标准定义查询的输出中每个元组有多少个副本，这又取决于输入关系中存在多少个元组副本。</p>
<p>为了对SQL的这种行为建模，关系代数的一个版本，称为多集关系代数，被定义为处理多集，即可能包含重复项的集合。</p>
<h1 id="chapter-7-Database-Design-and-the-E-R-Model"><a href="#chapter-7-Database-Design-and-the-E-R-Model" class="headerlink" title="chapter 7: Database Design and the E-R Model"></a>chapter 7: Database Design and the E-R Model</h1><h2 id="The-Entity-Relationship-Model"><a href="#The-Entity-Relationship-Model" class="headerlink" title="The Entity-Relationship Model"></a>The Entity-Relationship Model</h2><h3 id="Entity-Sets"><a href="#Entity-Sets" class="headerlink" title="Entity Sets"></a>Entity Sets</h3><h3 id="Relationship-Sets"><a href="#Relationship-Sets" class="headerlink" title="Relationship Sets"></a>Relationship Sets</h3><h2 id="E-R-Diagrams"><a href="#E-R-Diagrams" class="headerlink" title="E-R Diagrams"></a>E-R Diagrams</h2><p>E-R图可以用图形表达数据库的整体逻辑结构。E-R图简单而清晰，这在很大程度上解释了E-R模型被广泛使用的原因。<br><img src="image-460.png" alt="E-R关系图"></p>
<h3 id="Basic-Structure"><a href="#Basic-Structure" class="headerlink" title="Basic Structure"></a>Basic Structure</h3><ul>
<li><strong>分成两部分的矩形</strong>表示<strong>实体集</strong>。第一部分(在本教科书中是蓝色阴影部分)包含实体集的名称。第二部分包含实体集的所有属性的名称。</li>
<li><strong>菱形</strong>表示<strong>关系集</strong>。</li>
<li><strong>未分割的矩形</strong>表示<strong>关系集的属性</strong>。作为主键一部分的属性加下划线。</li>
<li><strong>双菱形</strong>表示链接到<strong>弱实体集的识别关系集</strong></li>
<li><strong>线</strong>将<em>实体集**</em>链接<em>*到</em>关系集*</li>
<li><strong>虚线</strong>将<em>关系集</em>的属性<strong>链接</strong>到<em>关系集</em>。</li>
<li><strong>双线</strong>表示<strong>关系集中实体的全部参与</strong>。</li>
<li>弱实体集<br>一个实体集合，<strong>其存在取决于另一个实体集合的存在</strong>。弱实体集合的实体通常没有唯一标识符，或者它们的唯一标识符是与其所属的实体集合的标识符相关的。<h3 id="Mapping-Cardinality"><a href="#Mapping-Cardinality" class="headerlink" title="Mapping Cardinality"></a>Mapping Cardinality</h3>一对一、一对多、多对一、多对多<br><img src="image-461.png" alt="alt text"></li>
</ul>
<p>类似于uml的类图，E-R图还提供了一种方法来指示关系集中每个实体参与关系的次数的更复杂约束。一行可以有关联的最小和最大基数，如l..h所示，其中l是最小基数，h是最大基数。最小值为1表示实体集在关系集中的总参与;也就是说，实体集中的每个实体至少出现在该关系集中的一个关系中。最大值为1表示实体最多参与一个关系，而最大值*表示没有限制。</p>
<h3 id="Complex-Attributes"><a href="#Complex-Attributes" class="headerlink" title="Complex Attributes"></a>Complex Attributes</h3><p><img src="image-462.png" alt="alt text"><br>图7.11还演示了一个多值属性电话号码，用“{电话号码}”表示，以及一个派生属性年龄，用“age()”表示。<br>建表的时候，多值属性的和主键单独建张表，其他剩下的统一建表。</p>
<h3 id="roles-1"><a href="#roles-1" class="headerlink" title="roles"></a>roles</h3><p>我们通过标记连接菱形和矩形的线来指示E-R图中的角色。课程实体集和prereq关系集之间的角色指标course id和prereq id如图7.12所示。</p>
<h3 id="Weak-Entity-Sets"><a href="#Weak-Entity-Sets" class="headerlink" title="Weak Entity Sets"></a>Weak Entity Sets</h3><p><img src="image-463.png" alt="alt text"></p>
<ul>
<li>弱实体的鉴别符用虚线下划线，而不是实线。</li>
<li>连接弱实体集和识别强实体集的关系集用双菱形表示</li>
</ul>
<h2 id="Reduction-to-Relational-Schemas"><a href="#Reduction-to-Relational-Schemas" class="headerlink" title="Reduction to Relational Schemas"></a>Reduction to Relational Schemas</h2><h3 id="Representation-of-Strong-Entity-Sets-with-Simple-Attributes"><a href="#Representation-of-Strong-Entity-Sets-with-Simple-Attributes" class="headerlink" title="Representation of Strong Entity Sets with Simple Attributes"></a>Representation of Strong Entity Sets with Simple Attributes</h3><h3 id="Representation-of-Strong-Entity-Sets-with-Complex-Attributes"><a href="#Representation-of-Strong-Entity-Sets-with-Complex-Attributes" class="headerlink" title="Representation of Strong Entity Sets with Complex Attributes"></a>Representation of Strong Entity Sets with Complex Attributes</h3><h3 id="Representation-of-Weak-Entity-Sets"><a href="#Representation-of-Weak-Entity-Sets" class="headerlink" title="Representation of Weak Entity Sets"></a>Representation of Weak Entity Sets</h3><h3 id="Representation-of-Relationship-Sets"><a href="#Representation-of-Relationship-Sets" class="headerlink" title="Representation of Relationship Sets"></a>Representation of Relationship Sets</h3><h4 id="Redundancy-of-Schemas"><a href="#Redundancy-of-Schemas" class="headerlink" title="Redundancy of Schemas"></a>Redundancy of Schemas</h4><p>将弱实体集连接到相应的强实体集的关系集被特殊处理。正如我们在第7.5.6节中提到的，这些关系是多对一的，没有描述性属性。此外，弱实体集的主键包含强实体集的主键。在图7.14的E-R图中，弱实体集区段通过关系集区段依赖于强实体集区段。section的主键是{course id, sec id, semester, year}， course的主键是course id。由于sec course没有描述性属性，因此sec course模式具有course id、sec id、semester和year属性。实体集部分的模式包括course id、sec id、semester和year(以及其他)属性。sec课程关系中的每个(course id, sec id, semester, year)组合也会出现在模式部分上的关系中，反之亦然。因此，sec课程模式是多余的。</p>
<p>通常，将弱实体集链接到其对应的强实体集的关系集模式是冗余的，并且不需要出现在基于E-R图的关系数据库设计中。</p>
<h4 id="Combination-of-Schemas"><a href="#Combination-of-Schemas" class="headerlink" title="Combination of Schemas"></a>Combination of Schemas</h4><ul>
<li>是全体参与的，那么必须合并</li>
<li>不是全体参与的，那么可以合并也可以不合并；如果合并，那么属性在某些行上的值将是空值NULL</li>
</ul>
<p>优化：</p>
<ul>
<li>有全参与的联系要优化<ul>
<li>course_dept, inst_dept,stu_dept,sec_class,sec_time_slot</li>
<li>去掉冗余 1-1，1-m（remove redundant）</li>
</ul>
</li>
<li>标识联系，不参与建表，不优化<ul>
<li>sec_course</li>
</ul>
</li>
<li>部分参与的可保留不优化<ul>
<li>advisor</li>
</ul>
</li>
<li>m:n 的联系，建表,不优化<ul>
<li>takes, teaches<h2 id="Entity-Relationship-Design-Issues"><a href="#Entity-Relationship-Design-Issues" class="headerlink" title="Entity-Relationship Design Issues"></a>Entity-Relationship Design Issues</h2></li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://val213.github.io">Val</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://val213.github.io/2024/08/24/%E3%80%90CMU%2015-445%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">https://val213.github.io/2024/08/24/%E3%80%90CMU%2015-445%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/25/%E3%80%90%E5%A4%A7%E4%B8%89%E4%B8%8A%E3%80%91%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" title="IT项目管理"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">IT项目管理</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/15/DragonOS/%E3%80%90DragonOS%E3%80%918.15%E5%91%A8%E4%BC%9A%E5%88%86%E4%BA%AB/" title="SIG-MAIN周会分享_0815"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">SIG-MAIN周会分享_0815</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/01/20/Redis/" title="Redis"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-20</div><div class="title">Redis</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://github.com/val213/image/blob/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230630230143.jpg?raw=true" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Val</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">119</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">96</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/val213"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/val213" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:val213666@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">记录跬步 e/acc</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1"><span class="toc-number">1.</span> <span class="toc-text">Chapter 1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#view-of-Data"><span class="toc-number">1.1.</span> <span class="toc-text">view of Data</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Modles"><span class="toc-number">1.1.1.</span> <span class="toc-text">Data Modles</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Relational-Model-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">Relational Model 关系模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Entity-Relationship-Model-%E5%AE%9E%E4%BD%93%E5%85%B3%E7%B3%BB%EF%BC%88E-R%EF%BC%89%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">Entity-Relationship Model 实体关系（E-R）模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Semi-structured-Data-Model-%E5%8D%8A%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">Semi-structured Data Model 半结构化数据模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-Based-Data-Model-%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">Object-Based Data Model 基于对象的数据模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Relational-Model"><span class="toc-number">1.1.2.</span> <span class="toc-text">Relational Model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Abstraction"><span class="toc-number">1.1.3.</span> <span class="toc-text">Data Abstraction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Instances-and-Schemas-%E5%AE%9E%E4%BE%8B%E5%92%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.4.</span> <span class="toc-text">Instances and Schemas 实例和模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Database-Languages"><span class="toc-number">1.2.</span> <span class="toc-text">Database Languages</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DDL"><span class="toc-number">1.2.1.</span> <span class="toc-text">DDL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-SQL-Data-Definition-Language"><span class="toc-number">1.2.2.</span> <span class="toc-text">The SQL Data-Definition Language</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Manipulation-Language"><span class="toc-number">1.2.3.</span> <span class="toc-text">Data-Manipulation Language</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Database-Access-from-Application-Programs"><span class="toc-number">1.2.4.</span> <span class="toc-text">Database Access from Application Programs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Database-Design"><span class="toc-number">1.3.</span> <span class="toc-text">Database Design</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Database-Engine"><span class="toc-number">1.4.</span> <span class="toc-text">Database Engine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Storage-Manager"><span class="toc-number">1.4.1.</span> <span class="toc-text">Storage Manager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Query-Processor"><span class="toc-number">1.4.2.</span> <span class="toc-text">Query Processor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transaction-Manager"><span class="toc-number">1.4.3.</span> <span class="toc-text">Transaction Manager</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Database-and-Application-Architecture"><span class="toc-number">1.5.</span> <span class="toc-text">Database and Application Architecture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Database-Users-and-Administrators"><span class="toc-number">1.6.</span> <span class="toc-text">Database Users and Administrators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Database-Users-and-User-Interfaces"><span class="toc-number">1.6.1.</span> <span class="toc-text">Database Users and User Interfaces</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Database-Administrator"><span class="toc-number">1.6.2.</span> <span class="toc-text">Database Administrator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#History-of-Database-Systems"><span class="toc-number">1.7.</span> <span class="toc-text">History of Database Systems</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-Introduction-to-the-Relational-Model"><span class="toc-number">2.</span> <span class="toc-text">Chapter 2: Introduction to the Relational Model</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Structure-of-Relational-Databases"><span class="toc-number">2.1.</span> <span class="toc-text">Structure of Relational Databases</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Database-Schema"><span class="toc-number">2.2.</span> <span class="toc-text">Database Schema</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Keys"><span class="toc-number">2.3.</span> <span class="toc-text">Keys</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Schema-Diagrams"><span class="toc-number">2.4.</span> <span class="toc-text">Schema Diagrams</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Relational-Query-Languages"><span class="toc-number">2.5.</span> <span class="toc-text">Relational Query Languages</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Relational-Algebra-%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0"><span class="toc-number">2.6.</span> <span class="toc-text">The Relational Algebra 关系代数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Select-Operation"><span class="toc-number">2.6.1.</span> <span class="toc-text">The Select Operation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Project-Operation"><span class="toc-number">2.6.2.</span> <span class="toc-text">The Project Operation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Composition-of-Relational-Operations"><span class="toc-number">2.6.3.</span> <span class="toc-text">Composition of Relational Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Cartesian-Product-Operation"><span class="toc-number">2.6.4.</span> <span class="toc-text">The Cartesian-Product Operation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Join-Operation"><span class="toc-number">2.6.5.</span> <span class="toc-text">The Join Operation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-Operations"><span class="toc-number">2.6.6.</span> <span class="toc-text">Set Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Assignment-Operation"><span class="toc-number">2.6.7.</span> <span class="toc-text">The Assignment Operation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Rename-Operation"><span class="toc-number">2.6.8.</span> <span class="toc-text">The Rename Operation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Equivalent-Queries"><span class="toc-number">2.6.9.</span> <span class="toc-text">Equivalent Queries</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-27-Other-Data-Models"><span class="toc-number">2.7.</span> <span class="toc-text">chapter 27 Other Data Models</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Document-Data-Model"><span class="toc-number">2.7.1.</span> <span class="toc-text">Document Data Model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Data-Model"><span class="toc-number">2.7.2.</span> <span class="toc-text">Vector Data Model</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-3-Introduction-to-SQL"><span class="toc-number">3.</span> <span class="toc-text">Chapter 3: Introduction to SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Overview-of-the-SQL-Query-Language"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 Overview of the SQL Query Language</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-SQL-Data-Definition"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 SQL Data Definition</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Types"><span class="toc-number">3.2.1.</span> <span class="toc-text">Basic Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Schema-Definition"><span class="toc-number">3.2.2.</span> <span class="toc-text">Basic Schema Definition</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Basic-Structure-of-SQL-Queries"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 Basic Structure of SQL Queries</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Queries-on-a-Single-Relation"><span class="toc-number">3.3.1.</span> <span class="toc-text">Queries on a Single Relation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queries-on-Multiple-Relations"><span class="toc-number">3.3.2.</span> <span class="toc-text">Queries on Multiple Relations</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#join"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">join</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#natural-join"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">natural join</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#danger-of-nartual-join"><span class="toc-number">3.3.2.2.1.</span> <span class="toc-text">danger of nartual join</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Additional-Basic-Operations"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 Additional Basic Operations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#the-rename-operation"><span class="toc-number">3.4.1.</span> <span class="toc-text">the rename operation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-Operations"><span class="toc-number">3.4.2.</span> <span class="toc-text">String Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Attribute-Specification-in-the-Select-Clause"><span class="toc-number">3.4.3.</span> <span class="toc-text">Attribute Specification in the Select Clause</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ordering-the-Display-of-Tuples"><span class="toc-number">3.4.4.</span> <span class="toc-text">Ordering the Display of Tuples</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-Operations-1"><span class="toc-number">3.4.5.</span> <span class="toc-text">Set Operations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Null-Values"><span class="toc-number">3.5.</span> <span class="toc-text">3.6 Null Values</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-Aggregate-Functions"><span class="toc-number">3.6.</span> <span class="toc-text">3.7 Aggregate Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Aggregation"><span class="toc-number">3.6.1.</span> <span class="toc-text">Basic Aggregation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Aggregation-with-Grouping"><span class="toc-number">3.6.2.</span> <span class="toc-text">Aggregation with Grouping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Having-Clause"><span class="toc-number">3.6.3.</span> <span class="toc-text">The Having Clause</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Aggregation-with-Null-and-Boolean-Values"><span class="toc-number">3.6.4.</span> <span class="toc-text">Aggregation with Null and Boolean Values</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-Nested-Subqueries"><span class="toc-number">3.7.</span> <span class="toc-text">3.8 Nested Subqueries</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-Membership"><span class="toc-number">3.7.1.</span> <span class="toc-text">Set Membership</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-Comparison"><span class="toc-number">3.7.2.</span> <span class="toc-text">Set Comparison</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Test-for-Empty-Relations"><span class="toc-number">3.7.3.</span> <span class="toc-text">Test for Empty Relations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Test-for-the-Absence-of-Duplicate-Tuples"><span class="toc-number">3.7.4.</span> <span class="toc-text">Test for the Absence of Duplicate Tuples</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Subqueries-in-the-From-Clause"><span class="toc-number">3.7.5.</span> <span class="toc-text">Subqueries in the From Clause</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-With-Clause"><span class="toc-number">3.7.6.</span> <span class="toc-text">The With Clause</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scalar-Subqueries"><span class="toc-number">3.7.7.</span> <span class="toc-text">Scalar Subqueries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scalar-Without-a-From-Clause"><span class="toc-number">3.7.8.</span> <span class="toc-text">Scalar Without a From Clause</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-Modification-of-the-Database"><span class="toc-number">3.8.</span> <span class="toc-text">3.9 Modification of the Database</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Deletion"><span class="toc-number">3.8.1.</span> <span class="toc-text">Deletion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Insertion"><span class="toc-number">3.8.2.</span> <span class="toc-text">Insertion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Update"><span class="toc-number">3.8.3.</span> <span class="toc-text">Update</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HW1"><span class="toc-number">3.9.</span> <span class="toc-text">HW1</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-4%EF%BC%9AIntermediate-SQL"><span class="toc-number">4.</span> <span class="toc-text">chapter 4：Intermediate SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Join-Expressions"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 Join Expressions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#join-condition"><span class="toc-number">4.1.1.</span> <span class="toc-text">join condition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#outer-joins"><span class="toc-number">4.1.2.</span> <span class="toc-text">outer joins</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#left-outer-join"><span class="toc-number">4.1.3.</span> <span class="toc-text">left outer join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#right-outer-join"><span class="toc-number">4.1.4.</span> <span class="toc-text">right outer join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#full-outer-join"><span class="toc-number">4.1.5.</span> <span class="toc-text">full outer join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inner-join"><span class="toc-number">4.1.6.</span> <span class="toc-text">inner join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join-Types-and-Conditions"><span class="toc-number">4.1.7.</span> <span class="toc-text">Join Types and Conditions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Views"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 Views</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#View-Definition"><span class="toc-number">4.2.1.</span> <span class="toc-text">View Definition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-Views-in-SQL-Queries"><span class="toc-number">4.2.2.</span> <span class="toc-text">Using Views in SQL Queries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Materialized-Views"><span class="toc-number">4.2.3.</span> <span class="toc-text">Materialized Views</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Update-of-a-View"><span class="toc-number">4.2.4.</span> <span class="toc-text">Update of a View</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transactions"><span class="toc-number">4.3.</span> <span class="toc-text">Transactions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integrity-Constraints"><span class="toc-number">4.4.</span> <span class="toc-text">Integrity Constraints</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Constraints-on-a-Single-Relation"><span class="toc-number">4.4.1.</span> <span class="toc-text">Constraints on a Single Relation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Not-Null-Constraint"><span class="toc-number">4.4.2.</span> <span class="toc-text">Not Null Constraint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unique-Constraint"><span class="toc-number">4.4.3.</span> <span class="toc-text">Unique Constraint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-check-Clause"><span class="toc-number">4.4.4.</span> <span class="toc-text">The check Clause</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Referential-Integrity"><span class="toc-number">4.4.5.</span> <span class="toc-text">Referential Integrity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#integrity-constraints-Violations-During-Transactions"><span class="toc-number">4.4.6.</span> <span class="toc-text">integrity constraints Violations During Transactions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Index-Creation"><span class="toc-number">4.4.7.</span> <span class="toc-text">Index Creation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Large-Object-Types"><span class="toc-number">4.4.8.</span> <span class="toc-text">Large-Object Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#User-Defined-Types"><span class="toc-number">4.4.9.</span> <span class="toc-text">User-Defined Types</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Domain-Types"><span class="toc-number">4.4.9.1.</span> <span class="toc-text">Domain Types</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Create-Table-Extensions"><span class="toc-number">4.4.10.</span> <span class="toc-text">Create Table Extensions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Authorization"><span class="toc-number">4.5.</span> <span class="toc-text">Authorization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Granting-and-Revoking-of-Privileges"><span class="toc-number">4.5.1.</span> <span class="toc-text">Granting and Revoking of Privileges</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#roles"><span class="toc-number">4.5.2.</span> <span class="toc-text">roles</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Authorization-on-Views"><span class="toc-number">4.5.3.</span> <span class="toc-text">Authorization on Views</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Authorizations-on-Schema"><span class="toc-number">4.5.4.</span> <span class="toc-text">Authorizations on Schema</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transfer-of-Privileges"><span class="toc-number">4.5.5.</span> <span class="toc-text">Transfer of Privileges</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Revoking-of-Privileges"><span class="toc-number">4.5.6.</span> <span class="toc-text">Revoking of Privileges</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-6-Formal-Relational-Query-Languages"><span class="toc-number">5.</span> <span class="toc-text">chapter 6: Formal Relational Query Languages</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Relational-Algebra"><span class="toc-number">5.1.</span> <span class="toc-text">The Relational Algebra</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Formal-Definition-of-the-Relational-Algebra"><span class="toc-number">5.1.1.</span> <span class="toc-text">Formal Definition of the Relational Algebra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Additional-Relational-Algebra-Operations"><span class="toc-number">5.1.2.</span> <span class="toc-text">Additional Relational-Algebra Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Extended-Relational-Algebra-Operations"><span class="toc-number">5.1.3.</span> <span class="toc-text">Extended Relational-Algebra Operations</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Generalized-Projection"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">Generalized Projection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Aggregation"><span class="toc-number">5.1.3.2.</span> <span class="toc-text">Aggregation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MULTISET-RELATIONAL-ALGEBRA"><span class="toc-number">5.1.3.2.1.</span> <span class="toc-text">MULTISET RELATIONAL ALGEBRA</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-7-Database-Design-and-the-E-R-Model"><span class="toc-number">6.</span> <span class="toc-text">chapter 7: Database Design and the E-R Model</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Entity-Relationship-Model"><span class="toc-number">6.1.</span> <span class="toc-text">The Entity-Relationship Model</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Entity-Sets"><span class="toc-number">6.1.1.</span> <span class="toc-text">Entity Sets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Relationship-Sets"><span class="toc-number">6.1.2.</span> <span class="toc-text">Relationship Sets</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#E-R-Diagrams"><span class="toc-number">6.2.</span> <span class="toc-text">E-R Diagrams</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Structure"><span class="toc-number">6.2.1.</span> <span class="toc-text">Basic Structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mapping-Cardinality"><span class="toc-number">6.2.2.</span> <span class="toc-text">Mapping Cardinality</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Complex-Attributes"><span class="toc-number">6.2.3.</span> <span class="toc-text">Complex Attributes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#roles-1"><span class="toc-number">6.2.4.</span> <span class="toc-text">roles</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Weak-Entity-Sets"><span class="toc-number">6.2.5.</span> <span class="toc-text">Weak Entity Sets</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reduction-to-Relational-Schemas"><span class="toc-number">6.3.</span> <span class="toc-text">Reduction to Relational Schemas</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Representation-of-Strong-Entity-Sets-with-Simple-Attributes"><span class="toc-number">6.3.1.</span> <span class="toc-text">Representation of Strong Entity Sets with Simple Attributes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Representation-of-Strong-Entity-Sets-with-Complex-Attributes"><span class="toc-number">6.3.2.</span> <span class="toc-text">Representation of Strong Entity Sets with Complex Attributes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Representation-of-Weak-Entity-Sets"><span class="toc-number">6.3.3.</span> <span class="toc-text">Representation of Weak Entity Sets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Representation-of-Relationship-Sets"><span class="toc-number">6.3.4.</span> <span class="toc-text">Representation of Relationship Sets</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redundancy-of-Schemas"><span class="toc-number">6.3.4.1.</span> <span class="toc-text">Redundancy of Schemas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Combination-of-Schemas"><span class="toc-number">6.3.4.2.</span> <span class="toc-text">Combination of Schemas</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Entity-Relationship-Design-Issues"><span class="toc-number">6.4.</span> <span class="toc-text">Entity-Relationship Design Issues</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/29/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E9%83%A8%E7%BD%B2%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98/" title="服务器持续集成部署中遇到的各种问题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="服务器持续集成部署中遇到的各种问题"/></a><div class="content"><a class="title" href="/2024/09/29/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E9%83%A8%E7%BD%B2%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98/" title="服务器持续集成部署中遇到的各种问题">服务器持续集成部署中遇到的各种问题</a><time datetime="2024-09-29T11:08:17.957Z" title="Created 2024-09-29 19:08:17">2024-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/27/DragonOS/%E3%80%90DragonOS%E3%80%91chown%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="【DragonOS】chown系统调用"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【DragonOS】chown系统调用"/></a><div class="content"><a class="title" href="/2024/09/27/DragonOS/%E3%80%90DragonOS%E3%80%91chown%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="【DragonOS】chown系统调用">【DragonOS】chown系统调用</a><time datetime="2024-09-27T09:12:10.372Z" title="Created 2024-09-27 17:12:10">2024-09-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/15/%E3%80%90%E5%B0%B1%E4%B8%9A%E3%80%91C++%E5%85%AB%E8%82%A1%E6%96%87/" title="C++八股文"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++八股文"/></a><div class="content"><a class="title" href="/2024/09/15/%E3%80%90%E5%B0%B1%E4%B8%9A%E3%80%91C++%E5%85%AB%E8%82%A1%E6%96%87/" title="C++八股文">C++八股文</a><time datetime="2024-09-14T16:32:58.664Z" title="Created 2024-09-15 00:32:58">2024-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/09/DragonOS/%E3%80%90DragonOS%E3%80%91PCI%E6%80%BB%E7%BA%BF%E5%AD%90%E7%B3%BB%E7%BB%9F/" title="【DragonOS】PCI总线子系统"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【DragonOS】PCI总线子系统"/></a><div class="content"><a class="title" href="/2024/09/09/DragonOS/%E3%80%90DragonOS%E3%80%91PCI%E6%80%BB%E7%BA%BF%E5%AD%90%E7%B3%BB%E7%BB%9F/" title="【DragonOS】PCI总线子系统">【DragonOS】PCI总线子系统</a><time datetime="2024-09-09T06:50:44.622Z" title="Created 2024-09-09 14:50:44">2024-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/05/DragonOS/%E3%80%90DragonOS%E3%80%91%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F/" title="引导加载程序"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="引导加载程序"/></a><div class="content"><a class="title" href="/2024/09/05/DragonOS/%E3%80%90DragonOS%E3%80%91%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F/" title="引导加载程序">引导加载程序</a><time datetime="2024-09-05T02:07:40.131Z" title="Created 2024-09-05 10:07:40">2024-09-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Val</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">纯粹的心，感受意义不明</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>