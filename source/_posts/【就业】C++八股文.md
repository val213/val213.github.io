---
title: C++八股文
tags: 
    - C++
categories: 技术文章
---

# C++八股文
## C++智能指针
C++标准库中的几种常见智能指针类型包括：

std::unique_ptr: 独占所有权，一个对象只能被一个unique_ptr所管理，不能被拷贝，只能通过移动语义转移所有权。

std::shared_ptr: 共享所有权，多个shared_ptr可以同时管理同一个对象，当最后一个引用销毁时，内存才被释放。

std::weak_ptr: 辅助shared_ptr，不会增加引用计数，避免循环引用（内存泄漏问题），通常用于打破shared_ptr之间的环状依赖。

这些智能指针的核心作用是自动管理动态分配的内存，使得程序员不必手动释放内存，避免内存泄漏等问题。

2. Rust中的引用类型简介
Rust中没有智能指针的概念，但它有一套独特的所有权机制和引用类型来管理内存。常见的引用类型包括：

引用（& 和 &mut）: 借用机制，用于临时访问数据而不转移所有权。&代表不可变引用，&mut代表可变引用。

Box<T>: 类似于C++的unique_ptr，表示堆上分配的单一所有权。只有拥有Box的地方能销毁这个堆内存。

Rc<T>: 类似于C++的shared_ptr，允许多个所有者共享同一个数据。Rc用于单线程环境中。

Arc<T>: 类似于Rc，但用于多线程环境。Arc是原子引用计数的，保证跨线程安全。

Weak<T>: 类似于C++的weak_ptr，辅助Rc或Arc，用于避免循环引用。

3. 相似之处
所有权与自动内存管理:

Rust和C++的核心相似之处是都通过所有权的概念实现自动内存管理。Rust的Box<T>和C++的unique_ptr都表示对资源的独占所有权，自动在对象不再使用时释放内存。
C++的shared_ptr和Rust的Rc/Arc则都用于共享资源的场景，并通过引用计数（reference counting）来决定何时释放内存。
弱引用:

C++的weak_ptr与Rust的Weak<T>功能相似，都是为了避免共享资源时的循环引用问题，防止内存泄漏。
4. 不同之处
语言机制:

C++中的智能指针是库中的工具，程序员需要手动选择并使用智能指针管理内存。C++没有强制性的所有权检查或引用规则。
Rust的所有权系统是内置在语言中的，编译器通过借用检查器（borrow checker）在编译期严格保证内存安全，强制程序员遵循所有权规则。
可变性和借用检查:

Rust通过&和&mut引入了明确的可变性借用规则，编译期保证同一时刻只能有一个可变引用或者多个不可变引用。这是Rust防止数据竞争和悬垂指针的一个关键机制。
C++的智能指针没有类似的编译时检查机制。虽然shared_ptr和weak_ptr可以用来共享资源，但没有Rust那样严格的规则来防止多线程竞争等问题，程序员需要自行保证线程安全。
多线程安全:

Rust中的Arc是线程安全的，保证了引用计数的原子性，适合在多线程环境中共享数据。
C++中的shared_ptr在多线程环境中是非线程安全的，必须手动添加锁或使用其他同步机制。
内存管理方式:

Rust通过编译期静态检查内存的生命周期，减少了运行时开销。大部分的所有权和借用问题在编译时被检测到，避免了潜在的运行时错误。
C++的智能指针则是在运行时进行引用计数和内存管理。这意味着在性能上，Rust的机制可能更高效，尤其是在没有共享引用的场景下。
5. 总结
在C++中，智能指针是一种帮助程序员更好地管理内存的工具，但它们仍然依赖程序员主动使用和遵循。Rust则将内存管理机制直接融入到了语言的核心设计中，通过所有权系统和借用检查器从编译时就强制保证了内存的安全性。

相似性：两者都提供了工具来管理动态内存，防止内存泄漏和悬垂指针（通过引用计数和弱引用）。
不同点：Rust具有更严格的编译期检查机制，能防止数据竞争和引用问题，而C++的智能指针需要运行时的引用计数，且没有内置的可变性检查。

## C++ 中内存分配情况 
栈：由编译器管理分配和回收，存放局部变ᰁ和函数参数。
堆：由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，空间较⼤，但可能会出现内存泄漏和空闲
碎⽚的情况。
全局/静态存储区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变ᰁ和静态变ᰁ。
常ᰁ存储区：存储常ᰁ，⼀般不允许修改。
代码区：存放程序的⼆进制代码。

## C++ 和 Java 区别（语⾔特性，垃圾回收，应⽤场景等） 
指针：Java 语⾔让程序员没法找到指针来直接访问内存，没有指针的概念，并有内存的⾃动管理功能，从⽽有效的
防⽌了 C++ 语⾔中的指针操作失误的影响。但并⾮ Java 中没有指针，Java 虚拟机内部中还是⽤了指针，保证了 
Java 程序的安全。
多᯿继承：C++ ⽀持多᯿继承但 Java 不⽀持，但⽀持⼀个类继承多个接⼝，实现 C++ 中多᯿继承的功能，⼜避免
了 C++ 的多᯿继承带来的不便。
数据类型和类：Java 是完全⾯向对象的语⾔，所有的函数和变ᰁ必须是类的⼀部分。除了基本数据类型之外，其余
的都作为类对象，对象将数据和⽅法结合起来，把它们封装在类中，这样每个对象都可以实现⾃⼰的特点和⾏为。
Java 中取消了 C++ 中的 struct 和 union 。
⾃动内存管理：Java 程序中所有对象都是⽤ new 操作符建⽴在内存堆栈上，Java ⾃动进⾏⽆⽤内存回收操作，不
需要程序员进⾏⼿动删除。⽽ C++ 中必须由程序员释放内存资源，增加了程序设计者的负担。Java 中当⼀个对象
不再被⽤到时， ⽆⽤内存回收器将给他们加上标签。Java ⾥⽆⽤内存回收程序是以线程⽅式在后台运⾏的，利⽤
空闲时间⼯作来删除。
Java 不⽀持操作符᯿载。操作符᯿载被认为是 C++ 的突出特性。
Java 不⽀持预处理功能。C++ 在编译过程中都有⼀个预编译阶段，Java 没有预处理器，但它提供了 import 与 C++ 
预处理器具有类似功能。
类型转换：C++ 中有数据类型隐含转换的机制，Java 中需要限时强制类型转换。

字符串：C++中字符串是以 Null 终⽌符代表字符串的结束，⽽ Java 的字符串 是⽤类对象（string 和 
stringBuffer）来实现的。
Java 中不提供 goto 语句，虽然指定 goto 作为关键字，但不⽀持它的使⽤，使程序简洁易读。
Java 的异常机制⽤于捕获例外事件，增强系统容错能⼒。

## 说⼀下 const 修饰指针如何区分？ 
下⾯都是合法的声明，但是含义⼤不同：
> - const int * p1; //指向整形常量的指针，它指向的值不能修改
> - int * const p2; //指向整形的常ᰁ指针 ，它不能在指向别的变量，但指向（变量）的值可以修改。 
> - const int *const p3; //指向整形常量 的 常量指针 。它既不能再指向别的常量，指向的值也不能修改。
理解这些声明的技巧在于，查看关键字const右边来确定什么被声明为常量，如果该关键字的右边是类型，则值是
常量；如果关键字的右边是指针变量，则指针本身是常量。

## 函数指针 
从定义和用途两方面来说下理解：
⾸先是定义：函数指针是指向函数的指针变量。函数指针本身⾸先是⼀个指针变量，该指针变量指向⼀个具体的函数。这正如⽤指针变量可指向整型变量、字符型、数组⼀样，这⾥是指向函数。
在编译时，每⼀个函数都有⼀个入口地址，该⼊⼝地址就是函数指针所指向的地址。有了指向函数的指针变量后，可⽤该指针变量调⽤函数，就如同⽤指针变量可引⽤其他类型变量⼀样，在这些概念上是⼤体⼀致的。
其次是⽤途：调用函数和做函数的参数，比如回调函数。
示例：
```cpp
char * fun(char * p) {…} // 函数fun
char * (*pf)(char * p); // 函数指针pf
pf = fun; // 函数指针pf指向函数fun
pf(p); // 通过函数指针pf调⽤函数fun
```

## 堆和栈区别 
### 栈
由编译器进⾏管理，在需要时由编译器⾃动分配空间，在不需要时候自动回收空间，⼀般保存的是局部变量和函数参数等。
连续的内存空间，在函数调⽤的时候，首先入栈的主函数的下⼀条可执行指令的地址，然后是函数的各个参数。
大多数编译器中，参数是从右向左⼊栈（这种顺序是为了让程序员在使⽤C/C++的“函数参数⻓度可变”这个特性时更⽅便。如果是从左向右压栈，第⼀个参数（即描述可变参数表各变类量型的那个参数）将被放在栈底，由于可变参的函数第⼀步就需要解析可变参数表的各参数类型，即第⼀步就需要得到上述参数，因此，将它放在栈底是很不方便的。）本次函数调⽤结束时，局部变量先出栈，然后是参数，最后是栈顶指针最开始存放的地址，程序由该点继续运⾏，不会产⽣碎片。
栈是⾼地址向低地址扩展，栈低⾼地址，空间较⼩。

### 堆
由程序员管理，需要手动 new malloc delete free 进⾏分配和回收，如果不回收的话，会造成内存泄漏的问题。
不连续的空间，实际上系统中有⼀个空闲链表，当有程序申请的时候，系统遍历空闲链表找到第⼀个⼤于等于申请大小的空间分配给程序，⼀般在分配程序的时候，也会空间头部写⼊内存大小，⽅便 delete 回收空间大小。当然如果有剩余的，也会将剩余的插⼊到空闲链表中，这也是产⽣内存碎⽚的原因。
堆是低地址向高地址扩展，空间交⼤，较为灵活。

## new / delete ，malloc / free 区别 
都可以⽤来在堆上分配和回收空间。new /delete 是操作符，malloc/free 是库函数。
**执行 new 实际上有两个过程**：
1. 分配未初始化的内存空间（malloc）；
2. 使⽤对象的构造函数对空间进行初始化；返回空间的⾸地址。

如果在第⼀步分配空间中出现问题，则抛出 std::bad_alloc 异常，或被某个设定的异常处理函数捕获处理；如果在第⼆步构造对象时出现异常，则自动调⽤ delete 释放内存。

**执行 delete 实际上也有两个过程**：
1. 使⽤析构函数对对象进⾏析构；
2. 回收内存空间（free）。

以上也可以看出 new 和 malloc 的区别，**new 得到的是经过初始化的空间，而且 malloc 得到的是未初始化的空间**。
所以 **new 是 new ⼀个类型，⽽ malloc 则是malloc ⼀个字节长度的空间**。delete 和 free 同理，delete 不仅释放空间还析构对象，delete ⼀个类型，free ⼀个字节⻓度的空间。

为什么有了 malloc／free 还需要 new／delete？因为对于非内部数据类型， malloc／free 无法满足动态对象的要求。对象在创建的同时需要自动调用构造函数，对象在消亡以前要自动调用析构函数。由于 mallo／free 是库函数不是运算符，不在编译器控制权限之内，不能够把执⾏的构造函数和析构函数的任务强加于 malloc／free，所以有了 new／delete 操作符。


## volatile 和 extern 关键字 
### volatile 三个特性
- 易变性：在汇编层⾯反映出来，就是两条语句，下⼀条语句不会直接使⽤上⼀条语句对应的 volatile 变量的寄存器内容，而是重新从内存中读取。
- 不可优化性：volatile 告诉编译器，不要对我这个变量进⾏各种激进的优化，甚⾄将变量直接消除，保证程序员写在代码中的指令，⼀定会被执⾏。
顺序性：能够保证 volatile 变量之间的顺序性，编译器不会乱序优化。
### extern 
在 C 语⾔中，修饰符 extern ⽤在变量或者函数的声明前，⽤来说明 “此变量/函数是在别处定义的，要在此处引⽤”。
注意 extern 声明的位置对其作⽤域也有关系，如果是在 main 函数中进行声明的，则只能在 main 函数中调⽤，**在其它函数中不能调用**。其实要调用其它⽂件中的函数和变量，只需把该⽂件⽤ #include 包含进来即可，为啥要用 extern？**因为 extern 会加速程序的编译过程，这样能节省时间**。
在 C++ 中 extern 还有另外⼀种作用，**用于指示 C 或者 C＋＋函数的调用规范。比如在 C＋＋ 中调用 C 库函数，就需要在 C＋＋ 程序中用 extern “C” 声明要引⽤的函数。这是给链接器用的，告诉链接器在链接的时候用 C 函数规范来链接。主要原因是 C＋＋ 和 C 程序编译完成后在⽬标代码中命名规则不同，用此来解决名字匹配的问题。**

### define 和 const 区别（编译阶段、安全性、内存占⽤等） 
对于 define 来说，宏定义实际上是在预编译阶段进行处理，没有类型，也就没有类型检查，仅仅做的是遇到宏定义进⾏字符串的展开，遇到多少次就展开多少次，而且这个简单的展开过程中，很容易出现边界效应，达不到预期的效果。因为 define 宏定义仅仅是展开，因此**运行时系统并不为宏定义分配内存**，但是从汇编 的角度来讲，define 却**以立即数的方式保留了多份数据的拷贝**。

对于 const 来说，const 是在编译期间处理的，const 有类型，也有类型检查，**程序运行时系统会为 const 常量分配内存**，而且**从汇编的角度讲，const 常量在出现的地方保留的是真正数据的内存地址，只保留了⼀份数据的拷贝**，省去了不必要的内存空间。而且，有时编译器不会为普通的 const 常量分配内存，而是**直接将 const 常量添加到符号表中**，省去了读取和写⼊内存的操作，效率更⾼。
## 虚函数相关（虚函数表，虚函数指针），虚函数的实现原理 
⾸先我们来说⼀下，C++中多态的表象，在基类的函数前加上 **virtual** 关键字，在派⽣类中重写该函数，运⾏时将会根据对象的实际类型来调用相应的函数。如果对象类型是派⽣类，就调用派⽣类的函数，如果是基类，就调用基类的函数。
**实际上，当⼀个类中包含虚函数时，编译器会为该类⽣成⼀个虚函数表，保存该类中虚函数的地址**，同样，派生类继承基类，派生类中自然⼀定有虚函数，所以编译器也会为派生类生成自己的虚函数表。当我们定义⼀个派生类对象时，编译器检测该类型有虚函数，所以为这个派⽣类对象生成⼀个虚函数指针，指向该类型的虚函数表，这个虚函数指针的初始化是在构造函数中完成的。

后续如果有⼀个基类类型的指针，指向派生类，那么当调用虚函数时，就会根据所指真正对象的虚函数表指针去寻找虚函数的地址，也就可以调⽤派生类的虚函数表中的虚函数以此实现多态。

补充：如果基类中没有定义成 virtual，那么进行 Base B; Derived D; Base *p = D; p->function(); 这种情况下调⽤
的则是 Base 中的 function()。**因为基类和派⽣类中都没有虚函数的定义，那么编译器就会认为不⽤留给动态多态的机会**，就事先进⾏函数地址的绑定（早绑定），详述过程就是，定义了⼀个派生类对象，首先要构造基类的空间，然后构造派生类的自身内容，形成⼀个派生类对象，那么在进行类型转换时，直接截取基类的部分的内存，编译器认为类型就是基类，那么（函数符号表［不同于虚函数表的另⼀个表］中）绑定的函数地址也就是基类中函数的地址，所以执行的是基类的函数。
## 对于派⽣类来说，编译器建⽴虚函数表的过程其实⼀共是三个步骤： 
拷⻉基类的虚函数表，如果是多继承，就拷⻉每个有虚函数基类的虚函数表
当然还有⼀个基类的虚函数表和派⽣类⾃身的虚函数表共⽤了⼀个虚函数表，也称为某个基类为派⽣类的主基
类
查看派⽣类中是否有᯿写基类中的虚函数， 如果有，就替换成已经᯿写的虚函数地址；查看派⽣类是否有⾃
身的虚函数，如果有，就追加⾃身的虚函数到⾃身的虚函数表中。
Derived *pd = new D(); B *pb = pd; C *pc = pd; 其中 pb，pd，pc 的指针位置是不同的，要注意的是派⽣类的自身的内容要追加在主基类的内存块后

## 析构函数⼀般写成虚函数的原因 
直观的讲：是为了降低内存泄漏的可能性。

举例来说就是，⼀个基类的指针指向⼀个派⽣类的对象，在使用完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那么编译器根据指针类型就会认为当前对象的类型是基类，调用基类的析构函数 （该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执行基类的析构，派生类的自身内容将无法被析构，造成内存泄漏。
如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执行派⽣类的析构函数，再执行基类的析构函数，成功释放内存。

