---
title: 编译原理
---
# 编译器组成
# 词法分析

## RE

### NFA

### DFA

# 语法分析
## Formalisms fot syntax analysis
## Language of CFG

## derivation 推导

## parse tree and abstract syntax tree

## ambiguity 二义性
### 如何处理二义性
- 优先级
- 结合性
- 括号
- 语法规则
## parsing algorithm
### Top-down parsing 自顶向下
多对多的关系，用图表示。节点是句子和句型，边是推导关系。

#### backtracking 回溯
BFS剪枝，时间和空间开销大。

用BFS：进行图遍历搜索，复杂，时间复杂度过高，产生大量无用分支，时间和空间的最差情况都是指数级别。现代编译器中不被使用

剪枝：由终止符号做前缀时，如果无法与输入的前缀匹配则剪枝。(时，无法剪枝，因为前缀一直是非终止符号)
用DFS：有比BFS更好的空间复杂度和时间复杂度，但是无法匹配左递归，因为会一直循环。
#### predictive parsing 预测分析
Idea：利用先行词(lookahead tokens)，也就是上面提到过的终止符前缀。

从输入串和文法的开始符号开始分析

以当前input的token来独⼀⽆⼆地决定下⼀个被使⽤的production，parsing是预测性

预测分析文法包括LL(k)文法，其中L表示从左向右扫描，L表示最左推导，k表示“需要k个先行词用于预测”

LL(1)文法是常用的，也不完全常用。


##### LL(1)
###### first 和 follow
lookahead sets: 用于预测的token集合。
- first set: 一个非终结符号的first set是它的所有产生式的first set的并集。
  
Definition：

$$G=(V_N, V_T, P, S) \text{ is a grammar,} $$ 

$$ β∈(V_N∪V_T)* $$

$$FIRST(β) = { a ∊ V_T | β ⇒* a......}$$
$$\text{if} β⇒* ε \text{then} ε ∊ FIRST(β)$$

- follow set: 一个非终结符号的follow set是它的所有产生式的follow set的并集。

Definition:

$$G=(VT, VN, S,P) \text{ is a grammar},A∈V_N ,$$

$$FOLLOW(A)={a ∊ VT | S⇒*…Aa…},$$

$$\text{if } S⇒* …A, \text{then dollar}  ∊ FOLLOW(A)$$
$$(\text{dollar is used to mark the end of the input)}$$


- 可空的非终止符(nullable nonterminal), 如果一个非终止符号的产生式中有$\epsilon$，那么这个非终止符号是可空的。
- 计算产生式右侧所有的First(a)并验证其两两交集是否为空
- 只有当一个非终结符号的first set和follow set没有交集时，这个文法才是LL(1)文法。
- 如果一个非终止符号的产生式中有$\epsilon$，那么需要考察这个非终止符号的follow set。
（First(A)和Follow(A)的交集为空才行）


典型的非LL(1)文法：
- if a grammar has **left factor(左因子)** or **left recursion（左递归）**, it is not LL(1).
- 有左公因⼦或者左递归，⼀定不是LL(1)型grammar
- 没有左公因⼦或者左递归也不⼀定是LL(1)算法
### Bottom-up parsing 自底向上
- 右句型：句型的一种，句型的最右边是一个非终结符号。
- 最右推导：从开始符号推导出句型的过程。
- handle：在推导过程中，句型的一部分，跟产生式右部所匹配的部分。
- 从输入串开始，逐步推导出文法的开始符号。  
- 归约：推导的逆过程，将handle归约回产生式左侧的非终结符号。
- 将右句型一分为二分为左部/右部，handle在左部的最右边。左部被称为work area，所有的handle都在work area中。
- 用一个分析栈来存储已经分析过的部分，栈底是文法的开始符号。top-down的分析栈中是待分析的内容。
- shift-reduce parsing: 从左到右扫描输入串，shift是将输入串的一个token放入栈中，reduce是将handle归约为产生式左部的非终结符号。
- 什么时候规约？做预测。这是后续算法解决的问题
- 可行前缀：找到一个handle之前，在栈里出现过的所有串都可称为可行前缀。如果前缀是可行的，证明分析也是对的，所以也称为“活前缀”
#### LR parsing
- LR(0) parsing: 用于解决shift-reduce冲突的问题。
  - Parsing Table: 
    - top-down的分析表：选择产生式的规则
    - bottom-up的分析表：
  - 栈顶就是状态
- 增广文法
#### SLR
S(simple)LR(1) parsing: 用于解决reduce-reduce冲突的问题。

基本思想：看当前的handle对应的非终止符号（产生式的左部）后面允许出现哪些终止符号
# 语义分析




# 作业