---
title: 软件体系架构
categories: 复习笔记
tags: 软件体系架构
---
# 2024考试须知
![考试须知](image.png)
![考纲](image-1.png)
![复习提纲1](image-2.png)
![复习提纲2](image-3.png)
# Part 1：Introduction
## chapter 1：What is Software Architecture?
知识点：
- 软件体系结构的基本概念
- 软件体系架构的重要性

### 什么是软件体系结构？
系统的软件架构是理解系统所需的结构集合，包括软件元素、元素之间的关系以及它们的属性。

- 架构是结构的集合
    - 结构是由关系连接在一起的元素集合
    - 软件系统由许多结构组成，没有单一的结构可以称为架构。

架构有三个重要的结构类别：
- Module
- Component and Connector
- Allocation

### which structures are architectural?
- 如果一个结构有助于推理系统以及系统的属性，那么该结构就是架构性的。
- 该推理应关注系统的一个属性，该属性对某些利益相关者至关重要。
    - 系统实现的功能
    - 系统在面对故障时的可用性
    - 对系统进行更改的成本
    - 系统对用户请求的响应能力
    - 其他……
### Module Structure，Allocation Structure，Component and Connector Structure 的定义、概念和类型
#### Module Structure
Structures partition systems into implementation units called modules.**每一个模块被分配不同的职责和相应的任务**。
- Decomposition
- User structure->Layer pattern
- Class structure
- Data model
##### Decomposition
- 这些单元是通过 is-a-submodule-of 关系连接在一起的。
- 展示了模块如何递归地被分解成更小的模块，直到模块足够小，易于理解。
- 模块通常会有一些产品（接口、规范、代码、测试计划等）与之关联。
- 分解结构在很大程度上决定了系统的可修改性，通过确保可能的变更被局限化来实现。
##### Uses Structure
- 这些单元也是模块，可能是类
- 通过 uses 关系相互关联
- 如果第一个单元的正确性依赖于第二个单元的正确运行，那么第一个单元就使用了第二个单元。
##### Layer Structure
层是一个抽象的“虚拟机”，通过受控接口提供一组有凝聚力的服务。
- 在严格的分层系统中，一个层只能调用比它更低的层，而不能调用比它更高的层。
- 这种结构赋予系统可移植性，能够更换底层的实现而不影响上层。
##### Class Structure
- inherited from 或者 is an instance of 关系
- 可以推理关于重用和功能的增量添加
##### Data Model
- 数据模型通过数据实体及其关系描述静态信息结构
- 例如，银行系统中实体包括账户、客户和贷款。
- 每个实体具体多个属性
#### C & C Structure
Component-and-connector (C&C) Structures：focus on the way the elements interact with each other at runtime to carry out the system’s functions. **关注元素在运行时如何相互交互以执行系统的功能**。

**一个component就是一个runtime entity**。
- Service structure
- Concurrency structure
##### Service Structure
- 通过例如 SOAP 的服务协调机制相互操作的服务。
- 有助于构建由可能的匿名开发且互相独立 anonymously and independently of each other 的组件组成的系统。
##### Concurrency Structure
- 该结构有助于确定 parallelism and the locations where resource contention(争用) may occur。
#### Allocation Structure
describe the mapping from software structures to the system’s environments，有organizational、developmental、installation、Execution.
**描述了软件结构到系统环境的映射，有组织、开发、安装、执行等**。如：模块被分配给团队进行开发，并被分配到文件结构中用于实现、集成和测试的位置。而 Component 被部署到硬件上。
- Deployment structure
- Implementation structure
- Work assignment structure
##### Deployment Structure
- 元素包括软件（C & C 中的实体）和硬件和他们之间的连接（通信通道）
- allocated-to 关系
- 用于推断 performance, data integrity, security, and availability.
- 在分布式和并行系统中，这个结构尤为重要
##### Implementation Structure
- 用于描述软件结构如何映射到系统的开发、集成或者配置控制环境中的文件结构
##### Work Assignment Structure
- 用于描述软件结构如何映射到团队的工作分配

### Architecture Patterns

### Relationship between Pattern and Tactics
架构策略是一个设计决策，影响质量属性的响应。策略的重点是单一质量属性响应。一个策略并不考虑质量属性之间的权衡。

架构模式可以看作是“策略的组合”，会考虑质量属性之间的权衡。

### Achiving quality attributes through tactics
有一组原始设计技术，架构师可以用来实现质量属性的响应。我们将这些称为架构设计原语策略。

### what makes a good architecture?
不存在固有的好和坏的架构。体系架构或多或少适用于某些目的。架构可以被评估，但是只能在特定目标的上下文中进行评估。

然而也有一些 good rules of thumb：
- process
    - The architecture should be the product of a single architect or a small group of architects with an identified leader.  架构应该是一个单一架构师或者一个小团队的产品，并且有一个明确的领导者。
    - 架构师应该设计架构基于 a prioritized list of well-specified quality attribute requirements.  （**明确规定的质量属性需求的优先级列表**。）
    - documented using views
    - 架构应该被评估他的能力到传递这个系统的质量属性。
    - 架构应该适合增量实现
- structure
    - 体系架构应该以定义好的模块为特征，这些模块的功能职责是根据信息隐藏和关注点分离（**information hiding and separation of concerns**）的原则来分配的。
    - 应该使用众所周知的体系架构模式和特定于每个属性的策略来实现质量属性
    - 架构不应该依赖于商业产品或者工具的特定版本
    - 产生数据的模块应该与消费数据的模块分离
    - 不要期望模块和组件之间是一对一的对应关系。例如，在具有并发性的系统中，可能存在并行运行的组件的多个实例，其中每个组件都是从同一个模块构建的。对于具有多个并发线程的系统，每个线程可以使用来自多个组件的服务，每个组件都是由不同的模块构建的。
    - 应该让每个进程都可以轻松更改其对特定处理器的赋值，甚至可能在运行时更改。
    - 体系结构应该提供少量的组件交互方式。也就是说，整个系统应该以同样的方式做同样的事情。这将有助于可理解性，减少开发时间，提高可靠性，并增强可修改性。
    - 体系结构应该包含一组特定的（很小的）资源争用区域，这些争用区域的解析是明确指定和维护的。
## chapter 2：Why is Software Architecture Important?
13个理由：
1. An architecture will inhibit or enable a system’s driving quality attributes. 一个架构会抑制或者促进系统的驱动质量属性。
2. The decisions made in an architecture allow you to reason about and manage change as the system evolves. 架构中的决策使您能够推理和管理系统的演变。
3. The analysis of an architecture enables early prediction of a system’s 
qualities. 架构的分析使您能够早期预测系统的质量。
4. A documented architecture enhances communication among stakeholders. 文档化的架构增强了利益相关者之间的沟通。
5. The architecture is a carrier of the earliest and hence most fundamental, 
hardest-to-change design decisions. 架构是最早的、因此最基本的、最难以改变的设计决策的载体。
6. An architecture defines a set of constraints on subsequent implementation. 架构定义了对后续实现的一组约束。
7. The architecture dictates the structure of an organization, or vice versa. 架构决定了组织的结构，反之亦然。
8. An architecture can provide the basis for evolutionary prototyping. 架构可以为演进式原型提供基础。
9. An architecture is the key artifact that allows the architect and project manager to reason about cost and schedule. 架构是允许架构师和项目经理推理成本和进度的关键工件。
10. An architecture can be created as a transferable, reusable model that forms 
the heart of a product line. 架构可以作为可转移、可重用的模型创建，形成产品线的核心。
11. Architecture-based development focuses attention on the assembly of components, rather than simply on their creation. 基于架构的开发关注组件的组装，而不仅仅是它们的创建。
12. By restricting design alternatives, architecture channels the creativity of 
developers, reducing design and system complexity. 通过限制设计选择，架构引导开发人员的创造力，减少设计和系统复杂性。
13. An architecture can be the foundation for training a new team member. 架构可以成为培训新团队成员的基础。

## chapter 3：The many Contexts of Software Architecture

# Part 2：Quality Attributes
## chapter 4：understanding Quality Attributes
### 描述质量属性场景的六要素
为了总结我们如何指定质量属性需求，我们将它们正式捕获为六部分场景。虽然忽略这六个部分中的一个或多个部分是很常见的，特别是在考虑质量属性的早期阶段，知道所有部分都在那里迫使架构师考虑每个部分是否相关。
In summary, here are the six parts:
1. **Source of stimulus**. This is some entity (a human, a computer system, or 
any other actuator) that generated the stimulus. 刺激源。这是一些实体（人类、计算机系统或任何其他执行器）产生的刺激。
2. **Stimulus**. The stimulus is a condition that requires a response when it arrives at a system. 刺激。刺激是一种条件，当它到达系统时需要响应。
3. **Environment**. The stimulus occurs under certain conditions. The system 
may be in an overload condition or in normal operation, or some other relevant state. For many systems, “normal” operation can refer to one of a number of modes. For these kinds of systems, the environment should specify in 
which mode the system is executing. 环境。刺激发生在某些条件下。系统可能处于过载状态或正常运行状态，或者其他相关状态。对于许多系统，“正常”操作可能指的是多种模式之一。对于这类系统，环境应指定系统正在执行的模式。
4. **Artifact**. Some artifact is stimulated. This may be a collection of systems, 
the whole system, or some piece or pieces of it. 工件（产品）。某些工件被刺激。这可能是一组系统、整个系统或其中的一些部分。
5. **Response**. The response is the activity undertaken as the result of the arrival 
of the stimulus. 响应。响应是作为刺激到达的结果而进行的活动。
6. **Response measure**. When the response occurs, it should be measurable in 
some fashion so that the requirement can be tested. 响应测量。当响应发生时，它应该以某种方式可测量，以便可以测试需求。
## chaptr 5：Availability
![系统可用性要求](image-4.png)
### what is availability?
- Availability refers to a property of software that it is there and ready to carry out its task when you need it to be.  可用性是软件的一种属性，指的是软件在需要时可以随时运行并完成其任务。
- Availability refers to the ability of a system to mask or repair faults such that the cumulative service outage period does not exceed a required value over a specified time interval.  可用性是指系统能够屏蔽或修复故障，使得在指定时间间隔内累计的服务中断时间不超过要求的值。
- Availability is about minimizing service outage time by mitigating faults.  可用性是通过缓解故障来最小化服务中断时间。
### Availability General Scenarios
![可用性通用场景](image-5.png)
![简单的通用性具体场景](image-6.png)
### Tactics for Availability
![可用性策略](image-7.png)
- Input: Fault / 输入：故障
- Output: Fault Masked or Repair Made / 输出：故障被掩盖或修复
#### Fault Detection
- Ping & Echo
- Monitor / 监测
- Heartbeat / 心跳
- Timestamp / 时间戳
- Sanity Checking / 完整性检查
- Condition Monitoring / 状态监控
- Voting / 投票
- Exception Detection / 异常检测
- Self-Test / 自检
#### recover from fault
##### Preparation-and-repair
- Active Redundancy / 主动冗余
- Passive Redundancy / 被动冗余
- Spare / 备用
- Exception Handling / 异常处理
- Rollback / 回滚
- Software Upgrade / 软件升级
- Retry / 重试
- Ignore Faulty Behavior / 忽略故障行为
- Degradation / 降级
- Reconfiguration / 重新配置
##### Reintroduction 
- Shadow / 影子
- State Resynchronization / 状态重新同步
- Escalating Restart / 升级重启
- Non-Stop Forwarding / 不间断转发
#### prevent fault
- Removal from Service / 从服务中移除
- Transactions / 事务
- Predictive Model / 预测模型
- Exception Prevention / 异常预防
- Increase Competence Set / 增加能力集
## chapter 6：interoperability
## chapter 7：Modifiability
## chapter 8：Performance
### Performance General Scenarios
![性能通用场景](image-8.png)
![简单的性能具体场景](image-9.png)
### Tactics for Performance
![性能策略](image-10.png)
- Input: Event arrival / 输入：事件到达
- Output: response generated within time constraint / 输出：在时间约束内生成响应
#### control resource demand
- manage sampling rate / 管理采样率
- limit event response / 限制事件响应
- prioritize events / 优先处理事件
- reduce overhead
- bound execution time / 限制执行时间
- increse resource efficiency / 提高资源效率
#### manage resource
- increase resource / 增加资源
- introduce concurrency / 引入并发
- maintain multiple copies of computation / 维护多个计算副本
- maintain multiple copies of data / 维护多个数据副本
- bound queue size / 限制队列大小
- schedule resources / 资源调度
## chapter 9：Security
### Security General Scenarios
![安全通用场景](image-11.png)
![简单的安全具体场景](image-12.png)
### tactics for Security
![安全策略](image-13.png)
## chapter 10：Testability
### Testability General Scenarios
![可测试性通用场景](image-14.png)
![简单的可测试性具体场景](image-15.png)
### Tactics for Testability
![可测试性策略](image-16.png)
## chapter 11：Usability
## chapter 12：other Quality Attributes
# Part 3：Architecture in the Life Cycle
## ATAM：Architecture Tradeoff Analysis Method 架构权衡分析方法