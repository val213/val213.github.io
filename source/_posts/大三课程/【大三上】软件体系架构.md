---
title: 软件体系架构
categories: 复习笔记
tags: 软件体系架构
---
# 2024考试须知
![考试须知](image.png)
![考纲](image-1.png)
![复习提纲1](image-2.png)
![复习提纲2](image-3.png)
# Part 1：Introduction
## chapter 1：What is Software Architecture?
知识点：
- 软件体系结构的基本概念
- 软件体系架构的重要性

### 🔥什么是软件体系结构？定义、概念
系统的软件架构是理解系统所需的结构集合，包括软件元素、元素之间的关系以及它们的属性。

- 架构是结构的集合
    - 结构是由关系连接在一起的元素集合
    - 软件系统由许多结构组成，没有单一的结构可以称为架构。

架构有三个重要的结构类别：
- Module
- Component and Connector
- Allocation

### which structures are architectural?
- 如果一个结构有助于推理系统以及系统的属性，那么该结构就是架构性的。
- 该推理应关注系统的一个属性，该属性对某些利益相关者至关重要。
    - 系统实现的功能
    - 系统在面对故障时的可用性
    - 对系统进行更改的成本
    - 系统对用户请求的响应能力
    - 其他……
### 🔥🔥Module Structure，Allocation Structure，Component and Connector Structure 的定义、概念和类型
- 🔥seven categories of design decisions
- 🔥its role in project risk reduction?(how to reduce risks?)
#### Module Structure
Structures partition systems into implementation units called modules.**每一个模块被分配不同的职责和相应的任务**。
- Decomposition
- User structure->Layer pattern
- Class structure
- Data model
##### Decomposition
- 这些单元是通过 is-a-submodule-of 关系连接在一起的。
- 展示了模块如何递归地被分解成更小的模块，直到模块足够小，易于理解。
- 模块通常会有一些产品（接口、规范、代码、测试计划等）与之关联。
- 分解结构在很大程度上决定了系统的可修改性，通过确保可能的变更被局限化来实现。
##### Uses Structure
- 这些单元也是模块，可能是类
- 通过 uses 关系相互关联
- 如果第一个单元的正确性依赖于第二个单元的正确运行，那么第一个单元就使用了第二个单元。
##### Layer Structure
层是一个抽象的“虚拟机”，通过受控接口提供一组有凝聚力的服务。
- 在严格的分层系统中，一个层只能调用比它更低的层，而不能调用比它更高的层。
- 这种结构赋予系统可移植性，能够更换底层的实现而不影响上层。
##### Class Structure
- inherited from 或者 is an instance of 关系
- 可以推理关于重用和功能的增量添加
##### Data Model
- 数据模型通过数据实体及其关系描述静态信息结构
- 例如，银行系统中实体包括账户、客户和贷款。
- 每个实体具体多个属性

#### C & C Structure
Component-and-connector (C&C) Structures：focus on the way the elements interact with each other at runtime to carry out the system’s functions. **关注元素在运行时如何相互交互以执行系统的功能**。

**一个component就是一个runtime entity**。
- Service structure
- Concurrency structure
##### Service Structure
- 通过例如 SOAP 的服务协调机制相互操作的服务。
- 有助于构建由可能的匿名开发且互相独立 anonymously and independently of each other 的组件组成的系统。
##### Concurrency Structure
- 该结构有助于确定 parallelism and the locations where resource contention(争用) may occur。

#### Allocation Structure
describe the mapping from software structures to the system’s environments，有organizational、developmental、installation、Execution.
**描述了软件结构到系统环境的映射，有组织、开发、安装、执行等**。如：模块被分配给团队进行开发，并被分配到文件结构中用于实现、集成和测试的位置。而 Component 被部署到硬件上。
- Deployment structure
- Implementation structure
- Work assignment structure
##### Deployment Structure
- 元素包括软件（C & C 中的实体）和硬件和他们之间的连接（通信通道）
- allocated-to 关系
- 用于推断 performance, data integrity, security, and availability.
- 在分布式和并行系统中，这个结构尤为重要
##### Implementation Structure
- 用于描述软件结构如何映射到系统的开发、集成或者配置控制环境中的文件结构
##### Work Assignment Structure
- 用于描述软件结构如何映射到团队的工作分配

### Architecture Patterns

### Relationship between Pattern and Tactics
架构策略是一个设计决策，影响质量属性的响应。策略的重点是单一质量属性响应。一个策略并不考虑质量属性之间的权衡。

架构模式可以看作是“策略的组合”，会考虑质量属性之间的权衡。

### Achiving quality attributes through tactics
有一组原始设计技术，架构师可以用来实现质量属性的响应。我们将这些称为架构设计原语策略。

### what makes a good architecture?
不存在固有的好和坏的架构。体系架构或多或少适用于某些目的。架构可以被评估，但是只能在特定目标的上下文中进行评估。

然而也有一些 good rules of thumb：
- process
    - The architecture should be the product of a single architect or a small group of architects with an identified leader.  架构应该是一个单一架构师或者一个小团队的产品，并且有一个明确的领导者。
    - 架构师应该设计架构基于 a prioritized list of well-specified quality attribute requirements.  （**明确规定的质量属性需求的优先级列表**。）
    - documented using views
    - 架构应该被评估他的能力到传递这个系统的质量属性。
    - 架构应该适合增量实现
- structure
    - 体系架构应该以定义好的模块为特征，这些模块的功能职责是根据信息隐藏和关注点分离（**information hiding and separation of concerns**）的原则来分配的。
    - 应该使用众所周知的体系架构模式和特定于每个属性的策略来实现质量属性
    - 架构不应该依赖于商业产品或者工具的特定版本
    - 产生数据的模块应该与消费数据的模块分离
    - 不要期望模块和组件之间是一对一的对应关系。例如，在具有并发性的系统中，可能存在并行运行的组件的多个实例，其中每个组件都是从同一个模块构建的。对于具有多个并发线程的系统，每个线程可以使用来自多个组件的服务，每个组件都是由不同的模块构建的。
    - 应该让每个进程都可以轻松更改其对特定处理器的赋值，甚至可能在运行时更改。
    - 体系结构应该提供少量的组件交互方式。也就是说，整个系统应该以同样的方式做同样的事情。这将有助于可理解性，减少开发时间，提高可靠性，并增强可修改性。
    - 体系结构应该包含一组特定的（很小的）资源争用区域，这些争用区域的解析是明确指定和维护的。
## chapter 2：Why is Software Architecture Important?
13个理由：
1. An architecture will inhibit or enable a system’s driving quality attributes. 一个架构会抑制或者促进系统的驱动质量属性。
2. The decisions made in an architecture allow you to reason about and manage change as the system evolves. 架构中的决策使您能够推理和管理系统的演变。
3. The analysis of an architecture enables early prediction of a system’s 
qualities. 架构的分析使您能够早期预测系统的质量。
4. A documented architecture enhances communication among stakeholders. 文档化的架构增强了利益相关者之间的沟通。
5. The architecture is a carrier of the earliest and hence most fundamental, 
hardest-to-change design decisions. 架构是最早的、因此最基本的、最难以改变的设计决策的载体。
6. An architecture defines a set of constraints on subsequent implementation. 架构定义了对后续实现的一组约束。
7. The architecture dictates the structure of an organization, or vice versa. 架构决定了组织的结构，反之亦然。
8. An architecture can provide the basis for evolutionary prototyping. 架构可以为演进式原型提供基础。
9. An architecture is the key artifact that allows the architect and project manager to reason about cost and schedule. 架构是允许架构师和项目经理推理成本和进度的关键工件。
10. An architecture can be created as a transferable, reusable model that forms 
the heart of a product line. 架构可以作为可转移、可重用的模型创建，形成产品线的核心。
11. Architecture-based development focuses attention on the assembly of components, rather than simply on their creation. 基于架构的开发关注组件的组装，而不仅仅是它们的创建。
12. By restricting design alternatives, architecture channels the creativity of 
developers, reducing design and system complexity. 通过限制设计选择，架构引导开发人员的创造力，减少设计和系统复杂性。
13. An architecture can be the foundation for training a new team member. 架构可以成为培训新团队成员的基础。

## chapter 3：The many Contexts of Software Architecture

# Part 2：Quality Attributes
## chapter 4：understanding Quality Attributes
### 描述质量属性场景的六要素
为了总结我们如何指定质量属性需求，我们将它们正式捕获为六部分场景。虽然忽略这六个部分中的一个或多个部分是很常见的，特别是在考虑质量属性的早期阶段，知道所有部分都在那里迫使架构师考虑每个部分是否相关。
In summary, here are the six parts:
1. **Source of stimulus**. This is some entity (a human, a computer system, or 
any other actuator) that generated the stimulus. 刺激源。这是一些实体（人类、计算机系统或任何其他执行器）产生的刺激。
2. **Stimulus**. The stimulus is a condition that requires a response when it arrives at a system. 刺激。刺激是一种条件，当它到达系统时需要响应。
3. **Environment**. The stimulus occurs under certain conditions. The system 
may be in an overload condition or in normal operation, or some other relevant state. For many systems, “normal” operation can refer to one of a number of modes. For these kinds of systems, the environment should specify in 
which mode the system is executing. 环境。刺激发生在某些条件下。系统可能处于过载状态或正常运行状态，或者其他相关状态。对于许多系统，“正常”操作可能指的是多种模式之一。对于这类系统，环境应指定系统正在执行的模式。
4. **Artifact**. Some artifact is stimulated. This may be a collection of systems, 
the whole system, or some piece or pieces of it. 工件（产品）。某些工件被刺激。这可能是一组系统、整个系统或其中的一些部分。
5. **Response**. The response is the activity undertaken as the result of the arrival 
of the stimulus. 响应。响应是作为刺激到达的结果而进行的活动。
6. **Response measure**. When the response occurs, it should be measurable in 
some fashion so that the requirement can be tested. 响应测量。当响应发生时，它应该以某种方式可测量，以便可以测试需求。
## chaptr 5：Availability
![系统可用性要求](image-4.png)
### what is availability?
- Availability refers to a property of software that it is there and ready to carry out its task when you need it to be.  可用性是软件的一种属性，指的是软件在需要时可以随时运行并完成其任务。
- Availability refers to the ability of a system to mask or repair faults such that the cumulative service outage period does not exceed a required value over a specified time interval.  可用性是指系统能够屏蔽或修复故障，使得在指定时间间隔内累计的服务中断时间不超过要求的值。
- Availability is about minimizing service outage time by mitigating faults.  可用性是通过缓解故障来最小化服务中断时间。
### Availability General Scenarios
![可用性通用场景](image-5.png)
![简单的通用性具体场景](image-6.png)
### 🔥🔥Tactics for Availability
![可用性策略](image-7.png)
- Input: Fault / 输入：故障
- Output: Fault Masked or Repair Made / 输出：故障被掩盖或修复
#### Fault Detection
- Ping & Echo
- Monitor / 监测
- Heartbeat / 心跳
- Timestamp / 时间戳
- Sanity Checking / 完整性检查
- Condition Monitoring / 状态监控
- Voting / 投票
- Exception Detection / 异常检测
- Self-Test / 自检
#### recover from fault
##### Preparation-and-repair
- Active Redundancy / 主动冗余
- Passive Redundancy / 被动冗余
- Spare / 备用
- Exception Handling / 异常处理
- Rollback / 回滚
- Software Upgrade / 软件升级
- Retry / 重试
- Ignore Faulty Behavior / 忽略故障行为
- Degradation / 降级
- Reconfiguration / 重新配置
##### Reintroduction 
- Shadow / 影子
- State Resynchronization / 状态重新同步
- Escalating Restart / 升级重启
- Non-Stop Forwarding / 不间断转发
#### prevent fault
- Removal from Service / 从服务中移除
- Transactions / 事务
- Predictive Model / 预测模型
- Exception Prevention / 异常预防
- Increase Competence Set / 增加能力集
## chapter 6：interoperability
### what is interoperability?
Interoperability is about the degree to which two or more systems can usefully exchange meaningful information via interfaces in a particular context. 互操作性是指两个或多个系统在特定上下文中通过接口有效地交换有意义的信息的程度。

Any discussion of a system's interoperability needs to identify with whom, and under what circumstances. 任何关于系统互操作性的讨论都需要明确与谁、以及在什么情况下进行。
### Interoperability General Scenarios
![交互性通用场景](image-20.png)
![简单的交互性具体场景](image-21.png)
### 🔥Tactics for Interoperability
![交互性策略](image-22.png)
## chapter 7：Modifiability
### Modifiability General Scenarios
![可修改性通用场景](image-17.png)
![简单的可修改性具体场景](image-18.png)
### Tactics for Modifiability
![可修改性策略](image-19.png)
## chapter 8：Performance
### Performance General Scenarios
![性能通用场景](image-8.png)
![简单的性能具体场景](image-9.png)
### 🔥🔥Tactics for Performance
![性能策略](image-10.png)
- Input: Event arrival / 输入：事件到达
- Output: response generated within time constraint / 输出：在时间约束内生成响应
#### control resource demand
- manage sampling rate / 管理采样率
- limit event response / 限制事件响应
- prioritize events / 优先处理事件
- reduce overhead
- bound execution time / 限制执行时间
- increse resource efficiency / 提高资源效率
#### manage resource
- increase resource / 增加资源
- introduce concurrency / 引入并发
- maintain multiple copies of computation / 维护多个计算副本
- maintain multiple copies of data / 维护多个数据副本
- bound queue size / 限制队列大小
- schedule resources / 资源调度
## chapter 9：Security 安全保障
### Security General Scenarios
![安全保障通用场景](image-11.png)
![简单的安全保障具体场景](image-12.png)
### 🔥tactics for Security
![安全保障策略](image-13.png)
## chapter 10：Testability
### Testability General Scenarios
![可测试性通用场景](image-14.png)
![简单的可测试性具体场景](image-15.png)
### Tactics for Testability
![可测试性策略](image-16.png)
## chapter 11：Usability 易用性
### Usability General Scenarios
![易用性通用场景](image-23.png)
![简单的易用性具体场景](image-24.png)
### tactics for Usability
![易用性策略](image-25.png)
## chapter 12：other Quality Attributes
- **functional suitability 功能适用性**
    This characteristic represents the degree to which a product or system provides functions that meet stated and implied needs when used under specified conditions. This characteristic is composed of the following sub-characteristics.
    这一特性表示产品或系统在特定条件下提供的功能满足明确和隐含需求的程度。该特性由以下子特性组成。
    - Functional completeness / 功能完整性
    Degree to which the set of functions covers all the specified tasks and intended users' objectives.
    功能集覆盖所有指定任务和预期用户目标的程度。
    - Functional correctness / 功能正确性
    Degree to which a product or system provides accurate results when used by intended users.
    产品或系统在预期用户使用时提供准确结果的程度。
    - Functional appropriateness / 功能适当性
    Degree to which the functions facilitate the accomplishment of specified tasks and objectives.
    功能在完成指定任务和目标中的促进程度。
- **performance efficiency 性能效率**
    This characteristic represents the degree to which a product performs its functions within specified time and throughput parameters and is efficient in the use of resources (such as CPU, memory, storage, network devices, energy, materials, etc.) under specified conditions. This characteristic is composed of the following sub-characteristics.
    这一特性表示产品在特定时间和吞吐量参数内执行其功能的效率，并在特定条件下有效利用资源（如 CPU、内存、存储、网络设备、能源、材料等）。该特性由以下子特性组成。
    - Time behavior / 时间行为
    Degree to which the response time and throughput rates of a product or system, when performing its functions, meet requirements.
    产品或系统在执行功能时，其响应时间和吞吐率满足需求的程度。
    - Resource utilization / 资源利用率
    Degree to which the amounts and types of resources used by a product or system, when performing its functions, meet requirements.
    产品或系统在执行功能时，所使用的资源量和资源类型满足需求的程度。
    - Capacity / 容量
    Degree to which the maximum limits of a product or system parameter meet requirements.
    产品或系统参数的最大限制满足需求的程度。
- **compatibility 兼容性**
    Degree to which a product, system, or component can exchange information with other products, systems, or components, and/or perform its required functions while sharing the same common environment and resources. This characteristic is composed of the following sub-characteristics.
产品、系统或组件在共享相同的公共环境和资源时，与其他产品、系统或组件交换信息或执行所需功能的程度。该特性由以下子特性组成。
    - Co-existence / 共存性
    Degree to which a product can perform its required functions efficiently while sharing a common environment and resources with other products, without detrimental impact on any other product.
    产品在共享公共环境和资源时，与其他产品共存并有效执行所需功能的程度，不对其他产品产生不利影响。
    - Interoperability / 互操作性
    Degree to which a system, product, or component can exchange information with other products and mutually use the information that has been exchanged.
    系统、产品或组件与其他产品交换信息并互相利用已交换信息的程度。
- **Interaction Capability / 交互能力**
Degree to which a product or system can be interacted with by specified users to exchange information via the user interface to complete specific tasks in a variety of contexts of use. This characteristic is composed of the following sub-characteristics.
产品或系统在特定的使用情境下，用户通过用户界面与其交互并完成特定任务的能力。该特性由以下子特性组成。
    - Appropriateness recognizability / 适当性识别度
    Degree to which users can recognize whether a product or system is appropriate for their needs.
    用户识别产品或系统是否适合其需求的程度。
    - Learnability / 可学习性
    Degree to which the functions of a product or system can be learned to be used by specified users within a specified amount of time.
    用户在指定时间内学习并使用产品或系统功能的难易程度。
    - Operability / 可操作性
    Degree to which a product or system has attributes that make it easy to operate and control.
    产品或系统具有易于操作和控制的属性的程度。
    - User error protection / 用户错误保护
    Degree to which a system prevents users from operating errors.
    系统防止用户操作错误的程度。
    - User engagement / 用户参与度
    Degree to which a user interface presents functions and information in an inviting and motivating manner, encouraging continued interaction.
    用户界面以吸引人且激励性的方式呈现功能和信息，鼓励用户持续交互的程度。
    - Inclusivity / 包容性
    Degree to which a product or system can be used by people of various backgrounds (such as people of various ages, abilities, cultures, ethnicities, languages, genders, economic situations, etc.).
    产品或系统能被不同背景（如年龄、能力、文化、民族、语言、性别、经济状况等）的人群使用的程度。
- reliability  可靠性
Degree to which a system, product, or component performs specified functions under specified conditions for a specified period of time. This characteristic is composed of the following sub-characteristics.
系统、产品或组件在特定条件下、在指定时间段内执行指定功能的能力。该特性由以下子特性组成。
    - Faultlessness / 无故障性
    Degree to which a system, product, or component performs specified functions without fault under normal operation.
    系统、产品或组件在正常操作下无故障地执行指定功能的程度。
    - Availability / 可用性
    Degree to which a system, product, or component is operational and accessible when required for use.
    系统、产品或组件在需要时可操作并可以访问的程度。
    - Fault tolerance / 故障容忍性
    Degree to which a system, product, or component operates as intended despite the presence of hardware or software faults.
    系统、产品或组件在硬件或软件故障存在的情况下仍能按预期工作 的程度。
    - Recoverability / 恢复性
    Degree to which, in the event of an interruption or a failure, a product or system can recover the data directly affected and re-establish the desired state of the system.
    在中断或故障发生时，产品或系统能够恢复直接受影响的数据，并重新建立系统的期望状态的程度。
- **safety 安全性**
This characteristic represents the degree to which a product, under defined conditions, avoids a state in which human life, health, property, or the environment is endangered. This characteristic is composed of the following sub-characteristics.
该特性代表产品在特定条件下，避免进入可能危及人类生命、健康、财产或环境的状态的能力。该特性由以下子特性组成。
    - Operational Constraint / 操作约束
    Degree to which a product or system constrains its operation to within safe parameters or states when encountering operational hazards.
    当遇到操作风险时，产品或系统将其操作约束在安全参数或状态范围内的程度。
    - Risk Identification / 风险识别
    Degree to which a product can identify a course of events or operations that can expose life, property, or the environment to unacceptable risk.
    产品能够识别可能将生命、财产或环境暴露于不可接受风险的事件或操作过程的能力。
    - Fail-Safe / 故障安全
    Degree to which a product can automatically place itself in a safe operating mode, or revert to a safe condition in the event of a failure.
    在发生故障时，产品能够自动将自身置于安全操作模式，或恢复到安全状态的能力。
    - Hazard Warning / 危险警告
    Degree to which a product or system provides warnings of unacceptable risks to operations or internal controls so that they can react in sufficient time to sustain safe operations.
    产品或系统能够及时提供关于操作或内部控制不可接受风险的警告，从而使其能够在足够的时间内做出反应，维持安全操作的能力。
    - Safe Integration / 安全集成
    Degree to which a product can maintain safety during and after integration with one or more components.
    在与一个或多个组件集成过程中及之后，产品能够维持安全的能力。
## chapter 13：Architectural Tactics and Patterns
### what is a Pattern?
An architecture pattern is a package of design decisions that is found repeatedly in practice。
它有已知属性 that permits reuse, and describes 一类 architectures。

模式是对环境条件的反应中自发出现的，只要条件发生变化，模式就会自动出现等待人发现。
软件架构师必须决定如何实例化模式，如何使其适合特定的上下文和问题的约束。

- context: 
    A context is A recurring, common situation in the world that gives rise to a problem
- problem: 
    The problem, appropriately generalized, that arises in the given context. The pattern description outlines the problem and its variants, and 
describes any complementary or opposing forces. The description of the problem often includes quality attributes that must be met. 
    在给定环境中产生的问题，适当地概括模式描述概述了问题及其变体，并描述了任何互补或相反的力量。
    问题的描述通常包括必须满足的质量属性。
- solution: 
    对问题的一个成功的架构解决方案，适当地抽象。解决方案描述了解决问题的体系结构，包括如何平衡工作中的多种力量。
    解决方案将描述元素的职责和元素之间的静态关系（使用模块结构），或者描述元素的运行时行为和元素之间的交互（布置组件和连接器或分配结构）。

部分重要的模式（参照复习 PPT）：
定义、基本概念、相关质量属性（例如，可用性和性能）、弱点（如何改进？）、优势和权衡。
### Module type patterns
- Layered pattern 分层模式
### Component and Connector type patterns
- Shared Data pattern 共享数据模式
- Client-Server pattern 客户端-服务器模式
- peer to peer pattern 对等模式
- pipe-and-filter pattern 管道和过滤器模式
- Publish-Subscribe Pattern 发布-订阅模式
- Model-View-Controller pattern 模型-视图-控制器模式
#### 🔥🔥p2p
Peer-to-Peer Pattern
##### 定义
- each node can be publisher, subscriber, or broker. 
- subscribers subscribe to publishers directly, and publishers publish to subscribers directly. Therefore they must maintain knowledge of each other.
- complex in nature, mechanisms such as DHTs (Distributed Hash Tables) and CHORD are emloyed to locate nodes in the network. 在性质上复杂，机制如DHTs（分布式哈希表）和CHORD被用来定位网络中的节点。
- e.g. java distributed event service.
##### 描述
- Context: Distributed computational entities—each of which is considered 
equally important in terms of initiating an interaction and each of which provides 
its own resources—need to cooperate and collaborate to provide a service to a 
distributed community of users. /
上下文：分布式计算实体——每个实体在发起交互方面被认为是同等重要的，并且每个实体都提供自己的资源——需要合作和协作，为分布式用户群提供服务。
- Problem: How can a set of “equal” distributed computational entities be connected to each other via a common protocol so that they can organize and share 
their services with high availability and scalability? /
问题：如何通过一个共同的协议将一组“相等”的分布式计算实体连接在一起，以便它们可以组织和共享其具有高可用性和可扩展性的服务？
- Solution: In the peer-to-peer (P2P) pattern, components directly interact as 
peers. All peers are “equal” and no peer or group of peers can be critical for 
the health of the system. Peer-to-peer communication is typically a request/
reply interaction **without the asymmetry** found in the client-server pattern. 
That is, any component can, in principle, interact with any other component by 
requesting its services. The interaction may be initiated by either party—that 
is, in client-server terms, each peer component is both a client and a server. 
Sometimes the interaction is just to forward data without the need for a reply. 
Each peer provides and consumes similar services and uses the same protocol. 
Connectors in peer-to-peer systems involve bidirectional interactions, reflecting 
the two-way communication that may exist between two or more peer-to-peer 
components. /
解决方案：在对等（P2P）模式中，组件直接作为对等体进行交互。所有对等体都是“相等的”，没有对等体或对等体组可以对系统的健康状况至关重要。对等体之间的通信通常是请求/回复交互，**没有客户端-服务器模式中的不对称性**。也就是说，任何组件原则上都可以通过请求其服务与任何其他组件交互。交互可以由任一方发起——也就是说，在客户端-服务器术语中，每个对等体组件既是客户端又是服务器。有时，交互只是为了转发数据，而不需要回复。每个对等体提供和消耗类似的服务，并使用相同的协议。对等体系统中的连接器涉及双向交互，反映了两个或多个对等体组件之间可能存在的双向通信。
##### weaknesses
- managing data consistency, data/service availability, backup, and recovery are all more complex. / 管理数据一致性、数据/服务可用性、备份和恢复都更加复杂。
- small p2p systems may not be able to achieve quality goals such as performance and availability. / 小型对等系统可能无法实现性能和可用性等质量目标。
#### 🔥pipe-and-filter pattern
Pipe-and-Filter Pattern
- Context: Many systems are required to transform streams of discrete data items, 
from input to output. Many types of transformations occur repeatedly in practice, 
and so it is desirable to create these as independent, reusable parts. /
上下文：许多系统需要将离散数据项流从输入转换为输出。许多类型的转换在实践中反复发生，因此将它们创建为独立的、可重用的部分是可取的。
- Problem: Such systems need to be divided into reusable, loosely coupled components with simple, generic interaction mechanisms. In this way they can be 
flexibly combined with each other. The components, being generic and loosely 
coupled, are easily reused. The components, being independent, can execute in 
parallel. /
问题：这样的系统需要被划分为具有简单、通用交互机制的可重用、松散耦合的组件。通过这种方式，它们可以灵活地相互结合。组件是通用的和松散耦合的，很容易重用。组件是独立的，可以并行执行。
- Solution: The pattern of interaction in the pipe-and-filter pattern is characterized 
by successive transformations of streams of data. Data arrives at a filter’s input 
port(s), is transformed, and then is passed via its output port(s) through a pipe to 
the next filter. A single filter can consume data from, or produce data to, one or 
more ports. /
解决方案：管道-过滤器模式中的交互模式以数据流的连续转换为特征。数据到达过滤器的输入端口，进行转换，然后通过其输出端口通过管道传递到下一个过滤器。单个过滤器可以使用来自一个或多个端口的数据，也可以为其生成数据。
#### 🔥Publish-Subscribe Pattern
Publish-Subscribe Pattern
- Context: There are a number of independent producers and consumers of data 
that must interact. The precise number and nature of the data producers and consumers are not predetermined or fixed, nor is the data that they share.  /
上下文：有许多独立的数据生产者和消费者必须进行交互。数据生产者和消费者的确切数量和性质没有预先确定或固定，它们共享的数据也不确定。
- Problem: How can we create integration mechanisms that support the ability to 
transmit messages among the producers and consumers in such a way that they 
are unaware of each other’s identity, or potentially even their existence?  /
问题：如何创建支持在生产者和消费者之间传递消息的集成机制，以便它们不知道彼此的身份，甚至可能不知道彼此的存在？
- Solution: In the publish-subscribe pattern, summarized in Table 13.8, components interact via announced messages, or events. Components may subscribe 
to a set of events. It is the job of the publish-subscribe runtime infrastructure to 
make sure that each published event is delivered to all subscribers of that event. 
Thus, the main form of connector in these patterns is an event bus. Publisher 
components place events on the bus by announcing them; the connector then delivers those events to the subscriber components that have registered an interest in 
those events. Any component may be both a publisher and a subscriber. /
解决方案：在发布-订阅模式中，组件通过公告消息或事件进行交互。组件可以订阅一组事件。发布-订阅运行时基础设施的工作是确保每个发布的事件都传递给该事件的所有订阅者。因此，这些模式中的主要连接器形式是事件总线。发布者组件通过宣布事件将事件放在总线上；然后连接器将这些事件传递给已注册对这些事件感兴趣的订阅者组件。任何组件都可以是发布者和订阅者。

##### Solution
![Pub & Sub's solution](image-29.png)
- weaknesses
    - 发布-订阅在发送者和接收者之间增加了一层间接性。这对延迟和潜在的可伸缩性有负面影响，这取决于它的实现方式。人们通常不希望在必须满足硬实时截止日期的系统中使用发布-订阅，因为它会在消息传递时间中引入不确定性。
    - 此外，发布-订阅模式的缺点在于，它对消息的排序提供的控制较少，并且消息的传递不能得到保证（因为发送方无法知道接收方是否正在侦听）。这可能使发布-订阅模式不适用于共享状态至关重要的复杂交互。

![A typical publish-subscribe pattern realization](image-30.png)
让组件不知道彼此的身份，可以很容易地修改系统（添加或删除数据的生产者和消费者），但这是以牺牲运行时性能为代价的，因为发布-订阅基础设施是一种间接的，这会增加延迟。此外，如果发布-订阅连接器完全失败，这将是整个系统的单点故障。

- 基于列表的发布
    - 订阅是该模式的一种实现，其中每个发布者都维护一个订阅列表——一个已注册对接收事件感兴趣的订阅者列表。正如我们将在下面看到的那样，该模式的这个版本比其他版本解耦更少，因此它没有提供那么多的可修改性，但就运行时开销而言，它可以相当有效。此外，如果组件是分布式的，则不存在单点故障。

- 基于广播的发布
    - 订阅不同于基于列表的发布-订阅，发布者对订阅者的了解更少（或根本没有）。发布者只是发布事件，然后进行广播。订阅者（或在分布式系统中，代表订阅者的服务）在每个事件到达时进行检查，并确定发布的事件是否感兴趣。如果存在大量消息，并且特定订阅者对大多数消息不感兴趣，则此版本可能非常低效。

- 基于内容的发布
    - 订阅与前两种变体不同，前两种变体大致被归类为“基于主题”。主题是预定义的事件或消息，组件订阅主题中的所有事件。另一方面，内容则更为一般化。每个事件都与一组属性相关联，只有当这些属性与订阅者定义的模式匹配时才会传递给订阅者。

在实践中，发布-订阅模式通常由某种形式的面向消息的中间件实现，其中中间件作为代理实现，管理生产者和消费者之间的连接和信息通道。除了路由和有时存储消息外，此中间件通常还负责消息（或消息协议）的转换。因此，发布-订阅模式继承了代理模式的优点和缺点
#### 🔥Model-View-Controller Pattern
Model-View-Controller Pattern
- Context: User interface software is typically the most frequently modified portion 
of an interactive application. For this reason it is important to keep modifications to the user interface software separate from the rest of the system. Users often 
wish to look at data from different perspectives, such as a bar graph or a pie chart. 
These representations should both reflect the current state of the data. /
上下文：用户界面软件通常是交互式应用程序中最经常修改的部分。因此，将对用户界面软件的修改与系统的其余部分分开是很重要的。用户通常希望从不同的角度查看数据，例如条形图或饼图。这些表示应该都反映数据的当前状态。
- Problem: How can user interface functionality be kept separate from application 
functionality and yet still be responsive to user input, or to changes in the underlying application’s data? And how can multiple views of the user interface be created, maintained, and coordinated when the underlying application data changes? /
问题：如何将用户界面功能与应用程序功能分开，同时仍然对用户输入或基础应用程序数据的更改做出响应？当基础应用程序数据发生变化时，如何创建、维护和协调用户界面的多个视图？
- Solution: The model-view-controller (MVC) pattern separates application functionality into three kinds of components: 
    - A model, which contains the application’s data / 包含应用程序数据的模型
    - A view, which displays some portion of the underlying data and interacts 
with the user / 显示底层数据的某些部分并与用户交互的视图
    - A controller, which mediates between the model and the view and manages 
the notifications of state changes / 在模型和视图之间进行调解，并管理状态更改的通知
![MVC pattern](image-28.png)
##### Solution
![MVC-pattern-solution](image-27.png)
- weaknesses: 
    - 对于简单的用户界面来说，复杂性可能不值得。
    - 模型、视图和控制器抽象可能不太适合某些用户界面工具包。
### Allocation type patterns
- multi-tier pattern 多层模式
- competence center pattern 能力中心模式
- platform pattern 平台模式
- map-reduce pattern 映射-减少模式
#### 🔥🔥Map-Reduce Pattern
- Context: Businesses have a pressing **need to quickly analyze enormous volumes 
of data** they generate or access, at petabyte scale. Examples include logs of interactions in a social network site, massive document or data repositories, and pairs 
of `<source, target>` web links for a search engine. Programs for the analysis of 
this data should be easy to write, run efficiently, and be resilient with respect to 
hardware failure. /
上下文：企业迫切**需要快速分析它们生成或访问的大量数据**，达到PB级别。例如，社交网络站点中的交互日志、大量文档或数据存储库，以及搜索引擎的 `<source, target>` 网页链接对。用于分析这些数据的程序应易于编写、高效运行，并且对硬件故障具有弹性。
- Problem: For many applications with ultra-large data sets, sorting the data and 
then analyzing the grouped data is sufficient. The problem the map-reduce pattern solves is to efficiently perform a distributed and parallel sort of a large data 
set and provide a simple means for the programmer to specify the analysis to be 
done. /
问题：对于许多具有超大数据集的应用程序，对数据进行排序，然后分析分组数据就足够了。映射-减少模式解决的问题是高效地执行大数据集的分布式和并行排序，并为程序员提供简单的方法来指定要执行的分析。
- Solution: The map-reduce pattern requires three parts: First, a specialized infrastructure takes care of allocating software to the hardware nodes in a massively 
parallel computing environment and handles sorting the data as needed. A node 
may be a standalone processor or a core in a multi-core chip. Second and third are 
two programmer-coded functions called, predictably enough, map and reduce. /
解决方案：映射-减少模式需要三个部分：首先，专门的基础设施负责在大规模并行计算环境中将软件分配给硬件节点，并根据需要处理数据排序。节点可以是独立处理器或多核芯片中的一个核心。第二和第三部分是两个程序员编写的函数，可预见地称为映射和减少。

##### c & c view of map-reduce
![map-reduce](image-26.png)
##### weaknesses
当然，map-reduce模式并不适用于所有实例。一些反对采用这种模式的考虑是:
- If you do not have large data sets, then the overhead of map-reduce is not 
justified. / 如果您没有大数据集，那么 map-reduce 的开销是不合理的。
- If you cannot divide your data set into similar sized subsets, the advantages 
of parallelism are lost. / 如果您无法将数据集划分为大小相似的子集，那么并行性的优势就会丧失。
- If you have operations that require multiple reduces, this will be complex to 
orchestrate. / 如果您有需要多个减少的操作，那么这将是复杂的编排。

### 🔥Relationship between patterns and tactics
#### Patterns Comprise Tactics
正如13章的介绍中所说的，策略是设计的“构建块”，从中创建了架构模式。战术是原子，模式是分子。大多数模式由几个不同的策略组成（由这些策略构建），尽管这些策略可能都服务于一个共同的目的——例如提高可修改性——但它们经常被选择来提高不同的质量属性。例如，可以选择一种策略，使可用性模式更安全，或者减轻可修改性模式对性能的影响。
![AP and Corresponding tactics](image-31.png)

举了 layered pattern 的例子来说明。
#### Using Tactics to Augment Patterns
模式被描述为一般上下文中一类问题的解决方案。
当选择和应用模式时，其应用程序的上下文变得非常具体。因此，文档化的模式在特定情况下的应用是不明确的。

要使模式在给定的体系结构上下文中工作，我们需要从两个角度来检查它：
- 模式所做的内在质量属性权衡。模式的存在是为了达到一定的质量属性，我们需要将它们促进（和减少）的模式与我们的需求进行比较。
- 其他与模式没有直接关系的质量属性，但它仍然会影响，并且在我们的应用程序中很重要。

举了 broker pattern 的例子来说明。
# Part 3：Architecture in the Life Cycle
## 🔥🔥ATAM：Architecture Tradeoff Analysis Method 架构权衡分析方法
## 🔥ASRs
## 🔥ADD
## 🔥Utility Tree

# Open Discussion
- 🔥 The abstract common services tactic is intended to reduce coupling, but it also might reduc cohesion? / 抽象的通用服务策略旨在减少耦合，但它也可能减少内聚？
- 🔥 Discuss the choice of programming language (an example of choice of technology) and its relation to architecture in general. / 讨论编程语言的选择（技术选择的一个例子）及其与架构的一般关系。
- ...