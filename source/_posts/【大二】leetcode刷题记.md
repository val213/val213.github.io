---
title: LeetCode刷题记
tags: 
	- data structure
categories: 复习笔记
---

## linked list
### 2. Add Two Numbers
> You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
> 
> You may assume the two numbers do not contain any leading zero, except the number 0 itself.

这道题原理很简单，就是基础的带进位的加法器，但是需要注意的是链表的使用。

虚拟头节点、指向虚拟头节点的指针`dummy`和临时节点`temp`.

在进入加法循环之前，先利用`ListNode`的无参构造函数创建一个虚拟头指针作为起点，然后再定义一个临时指针`temp`，将`temp`指针初始化为`dummy`指针，即让`temp`指向`dummy`所指向的节点。

也就是说，同一个虚拟头节点拥有两个指向它的指针`dummy`和`temp`，后续`temp`作为临时指针不断移动到下一个新的有效节点，而`dummy`一直指向最开始的虚拟头节点不变。所以最后返回`dummy->next`的时候就是从第一个有效结点开始的链表全体了。


*解决方案的代码由@m_isha_125的回答提供。*
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummy=new ListNode();
        ListNode* temp=dummy;
        int carry=0;
        while(l1!=NULL || l2!=NULL || carry){
            int sum=0;
            if(l1!=NULL){
                sum+=l1->val;
                l1=l1->next;
            }
            if(l2!=NULL){
                sum+=l2->val;
                l2=l2->next;
            }
            sum+=carry;
            carry=sum/10;
            ListNode* newnode=new ListNode(sum%10);
            temp->next=newnode;
            temp=temp->next;
        }
        return dummy->next;
    }
};
```
#### 内存泄漏的问题
在C++中，`new`和`delete`是成对出现的，如果在使用`new`之后没有使用`delete`，就会造成内存泄漏。在这道题中，如果不使用`delete`，就会造成内存泄漏。
修改：
```cpp
class Solution {
public:
	ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
		ListNode* dummy=new ListNode();
		ListNode* temp=dummy;
		int carry=0;
		while(l1!=NULL || l2!=NULL || carry){
			int sum=0;
			if(l1!=NULL){
				sum+=l1->val;
				l1=l1->next;
			}
			if(l2!=NULL){
				sum+=l2->val;
				l2=l2->next;
			}
			sum+=carry;
			carry=sum/10;
			ListNode* newnode=new ListNode(sum%10);
			temp->next=newnode;
			temp=temp->next;
		}
		ListNode* ans=dummy->next;
		delete dummy;
		return ans;
	}
};
```

### 19. Remove Nth Node From End of List
> Given the head of a linked list, remove the nth node from the end of the list and return its head.      
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *fast = head, *slow = head;
        for (int i = 0; i < n; i++) fast = fast->next;
        if (!fast) return head->next;
        while (fast->next) fast = fast->next, slow = slow->next;
        slow->next = slow->next->next;
        return head;
    }
};
```
这道题有两个思路。一个是单指针遍历两次链表，但是不太好控制改变后继节点的是哪一个，各种情况很难有一个通用的循环格式（至少我尝试了一会没能成功）；第二种就是双指针，快慢指针，快指针先走n步，然后快慢指针一起走，当快指针走到链表尾部的时候，慢指针就是要删除的节点的前驱节点，然后改变后继节点即可。有一点需要注意就是，fast先走n步是绝对不会越界的，正数倒数都大于等于n个结点。

### 21. Merge Two Sorted Lists
> Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.

原来思路是挨个元素提取出来排序再放回一个新的链表里，但是……

*你的代码有一些错误，我可以帮你指出并改正。首先，你的代码没有考虑两个链表为空的情况，这可能导致空指针异常。其次，你的代码使用了一个额外的 vector 容器来存储两个链表中的元素，然后对其进行排序，这增加了空间复杂度和时间复杂度。最后，你的代码在遍历 vector 时没有创建新的节点，而是直接修改了原来的节点的值，这可能破坏了原来的链表结构，并且可能导致内存泄漏。*

建议答案：
```C++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        // 如果两个链表都为空，直接返回空指针
        if (list1 == nullptr && list2 == nullptr) return nullptr;
        // 创建一个哑节点作为结果链表的头节点
        ListNode* dummy = new ListNode();
        // 创建一个指针指向结果链表的当前节点
        ListNode* curr = dummy;
        // 当两个链表都不为空时，比较它们的头节点的值，将较小的节点添加到结果链表中，并移动对应的指针
        while (list1 != nullptr && list2 != nullptr) {
            if (list1->val < list2->val) {
                curr->next = list1;
                list1 = list1->next;
            } else {
                curr->next = list2;
                list2 = list2->next;
            }
            curr = curr->next;
        }
        // 当跳出循环时，说明有一个链表已经为空，将另一个链表剩余的部分直接接到结果链表中
        curr->next = list1 == nullptr ? list2 : list1;
        // 返回结果链表的头节点
        return dummy->next;
    }
};
```
这个代码的时间复杂度是 O(n+m)，其中 n 和 m 分别是两个链表的长度。空间复杂度是 O(1)，只需要常数级别的额外空间.


### 1071.Greatest Common Divisor of Strings
>For two strings s and t, we say "t divides s" if and only if s = t + ... + t (i.e., t is concatenated with itself one or more times).
>
>Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2.

```C++
class Solution {
public:
    string gcdOfStrings(string str1, string str2) {
        return (str1 + str2 == str2 + str1)? 
        str1.substr(0, gcd(size(str1),size(str2))): "";
    }
};
```
这道题的思路是，如果两个字符串存在最大公约数，那么这个最大公约数一定是两个字符串的前缀，所以只需要找到两个字符串的最大公约数的长度，然后截取其中一个字符串的前缀即可。

>断更了几个月，最近“金三银四”，惊觉自己还没准备好，有的同学准备蓝桥杯已经刷了不少题了，我也打算回来抽空刷刷题。


# Hot 100
## 哈希
1. 两数之和
2. 字母异位词分组
3. 最长连续序列
## 双指针
1. 移动零
2. 盛最多水的容器
>这道题非常适合使用双指针技巧来解决。这里的双指针主要指的是左右指针。你可以考虑以下思路：
>1. **初始化**：左指针`left`置于数组的开始位置，右指针`right`置于数组的末尾位置。这代表了容器的最大宽度。
>2. **移动规则**：比较左右指针指向的高度，移动较短的一端。因为容器的容量受限于较短的边，移动较长的边不会增加容器的容量，反而可能减少容量，因为容器的宽度在减小。
>3. **计算容量**：在每次指针移动后，计算当前指针所围成的容器的容量，更新最大容量。
>4. **终止条件**：当左指针和右指针相遇时，所有可能的容器都已经考虑过了，算法结束。
>这个方法的关键在于理解为什么移动较短的边可以保证不会错过最大容量的容器。这是因为，如果移动较长的边，无论较长的边的后续高度如何，由于宽度的减少，不可能得到更大的容量。而移动较短的边，有可能会遇到更高的边，从而增加容量。
3. 接雨水
> 方法三：双指针
动态规划的做法中，需要维护两个数组 leftMax 和 rightMax，因此空间复杂度是 O(n)。是否可以将空间复杂度降到 O(1)？
注意到下标 i 处能接的雨水量由 leftMax[i] 和 rightMax[i] 中的最小值决定。由于数组 leftMax 是从左往右计算，数组 rightMax 是从右往左计算，因此可以使用双指针和两个变量代替两个数组。
维护两个指针 left 和 right，以及两个变量 leftMax 和 rightMax，初始时 left=0,right=n−1,leftMax=0,rightMax=0。指针 left 只会向右移动，指针 right 只会向左移动，在移动指针的过程中维护两个变量 leftMax 和 rightMax 的值。
当两个指针没有相遇时，进行如下操作：
使用 height[left] 和 height[right] 的值更新 leftMax 和 rightMax 的值；
如果 height[left]<height[right]，则必有 leftMax<rightMax，下标 left 处能接的雨水量等于 leftMax−height[left]，将下标 left 处能接的雨水量加到能接的雨水总量，然后将 left 加 1（即向右移动一位）；
如果 height[left]≥height[right]，则必有 leftMax≥rightMax，下标 right 处能接的雨水量等于 rightMax−height[right]，将下标 right 处能接的雨水量加到能接的雨水总量，然后将 right 减 1（即向左移动一位）。
当两个指针相遇时，即可得到能接的雨水总量。
作者：力扣官方题解
链接：https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 滑动窗口
1. 无重复字符的最长子串
2. 找到字符串中所有字母异位词

滑动窗口类型的题目，通常都是在一个字符串（或数组）上通过滑动窗口来求解的。滑动窗口的思路是这样的：
1. 在字符串上使用两个指针，一个左指针和一个右指针，通常初始化为字符串的开头。
2. 移动右指针，直到找到一个符合条件的窗口，然后移动左指针，直到窗口不再符合条件。
3. 重复第 2 步，直到右指针到达字符串的末尾。

窗口滑动的过程中，需要维护一些数据结构，比如哈希表，来记录窗口中的一些信息。这些信息可以帮助我们判断窗口是否符合条件，以及在滑动窗口的过程中更新答案。

## 子串
1. 和为K的子数组
2. 滑动窗口最大值
>暴力法复杂度是O(n*K)，TLE了，使用双端队列优化，使得每个元素只被操作一次，复杂度是O(n)。
>双端队列的作用是存储当前窗口的最大值的下标，双端队列的头部是当前窗口的最大值的下标。当窗口向右移动时，我们需要把双端队列的头部的元素去掉，直到队列为空或者队列的尾部的元素大于当前元素，然后把当前元素加入队列的尾部。这样，双端队列中的元素就是按照从大到小的顺序排列的，双端队列的头部元素就是当前窗口的最大值的下标。
>一共四步骤：
>1. 移除不在窗口内的元素
>2. 移除所有小于当前元素的值
>3. 添加当前元素索引
>4. 添加当前窗口的最大值
3. 最小覆盖子串
>引入了start，len和valid来判断窗口是否符合条件，以及在滑动窗口的过程中更新答案。

## 普通数组
1. 最大子数组和
2. 合并区间
3. 轮转数组
    - 很巧妙的运用3次reverse实现了原地算法
4. 除自身以外数组的乘积
    - 解决这个问题，我们可以通过构造两个数组来实现，一个用于存储每个元素左侧所有元素的乘积，另一个用于存储每个元素右侧所有元素的乘积。最后，对于数组中的每个位置，我们只需要将这两个数组对应位置的值相乘即可得到除自身以外数组的乘积。但是，这种方法的空间复杂度为O(n)，不满足题目要求。
    - 为了达到O(1)的空间复杂度（不考虑输出数组的空间），我们可以将这两步合并，并且只使用输出数组来存储结果。具体步骤如下：

    1. **初始化输出数组**：首先，初始化一个输出数组`result`，大小与输入数组`nums`相同。`result[i]`最终将存储除 `nums[i]`以外其它所有元素的乘积。

    2. **计算左侧乘积**：从左到右遍历`nums`数组，计算每个元素左侧所有元素的乘积，并存储在`result`中。对于第一个元素，因为它左侧没有元素，所以乘积为1。

    3. **计算右侧乘积并合并**：然后，从右到左遍历 `nums` 数组，同时计算每个元素右侧所有元素的乘积。在这一步中，我们不需要另外的数组来存储右侧乘积，而是直接用一个变量`R`来表示当前元素右侧所有元素的乘积，并且将`R`与`result`数组中已经存储的左侧乘积相乘，即可得到最终结果。
    
    - 通过这种方式，我们只需要遍历两次数组，并且不需要使用额外的空间（除了输出数组），就可以得到每个元素除自身以外的数组乘积。
    - 伪代码
    ```
    初始化输出数组result，大小与nums相同，所有元素初值为1
    初始化左侧乘积为1
    从左到右遍历nums：
        result[i] = 左侧乘积
        左侧乘积 *= nums[i]

    初始化右侧乘积为1
    从右到左遍历nums：
        result[i] *= 右侧乘积
        右侧乘积 *= nums[i]
    返回result
    ```
5. 缺失的第一个正数
    - 原本的思路是将数组排序，然后遍历数组依次和res（初始化为1）比较，直到找到大于res的数，返回res。但是这样的时间复杂度是O(nlogn)，不满足题目要求。
    - 原地哈希的思路是，将数组中的数放到对应的位置上，然后遍历数组，找到第一个不符合的数，返回即可。这种方法只需要对数组进行常数次遍历，因此时间复杂度为O(n)，并且不需要额外的空间，空间复杂度为O(1)。
    - 置换或者标记，两种解法，参见[官方题解](https://leetcode.cn/problems/first-missing-positive/solutions/304743/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked)
## 矩阵
1. 矩阵置零
    - 不考虑最笨的用两个额外矩阵来标识cell需要置零的方法（O(mn)），还有两种空间复杂度依次减小的方法（O(m+n)和O(1)）;
    - O(m+n)的方法是使用两个数组来记录哪些行和列需要置零，然后再次遍历矩阵，将对应的行和列置零；
    - O(1)的方法是先判断矩阵的第一行和第一列是否需要置零，用另外的变量记录，然后使用矩阵的第一行和第一列来记录哪些行和列需要置零，然后再次遍历矩阵，将对应的行和列置零。补充上第一列和第一行的置零情况。
2. 螺旋矩阵
    - 边界法，不断缩小边界，直到边界相遇，结束循环。
3. 旋转图像
    - 要在原地旋转图像，你可以按照以下步骤进行：
    1. **转置矩阵**：首先，将矩阵转置。转置意味着行变成列，列变成行。这可以通过交换`matrix[i][j]`和`matrix[j][i]`来实现，其中`i < j`。
    2. **翻转每一行**：然后，翻转矩阵中的每一行。翻转一行意味着行中的第一个元素和最后一个元素交换，第二个元素和倒数第二个元素交换，以此类推。这可以通过交换`matrix[i][j]`和`matrix[i][n-j-1]`来实现，其中`n`是行的长度。
4. 二维矩阵搜索Ⅱ
    - 暴力法，仿照螺旋矩阵缩减边界的方法，用四个边界变量，时间复杂度是 `O(min(m, n) * (m + n))`，too long；
    - 针对题目240. 搜索二维矩阵 II，有一个更高效的解法，利用矩阵的性质：每行的元素从左到右升序排列，每列的元素从上到下升序排列。这个性质允许我们从矩阵的右上角（或左下角）开始搜索，从而有效地减少搜索空间。
以下是从右上角开始搜索的步骤：
    1. 初始化一个指针在右上角，即`row = 0`和`col = matrix[0].size() - 1`。
    2. 如果当前指向的值等于`target`，返回`true`。
    3. 如果当前指向的值小于`target`，则`target`不可能在当前行，因此`row++`。
    4. 如果当前指向的值大于`target`，则`target`不可能在当前列，因此`col--`。
    5. 重复步骤2-4，直到指针超出矩阵范围。
    6. 如果没有找到`target`，返回`false`。
这种方法的时间复杂度为O(m+n)，其中m是矩阵的行数，n是矩阵的列数。
## 链表
1. 相交链表
    - 第一反应用哈希表来检测重复的节点即为相交的起点，但是需要O(n)的额外空间。时间复杂度为O(n)。
    - 有一种更高效的解法，不需要额外的存储空间。这种方法基于两个观察结果：
        - 两个链表相交后，后面的部分必然相同。
        - 如果同时遍历两个链表，当一个链表到达末尾时跳到另一个链表的头部继续遍历，另一个链表也是如此，那么它们会在交点处相遇或在链表末尾的nullptr处相遇（如果不相交）。
        - 这种方法的时间复杂度为O(N+M)，空间复杂度为O(1)，其中N和M分别是两个链表的长度。
2. 反转链表
    - 递归和迭代两种方法，递归的方法是比较直观的，迭代的方法是比较高效的。
    - 使用迭代进行链表反转的操作可以记下来，因为这种方法在其他链表题目中也经常用到。
    ```cpp
    ListNode *prev = nullptr, *curr = head;
        while (curr) {
            ListNode *next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    ```
3. 回文链表
    - 直接想到用哈希表，没用上回文的性质，空间复杂度O(n)，时间复杂度O(n)；
    - 链表反转一半，反转后检查链表半部分是否一样
4. 环形链表
    - 快慢指针
5. 环形链表Ⅱ
    - 比起环形链表，这道题需要找到环的入口，可以用快慢指针，但是需要证明，具体证明可以参考[官方题解](https://leetcode.cn/problems/linked-list-cycle-ii/solutions/12616/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/)
6. 合并两个有序链表
    - 哨兵节点。
    ```cpp
    ListNode dummy(0); // 创建一个哨兵节点
    dummy.next = head;
    ListNode* curr = &dummy; // curr指针指向哨兵节点，用于追踪当前处理的节点对的前一个节点
    ```
7. 两数相加
    - 同样用到了哨兵节点和tail指针来构建新的链表。
8. 删除链表的倒数第N个节点
    - 尝试使用一趟遍历完成
    - 双指针，一个指针先走n步，然后两个指针一起走，直到第一个指针走到末尾，第二个指针就是要删除的节点的前驱节点。
9. 两两交换链表中的节点
    - 节点对
    - 哨兵again，学会用dump，用节点对的前一个节点来开始针对节点对的交换。
10. K个一组反转链表
    - 反转链表的方法作为子函数。
    - 用哨兵节点，prev 和 end 指针来分组处理
    - 细节：
        - end->next = nullptr; 切断分组便于反转
        - 反转后， start->next = nextGroup;
        - 重置 prev 和 end 指针，准备处理下一组
11. 随机链表的复制
    - 方法1，使用哈希表维护原链表和新链表的对应关系，通过两次遍历分别复制 next 和 random 指针。时间复杂度O(n)，空间复杂度O(n)；
    - 方法2，不使用额外空间，将新节点插入到原节点的后面，然后分离新旧链表。时间复杂度O(n)，空间复杂度O(1)。
12. 排序链表
    - "题目要求时间空间复杂度分别为 O(nlogn) 和 O(1)，根据时间复杂度我们自然想到二分法，从而联想到归并排序；"
    - 归并排序的思路是先找到链表的中点，然后递归地对两个子链表进行排序，最后合并两个有序链表。
    - 递归的终止条件是链表的长度小于或等于 1，即当链表为空或者只包含一个节点时，不需要对链表进行排序，直接返回即可。
    - 细节：fast指针从head->next开始，slow指针从head开始，这样可以保证slow指针在中点的前一个节点，方便分割链表。
    - 如果使用自底向上迭代的归并排序，不需要额外的递归栈空间。
13. 合并 K 个升序链表
    - 前置知识：合并两个有序链表
    - 三种方法：
        - 朴素的顺序合并
        - 分治合并
        - 使用优先队列
    - 顺序合并就是每一次合并两个链表，合并后作为一个链表继续和下一个链表合并。时间复杂度是O(k2n)，空间复杂度是O(1)；
    - 分治合并是将k个链表分成两部分，分别合并，然后再合并两个合并后的链表。时间复杂度是O(knlogk)，空间复杂度是O(logk)；
    - 使用优先队列和最小堆的想法来自于合并 k 个升序链表问题的核心需求：在任何时刻，我们都需要从 k 个链表中找到当前最小的节点来进行合并。优先队列和最小堆恰好提供了这样的功能，它们能够保证在对数时间复杂度内完成插入和删除最小元素的操作，这对于解决这个问题非常有效。
14. LRU 缓存
    - 类似操作系统实验的作业，用双向链表和哈希表实现。
    - 通过链表头节点和尾节点的增加删除移动来实现。
## 二叉树
1. 二叉树的中序遍历
    - 三种方法：递归、迭代、Morris遍历
    - 递归比较简单，root不断深入，如果为空则返回，否则递归左子树，放入结果，递归右子树。但是由于效率低，不推荐使用。
    - 迭代显式使用栈。栈的作用是模拟递归的过程，将递归的过程转化为迭代的过程。在迭代的过程中，我们需要模拟递归的调用栈，因此我们需要手动维护栈。但是三种遍历的迭代代码不太一样。容易“一看就懂，一写就废”
    - Morris 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 O(1)。Morris遍历的思路是利用线索二叉树，将二叉树的空闲指针利用起来，将空闲指针指向中序遍历的前驱节点，这样可以在O(1)的空间复杂度内完成中序遍历。
        - 假设当前遍历到的节点为 x，将 x 的左子树中最右边的节点的右孩子指向 x，这样在左子树遍历完成后我们通过这个指向走回了 x，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度
        作者：力扣官方题解
        链接：https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/412886/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/
    - 其实还有网友的第四种方法：颜色标记法。兼具栈迭代方法的高效，又像递归方法一样简洁易懂，更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码。
        - 在栈中使用元组来实现颜色标记节点的状态，新节点为白色，已访问的节点为灰色。如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。如果遇到的节点为灰色，则将节点的值输出。
        - https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/25220/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/?envType=study-plan-v2&envId=top-100-liked
2. 二叉树的最大深度
    - 深搜递归
    - 广搜队列迭代
3. 翻转二叉树
    - 递归
4. 对称二叉树
    - 方法1：直接递归比较左右子树的值
    - 方法2：翻转左子树后再比较左右子树是否一致（其实没必要，复杂度变高了）
5. 二叉树的直径
    - 递归，递归函数返回当前节点的深度，然后计算左右子树的深度之和，更新最大直径。
6. 二叉树的层序遍历
    - 广搜，队列迭代，用size表示每一层的节点数。
7. 将有序数组转换为二叉搜索树
    - 递归，每次取中间的数作为根节点，然后递归构建左右子树。
8. 验证二叉搜索树
    - 递归，每次传入上下界，判断左右子树是否满足条件。
9. 二叉搜索树中第k小的元素
    - 中序遍历即可
10. 二叉树的右视图
    - 层序遍历的基础上，每次取最右边的节点记录下来即可
11. 二叉树展开为链表
    - 递归，先展开左右子树，然后将左子树插入到右子树的位置，然后将左子树置空，原来的右子树接到新的右子树的最右边。
12. 从前序与中序遍历序列构造二叉树
    - 从前序遍历的第一个节点找到根节点
    - 在中序遍历中找到根节点的位置，得到左右子树的节点数量
    - 递归构建左右子树
13. 路径总和Ⅲ
    - 暴力 On2
    - 前缀和，有点费解
14. 二叉树的最近公共祖先
    - 同样是递归遍历，递归函数返回值是当前节点是否包含p或q，然后递归左右子树，如果左右子树都包含p或q，那么当前节点就是最近公共祖先。
15. 二叉树中的最大路径和
    - 递归，递归函数返回当前节点的最大贡献值，即当前节点的值加上左右子树的最大贡献值，然后更新最大路径和。
## 图论
1. 岛屿数量
    - 岛屿问题是 网格 DFS 问题的典型代表
    - [岛屿类问题的通用解法、DFS 遍历框架](https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/?source=vscode)
    - 还可以用并查集做，但是似乎有点复杂
2. 腐烂的橘子
    - 考虑多个腐烂的橘子情况
    - 用队列迭代，每次遍历一层，直到队列为空
    - 用一个变量记录新鲜橘子的数量，如果最后新鲜橘子数量不为0，返回-1
    - 可以用方向数组来把四个方向的if写的优雅一点（）
3. 课程表
    - 检查图是否成环
    - 队列层序遍历，每次将入度为0的节点加入队列，然后更新入度，直到队列为空
    - 图的存储：邻接表
    - 有向图的拓扑排序
4. 实现trie（前缀树）
    - unordered_map<char, Trie*> children;
    - bool isEnd;
    - TrieNode() : isEnd(false) {}    
## 回溯
回溯算法非常适合解决这类枚举所有可能解的问题。
通用方法：
- 递归回溯。递归之前将当前元素加入路径，递归之后将当前元素从路径中移除。
- 返回条件时把路径加入结果。
1. 全排列
    - 递归回溯。递归之前将当前元素加入路径，递归之后将当前元素从路径中移除。
    - 用depth变量控制递归的深度，当深度等于数字串的长度时，返回。
    - 返回时把路径加入结果。
2. 子集
    - 递归回溯。递归之前将当前元素加入路径，递归之后将当前元素从路径中移除。
    - 通过start变量控制递归的起始位置，避免重复。
3. 电话号码的字母组合
    - 遍历每个数字对应的字母，递归回溯。
    - 用depth变量控制递归的深度，当深度等于数字串的长度时，将路径加入结果。
4. 组合总和
    - 每一次回溯把 target 减去选中的数，当 target 小于 0 时，说明当前路径不合法，直接返回
    - 由于每个数字可以被重复选取，所以从当前数字开始继续遍历
5. 括号生成
    - 递归终止条件, 当左右括号数量都等于 n 时，说明已经找到了一个合法的括号组合
    - 当左括号数量小于 n 时，可以继续添加左括号，当右括号数量小于左括号数量时，可以继续添加右括号
6. 单词搜索
    - 在二维 board 里搜索字符串 word，从第一个匹配的字符开始，递归搜索上下左右四个方向。
    - 在回溯前后标记已访问的元素，避免重复访问。回溯返回后，需要恢复原来的状态。
7. 分割回文串
    - 递归逻辑：从 start 开始，尝试所有可能的分割点。对于每一个分割点，判断 start 到当前分割点之间的子字符串是否是回文：
        - 如果是回文，则将这个子字符串加入到 current 中，并从当前分割点的下一个位置继续递归搜索。
        - 完成递归后，需要撤销上一步的选择（即从 current 中移除最后添加的子字符串），以便尝试其他的分割方案。

    - 常规思路，判断回文的时候用数组索引，复杂度比较高
    - 更优的解法：dp记忆化搜索
        - 初始化记忆化数组：创建一个二维数组dp，其中dp[i][j]表示字符串从索引i到j的子串是否是回文。这个数组可以在算法开始前预先计算填充，以避免在回溯过程中的重复计算。
        - 预处理填充dp数组：通过双重循环遍历所有可能的子串，使用动态规划的方法填充dp数组。状态转移方程为：如果s[i] == s[j]且(j-i <= 2 || dp[i+1][j-1])，则dp[i][j] = true，表示子串是回文。
        - 修改回溯函数：在回溯函数中，使用dp数组来判断子串是否是回文，而不是每次都调用isPalindrome函数。
8. N皇后
    - 从第一行开始，尝试在每一列放置皇后。
    - 对于每个位置，检查放置皇后是否合法（即该位置的同行、同列、两个对角线上没有其他皇后）。
    - 如果当前位置合法，将其标记为'Q'，并递归尝试放置下一行的皇后。
    - 如果在当前行的所有列都无法放置皇后或已经成功放置所有皇后，则回溯到上一行，移动皇后到下一个位置
## 二分查找
- 搜索插入位置
    - 二分的一般方法，双指针，mid = left + (right - left) / 2
    - 当 mid < target 时，left 被设置为 mid + 1 而不是 mid，原因如下：
        - 避免无限循环：如果我们将 left 设置为 mid 而不是 mid + 1，并且 target 大于 nums[mid]，那么下一次循环时，left 和 mid 可能会保持不变，导致循环无法进展。通过设置 left 为 mid + 1，我们确保搜索区间在每次迭代时都会缩小，从而避免了无限循环。
        - 逻辑上的正确性：当 nums[mid] < target 时，意味着 target 一定不在当前的 left 到 mid 区间内（包括 mid），因为 mid 的值都小于 target。所以，下一次搜索应该从 mid + 1 开始，即排除了当前 mid 及其左侧的所有元素。
- 搜索二维矩阵
    - 同上，转化为二维其实是一维的问题，多了一步用除法和取余数来转化坐标
- 在排序数组中查找元素的第一个和最后一个位置
    - 使用二分搜索算法两次来找到排序数组中元素的第一个和最后一个位置：
        - 第一个位置：通过调整二分搜索的条件，当找到目标值 target 时，不立即返回，而是继续缩小右边界 right 至 mid，以尝试找到目标值的最左侧边界。这样做可以确保如果目标值有多个，我们能找到第一个位置。
        - 最后一个位置：当找到目标值时，调整左边界 left 至 mid + 1
- 搜索旋转排序数组
    - 思路1：通过某种遍历找出旋转点的下标，从此以后下标都基于此都特殊处理，照常进行二分查找
    - 思路2：找出旋转体的下标，然后使用旋转点将数组分为两部分，每部分内部仍然是有序的。确定 target 应该在哪一部分进行查找。在确定的部分内使用二分查找寻找 target。
    - 思路3：直接二分查找，根据mid和left、right的大小关系判断target在哪一部分，然后继续二分查找
- 寻找旋转排序数组中的最小值
    - 修改一下普通二分查找的模板
    - 总结经验：
        - 不带等号的判断条件下，结果mid不加1；带等号的判断条件下，结果mid加1
- 寻找两个正序数组的中位数
    - 暴力排序、归并排序法略，时间复杂度O(m+n)
    - 二分法
        - 分割线法
            - 假设两个数组的长度分别为 m 和 n。我们需要找到合并后数组中第 (m+n+1)/2 位置和 (m+n+2)/2 位置的数（对于奇数和偶数情况都适用，如果是奇数两个位置是同一个）。
            - 我们在较短的数组上进行二分查找，假设在 nums1 中查找，找到一个位置 i，使得 nums1[i-1] <= nums2[j] 且 nums2[j-1] <= nums1[i]，其中 j = (m + n + 1) / 2 - i。这样，nums1[i-1]、nums1[i]、nums2[j-1]、nums2[j] 就围成了一个“窗口”（在分割线左右的四个数），中位数就在这个窗口中产生。
            - 注意处理边界情况，比如 i=0，i=m，j=0，j=n
## 栈
- 有效的括号
- 最小栈
- 字符串解码
- 每日温度
- 柱状图中最大的矩形
## 堆
- 数组中的第K个最大元素
- 前K个高频元素
- 数据流的中位数
## 贪心算法
- 买卖股票的最佳时机
- 跳跃游戏
- 跳跃游戏Ⅱ
- 划分字母区间
## 动态规划
- 爬楼梯
- 杨辉三角
- 打家劫舍
- 完全平方数
- 零钱兑换
- 单词划分
- 最长递增子序列
- 乘积最大子数组
- 分割等和子集
- 最长有效括号
## 多维动态规划
- 不同路径
- 最小路径和
- 最长回文子串
- 最长公共子序列
- 编辑距离
## 技巧
- 只出现一次的数字
- 多数元素
- 颜色分类
- 下一个排列
- 寻找重复数